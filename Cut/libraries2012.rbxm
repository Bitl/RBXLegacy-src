<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Script" referent="RBX0">
		<Properties>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Sorter</string>
			<ProtectedString name="Source">print(&quot;Special thanks to Bitl, Carrot, iago, winsupermario1234, Khangaroo, drslicendice, coke, TheLivingBee, Raymonf, and a bunch of play - testers for help making 2012 fully stable and work. 8)&quot;)
script.Playerlist:clone().Parent = game.StarterGui
script.Dialogs:clone().Parent = game.StarterGui
script.Backpack:clone().Parent = game.StarterGui
script.Health:clone().Parent = game.StarterGui
script.Menu:clone().Parent = game.StarterGui
script.ReenableDialogScript:clone().Parent = game.Lighting
script.TimeoutScript:clone().Parent = game.Lighting
script.ResetCommand:clone().Parent = game.Workspace
script.Notifications:clone().Parent = game.StarterGui
script:remove()</ProtectedString>
		</Properties>
		<Item class="Script" referent="RBX1">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ReenableDialogScript</string>
				<ProtectedString name="Source">wait(5)
local dialog = script.Parent
if dialog:IsA(&quot;Dialog&quot;) then
&#9;dialog.InUse = false
end&#9;
script:Remove()
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX2">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ResetCommand</string>
				<ProtectedString name="Source">function onChatted(msg, speaker)
    
    source = string.lower(speaker.Name)
    msg = string.lower(msg)
    -- Note: This one is NOT caps sensitive

    if msg == &quot;!!!reset&quot; then
        speaker.Character.Humanoid.Health = 0
    end
end

function onPlayerEntered(newPlayer)
        newPlayer.Chatted:connect(function(msg) onChatted(msg, newPlayer) end) 
end
 
game.Players.ChildAdded:connect(onPlayerEntered)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX3">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TimeoutScript</string>
				<ProtectedString name="Source">wait(5)
local dialog = script.Parent
if dialog:IsA(&quot;Dialog&quot;) then
&#9;dialog.InUse = false
end&#9;
script:Remove()
</ProtectedString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBX4">
			<Properties>
				<string name="Name">Dialogs</string>
			</Properties>
			<Item class="Frame" referent="RBX5">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ControlFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX6">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">BottomLeftControl</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-46</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>130</XO>
							<YS>0</YS>
							<YO>46</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="NotificationBox" referent="RBX7">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">NotificationBox</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-200</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0.419999987</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX8">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Init</string>
					<ProtectedString name="Source">--rbxsig%XeVmMtUuu+dXh8pEbcaTkr2m9RJZXY42LaACJ12YYcuPtOUxy4Azi8uMDGU8ZTh7cvZC9BlOWgqmZHKjESSdfOZl0/cgd2JKHPZ2UqiqA1slJa7R5GtCcGXlNPHW8KDYgJGRuwe8h5CSiMDOl6QLTSEegTOG7fzHk/n1AFcRN8I=%
--rbxassetid%39250920%
--fixed by Carrot#0559

function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

local beter = game.Lighting

function waitForDialogChildrenMyLord(beter, name)
&#9;&#9;while not beter:FindFirstChild(name) do
&#9;&#9;&#9;beter.ChildAdded:wait()
&#9;&#9;end
end

local bois = game.Players.LocalPlayer.PlayerGui

function waitForFaker(bois, name)
&#9;&#9;while not bois:FindFirstChild(name) do
&#9;&#9;&#9;bois.ChildAdded:wait()
&#9;&#9;end
end


local mainFrame
local choices = {}
local lastChoice
local choiceMap = {}
local currentConversationDialog
local currentConversationPartner
local currentAbortDialogScript

local tooFarAwayMessage =           &quot;You are too far away to chat!&quot;
local tooFarAwaySize = 300
local characterWanderedOffMessage = &quot;Chat ended because you walked away&quot;
local characterWanderedOffSize = 350
local conversationTimedOut =        &quot;Chat ended because you didn&apos;t reply&quot;
local conversationTimedOutSize = 350

local player
local screenGui
local chatNotificationGui
local messageDialog
local timeoutScript = game.Lighting.ReenableDialogScript
local reenableDialogScript = game.Lighting.TimeoutScript
local dialogMap = {}
local dialogConnections = {}

local gui = nil
--waitForDialogChildrenMyLord(game,&quot;CoreGui&quot;)
--waitForDialogChildrenMyLord(game.CoreGui,&quot;RobloxGui&quot;)
--if game.CoreGui.RobloxGui:FindFirstChild(&quot;ControlFrame&quot;) then
--&#9;gui = game.CoreGui.RobloxGui.ControlFrame
--else
--&#9;gui = game.CoreGui.RobloxGui
--end

function currentTone()
&#9;if currentConversationDialog then
&#9;&#9;return currentConversationDialog.Tone
&#9;else
&#9;&#9;return Enum.DialogTone.Neutral
&#9;end
end
&#9;

function createChatNotificationGui()
&#9;chatNotificationGui = Instance.new(&quot;BillboardGui&quot;)
&#9;chatNotificationGui.Name = &quot;ChatNotificationGui&quot;
&#9;chatNotificationGui.ExtentsOffset = Vector3.new(0,1,0)
&#9;chatNotificationGui.Size = UDim2.new(4, 0, 5.42857122, 0)
&#9;chatNotificationGui.SizeOffset = Vector2.new(0,0)
&#9;chatNotificationGui.StudsOffset = Vector3.new(0.4, 4.3, 0)
&#9;chatNotificationGui.Enabled = true
&#9;chatNotificationGui.Active = true

&#9;local image = Instance.new(&quot;ImageLabel&quot;)
&#9;image.Name = &quot;Image&quot;
&#9;image.Active = false
&#9;image.BackgroundTransparency = 1
&#9;image.Position = UDim2.new(0,0,0,0)
&#9;image.Size = UDim2.new(1.0,0,1.0,0)
&#9;image.Image = &quot;&quot;
&#9;image.Parent = chatNotificationGui
   

&#9;local button = Instance.new(&quot;ImageButton&quot;)
&#9;button.Name = &quot;Button&quot;
&#9;button.AutoButtonColor = false
&#9;button.Position = UDim2.new(0.0879999995, 0, 0.0529999994, 0)
&#9;button.Size = UDim2.new(0.829999983, 0, 0.460000008, 0)
&#9;button.Image = &quot;&quot;
&#9;button.BackgroundTransparency = 1
&#9;button.Parent = image
end

function getChatColor(tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;return Enum.ChatColor.Blue
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;return Enum.ChatColor.Green
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;return Enum.ChatColor.Red
&#9;end
end

function styleChoices(tone)
&#9;for i, obj in pairs(choices) do
&#9;&#9;resetColor(obj, tone)
&#9;end
&#9;resetColor(lastChoice, tone)
end

function styleMainFrame(tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;mainFrame.Style = Enum.FrameStyle.ChatBlue
&#9;&#9;mainFrame.Tail.Image = &quot;rbxasset://textures/chatBubble_botBlue_tailRight.png&quot;
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;mainFrame.Style = Enum.FrameStyle.ChatGreen
&#9;&#9;mainFrame.Tail.Image = &quot;rbxasset://textures/chatBubble_botGreen_tailRight.png&quot;
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;mainFrame.Style = Enum.FrameStyle.ChatRed
&#9;&#9;mainFrame.Tail.Image = &quot;rbxasset://textures/chatBubble_botRed_tailRight.png&quot;
&#9;end
&#9;
&#9;styleChoices(tone)
end
function setChatNotificationTone(gui, purpose, tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;gui.Image.Image = &quot;rbxasset://textures/chatBubble_botBlue_notify_bkg.png&quot;
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;gui.Image.Image = &quot;rbxasset://textures/chatBubble_botGreen_notify_bkg.png&quot;
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;gui.Image.Image = &quot;rbxasset://textures/chatBubble_botRed_notify_bkg.png&quot;
&#9;end
&#9;if purpose == Enum.DialogPurpose.Quest then
&#9;&#9;gui.Image.Button.Image = &quot;rbxasset://textures/chatBubble_bot_notify_bang.png&quot;
&#9;elseif purpose == Enum.DialogPurpose.Help then
&#9;&#9;gui.Image.Button.Image = &quot;rbxasset://textures/chatBubble_bot_notify_question.png&quot;
&#9;elseif purpose == Enum.DialogPurpose.Shop then
&#9;&#9;gui.Image.Button.Image = &quot;rbxasset://textures/chatBubble_bot_notify_money.png&quot;
&#9;end
end

function createMessageDialog()
&#9;messageDialog = Instance.new(&quot;Frame&quot;);
&#9;messageDialog.Name = &quot;DialogScriptMessage&quot;
&#9;messageDialog.Style = Enum.FrameStyle.RobloxRound
&#9;messageDialog.Visible = false

&#9;local text = Instance.new(&quot;TextLabel&quot;)
&#9;text.Name = &quot;Text&quot;
&#9;text.Position = UDim2.new(0,0,0,-1)
&#9;text.Size = UDim2.new(1,0,1,0)
&#9;text.FontSize = Enum.FontSize.Size14
&#9;text.BackgroundTransparency = 1
&#9;text.TextColor3 = Color3.new(1,1,1)
&#9;text.Parent = messageDialog
end

function showMessage(msg, size)
&#9;messageDialog.Text.Text = msg
&#9;messageDialog.Size = UDim2.new(0,size,0,40)
&#9;messageDialog.Position = UDim2.new(0.5, -size/2, 0.5, -40)
&#9;messageDialog.Visible = true
&#9;wait(2)
&#9;messageDialog.Visible = false
end

function variableDelay(str)
&#9;local length = math.min(string.len(str), 100)
&#9;wait(0.75 + ((length/75) * 1.5))
end

function resetColor(frame, tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;frame.BackgroundColor3 = Color3.new(0/255, 0/255,   179/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(45/255, 142/255, 245/255) 
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;frame.BackgroundColor3 = Color3.new(0/255, 77/255,   0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(0/255, 190/255, 0/255) 
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;frame.BackgroundColor3 = Color3.new(140/255, 0/255, 0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(255/255,88/255, 79/255) 
&#9;end
end

function highlightColor(frame, tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;frame.BackgroundColor3 = Color3.new(2/255, 108/255,   255/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(1, 1, 1) 
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;frame.BackgroundColor3 = Color3.new(0/255, 128/255,   0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(1, 1, 1) 
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;frame.BackgroundColor3 = Color3.new(204/255, 0/255, 0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(1, 1, 1) 
&#9;end
end

function wanderDialog()
&#9;print(&quot;Wander&quot;)
&#9;mainFrame.Visible = false
&#9;endDialog()
&#9;showMessage(characterWanderedOffMessage, characterWanderedOffSize)
end

function timeoutDialog()
&#9;print(&quot;Timeout&quot;)
&#9;mainFrame.Visible = false
&#9;endDialog()
&#9;showMessage(conversationTimedOut, conversationTimedOutSize)
end
function normalEndDialog()
&#9;print(&quot;Done&quot;)
&#9;endDialog()
end

function endDialog()
   if currentAbortDialogScript then
&#9;&#9;currentAbortDialogScript:Remove()
&#9;&#9;currentAbortDialogScript = nil
&#9;end

&#9;local dialog = currentConversationDialog 
&#9;currentConversationDialog = nil
&#9;if dialog and dialog.InUse then
&#9;&#9;local reenableScript = reenableDialogScript:Clone()
&#9;&#9;reenableScript.archivable = false
&#9;&#9;reenableScript.Disabled = false
&#9;&#9;reenableScript.Parent = dialog
&#9;end

&#9;for dialog, gui in pairs(dialogMap) do
&#9;&#9;if dialog and gui then
&#9;&#9;&#9;gui.Enabled = not dialog.InUse
&#9;&#9;end
&#9;end

&#9;currentConversationPartner = nil
end

function sanitizeMessage(msg)
  if string.len(msg) == 0 then
     return &quot;...&quot;
  else
     return msg
  end
end

function selectChoice(choice)
&#9;renewKillswitch(currentConversationDialog)

&#9;--First hide the Gui
&#9;mainFrame.Visible = false
&#9;if choice == lastChoice then
&#9;&#9;game.Chat:Chat(game.Players.LocalPlayer.Character, &quot;Goodbye!&quot;, getChatColor(currentTone()))
&#9;&#9;
&#9;&#9;normalEndDialog()
&#9;else 
&#9;&#9;local dialogChoice = choiceMap[choice]

&#9;&#9;game.Chat:Chat(game.Players.LocalPlayer.Character, sanitizeMessage(dialogChoice.UserDialog), getChatColor(currentTone()))
&#9;&#9;wait(1)
&#9;&#9;--currentConversationDialog:SignalDialogChoiceSelected(player, dialogChoice)
&#9;&#9;game.Chat:Chat(currentConversationPartner, sanitizeMessage(dialogChoice.ResponseDialog), getChatColor(currentTone()))
&#9;
&#9;&#9;variableDelay(dialogChoice.ResponseDialog)
&#9;&#9;presentDialogChoices(currentConversationPartner, dialogChoice:GetChildren())
&#9;end 
end

function newChoice(numberText)
&#9;local frame = Instance.new(&quot;TextButton&quot;)
&#9;frame.BackgroundColor3 = Color3.new(0/255, 0/255, 179/255)
&#9;frame.AutoButtonColor = false
&#9;frame.BorderSizePixel = 0
&#9;frame.Text = &quot;&quot;
&#9;frame.MouseEnter:connect(function() highlightColor(frame, currentTone()) end)
&#9;frame.MouseLeave:connect(function() resetColor(frame, currentTone()) end)
&#9;frame.MouseButton1Click:connect(function() selectChoice(frame) end)

&#9;local number = Instance.new(&quot;TextLabel&quot;)
&#9;number.Name = &quot;Number&quot;
&#9;number.TextColor3 = Color3.new(127/255, 212/255, 255/255)
&#9;number.Text = numberText
&#9;number.FontSize = Enum.FontSize.Size14
&#9;number.BackgroundTransparency = 1
&#9;number.Position = UDim2.new(0,4,0,2)
&#9;number.Size = UDim2.new(0,20,0,24)
&#9;number.TextXAlignment = Enum.TextXAlignment.Left
&#9;number.TextYAlignment = Enum.TextYAlignment.Top
&#9;number.Parent = frame

&#9;local prompt = Instance.new(&quot;TextLabel&quot;)
&#9;prompt.Name = &quot;UserPrompt&quot;
&#9;prompt.BackgroundTransparency = 1
&#9;prompt.TextColor3 = Color3.new(1,1,1)
&#9;prompt.FontSize = Enum.FontSize.Size14
&#9;prompt.Position = UDim2.new(0,28, 0, 2)
&#9;prompt.Size = UDim2.new(1,-32, 1, -4)
&#9;prompt.TextXAlignment = Enum.TextXAlignment.Left
&#9;prompt.TextYAlignment = Enum.TextYAlignment.Top
&#9;prompt.TextWrap = true
&#9;prompt.Parent = frame

&#9;return frame
end
function initialize(parent)
&#9;choices[1] = newChoice(&quot;1)&quot;)
&#9;choices[2] = newChoice(&quot;2)&quot;)
&#9;choices[3] = newChoice(&quot;3)&quot;)
&#9;choices[4] = newChoice(&quot;4)&quot;)

&#9;lastChoice = newChoice(&quot;5)&quot;)
&#9;lastChoice.UserPrompt.Text = &quot;Goodbye!&quot;
&#9;lastChoice.Size = UDim2.new(1,0,0,28)

&#9;mainFrame = Instance.new(&quot;Frame&quot;)
&#9;mainFrame.Name = &quot;UserDialogArea&quot;
&#9;mainFrame.Size = UDim2.new(0, 350, 0, 200)
&#9;mainFrame.Style = Enum.FrameStyle.ChatBlue
&#9;mainFrame.Visible = false
&#9;
&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.Name = &quot;Tail&quot;
&#9;imageLabel.Size = UDim2.new(0,62,0,53)
&#9;imageLabel.Position = UDim2.new(1,8,0.25)
&#9;imageLabel.Image = &quot;rbxasset://textures/chatBubble_botBlue_tailRight.png&quot;
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Parent = mainFrame
&#9;&#9;
&#9;for n, obj in pairs(choices) do
&#9;&#9;obj.Parent = mainFrame
&#9;end
&#9;lastChoice.Parent = mainFrame

&#9;mainFrame.Parent = parent
end

function presentDialogChoices(talkingPart, dialogChoices)
&#9;if not currentConversationDialog then 
&#9;&#9;return 
&#9;end

&#9;currentConversationPartner = talkingPart
&#9;local sortedDialogChoices = {}
&#9;for n, obj in pairs(dialogChoices) do
&#9;&#9;if obj:IsA(&quot;DialogChoice&quot;) then
&#9;&#9;&#9;table.insert(sortedDialogChoices, obj)
&#9;&#9;end
&#9;end
&#9;table.sort(sortedDialogChoices, function(a,b) return a.Name &lt; b.Name end)

&#9;if #sortedDialogChoices == 0 then
&#9;&#9;normalEndDialog()
&#9;&#9;return
&#9;end

&#9;local pos = 1
   local yPosition = 0
&#9;choiceMap = {}
&#9;for n, obj in pairs(choices) do
&#9;&#9;obj.Visible = false
&#9;end

&#9;for n, obj in pairs(sortedDialogChoices) do
&#9;&#9;if pos &lt;= #choices then
&#9;&#9;&#9;--3 lines is the maximum, set it to that temporarily
&#9;&#9;&#9;choices[pos].Size = UDim2.new(1, 0, 0, 24*3)
&#9;&#9;&#9;choices[pos].UserPrompt.Text = obj.UserDialog
&#9;&#9;&#9;local height = math.ceil(choices[pos].UserPrompt.TextBounds.Y/24)*24

&#9;&#9;&#9;choices[pos].Position = UDim2.new(0, 0, 0, yPosition)
&#9;&#9;&#9;choices[pos].Size = UDim2.new(1, 0, 0, height)
&#9;&#9;&#9;choices[pos].Visible = true
&#9;&#9;
&#9;&#9;&#9;choiceMap[choices[pos]] = obj

&#9;&#9;&#9;yPosition = yPosition + height
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;end

&#9;lastChoice.Position = UDim2.new(0,0,0,yPosition)&#9;
&#9;lastChoice.Number.Text = pos .. &quot;)&quot;

&#9;mainFrame.Size = UDim2.new(0, 350, 0, yPosition+24+32)
&#9;mainFrame.Position = UDim2.new(0,20,0.0, -mainFrame.Size.Y.Offset-20)
&#9;styleMainFrame(currentTone())
&#9;mainFrame.Visible = true
end

function doDialog(dialog)
&#9;while not Instance.Lock(dialog, player) do
&#9;&#9;wait()
&#9;end

&#9;if dialog.InUse then
&#9;&#9;Instance.Unlock(dialog)
&#9;&#9;return &#9;&#9;&#9;
&#9;else
&#9;&#9;dialog.InUse = true
&#9;&#9;Instance.Unlock(dialog)
&#9;end

&#9;currentConversationDialog = dialog
&#9;game.Chat:Chat(dialog.Parent, dialog.InitialPrompt, getChatColor(dialog.Tone))
&#9;variableDelay(dialog.InitialPrompt)

&#9;presentDialogChoices(dialog.Parent, dialog:GetChildren())
end

function renewKillswitch(dialog)
&#9;if currentAbortDialogScript then
&#9;&#9;currentAbortDialogScript:Remove()
&#9;&#9;currentAbortDialogScript = nil
&#9;end

&#9;currentAbortDialogScript = timeoutScript:Clone()
&#9;currentAbortDialogScript.archivable = false
&#9;currentAbortDialogScript.Disabled = false
&#9;currentAbortDialogScript.Parent = dialog
end

function checkForLeaveArea()
&#9;while currentConversationDialog do
&#9;&#9;if currentConversationDialog.Parent and (player:DistanceFromCharacter(currentConversationDialog.Parent.Position) &gt;= currentConversationDialog.ConversationDistance) then
&#9;&#9;&#9;wanderDialog()
&#9;&#9;end
&#9;&#9;wait(1)&#9;&#9;
&#9;end
end

function startDialog(dialog)
&#9;if dialog.Parent and dialog.Parent:IsA(&quot;BasePart&quot;) then
&#9;&#9;if player:DistanceFromCharacter(dialog.Parent.Position) &gt;= dialog.ConversationDistance then
&#9;&#9;&#9;showMessage(tooFarAwayMessage, tooFarAwaySize)
&#9;&#9;&#9;return
&#9;&#9;end&#9;
&#9;&#9;
&#9;&#9;for dialog, gui in pairs(dialogMap) do
&#9;&#9;&#9;if dialog and gui then
&#9;&#9;&#9;&#9;gui.Enabled = false
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;renewKillswitch(dialog)

&#9;&#9;delay(1, checkForLeaveArea)
&#9;&#9;doDialog(dialog)
&#9;end
end

function removeDialog(dialog)
   if dialogMap[dialog] then
      dialogMap[dialog]:Remove()
      dialogMap[dialog] = nil
   end
&#9;if dialogConnections[dialog] then
&#9;&#9;dialogConnections[dialog]:disconnect()
&#9;&#9;dialogConnections[dialog] = nil
&#9;end
end&#9;

function addDialog(dialog)
&#9;if dialog.Parent then
&#9;&#9;if dialog.Parent:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;local chatGui = chatNotificationGui:clone()
&#9;&#9;&#9;chatGui.Enabled = not dialog.InUse&#9;&#9;
&#9;&#9;&#9;chatGui.Adornee = dialog.Parent
&#9;&#9;&#9;chatGui.Parent = game.Players.LocalPlayer.PlayerGui
&#9;&#9;&#9;chatGui.Image.Button.MouseButton1Click:connect(function() startDialog(dialog) end)
&#9;&#9;&#9;setChatNotificationTone(chatGui, dialog.Purpose, dialog.Tone)
&#9;&#9;&#9;
&#9;&#9;&#9;dialogMap[dialog] = chatGui

&#9;&#9;&#9;dialogConnections[dialog] = dialog.Changed:connect(function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;Parent&quot; and dialog.Parent then 
&#9;&#9;&#9;&#9;&#9;--This handles the reparenting case, seperate from removal case
&#9;&#9;&#9;&#9;&#9;removeDialog(dialog) 
&#9;&#9;&#9;&#9;&#9;addDialog(dialog) 
&#9;&#9;&#9;&#9;elseif prop == &quot;InUse&quot; then
&#9;&#9;&#9;&#9;&#9;chatGui.Enabled = not currentConversationDialog and not dialog.InUse
&#9;&#9;&#9;&#9;&#9;if dialog == currentConversationDialog then
&#9;&#9;&#9;&#9;&#9;&#9;timeoutDialog()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;elseif prop == &quot;Tone&quot; or prop == &quot;Purpose&quot; then
&#9;&#9;&#9;&#9;&#9;setChatNotificationTone(chatGui, dialog.Purpose, dialog.Tone)
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end)
&#9;&#9;else -- still need to listen to parent changes even if current parent is not a BasePart
&#9;&#9;&#9;dialogConnections[dialog] = dialog.Changed:connect(function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;Parent&quot; and dialog.Parent then 
&#9;&#9;&#9;&#9;&#9;--This handles the reparenting case, seperate from removal case
&#9;&#9;&#9;&#9;&#9;removeDialog(dialog) 
&#9;&#9;&#9;&#9;&#9;addDialog(dialog) 
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end
end


--[[function fetchScripts()
&#9;local model = game:GetService(&quot;InsertService&quot;):LoadAsset(39226062)
    if type(model) == &quot;string&quot; then -- load failed, lets try again
&#9;&#9;wait(0.1)
&#9;&#9;model = game:GetService(&quot;InsertService&quot;):LoadAsset(39226062)
&#9;end
&#9;if type(model) == &quot;string&quot; then -- not going to work, lets bail
&#9;&#9;return
&#9;end
&#9;
&#9;waitForDialogChildrenMyLord(model,&quot;TimeoutScript&quot;)
&#9;timeoutScript = model.TimeoutScript
&#9;waitForDialogChildrenMyLord(model,&quot;ReenableDialogScript&quot;)
&#9;reenableDialogScript = model.ReenableDialogScript
end
]]--

function onLoad()
  waitForProperty(game.Players, &quot;LocalPlayer&quot;)
  player = game.Players.LocalPlayer
  waitForProperty(player, &quot;Character&quot;)

  --print(&quot;Fetching Scripts&quot;)
  --fetchScripts()

  --print(&quot;Creating Guis&quot;)
  createChatNotificationGui()

  waitForFaker(bois,&quot;Dialogs&quot;)
  --print(&quot;Creating MessageDialog&quot;)
  createMessageDialog()
  messageDialog.Parent = game.Players.LocalPlayer.PlayerGui.Dialogs
  
  
  --print(&quot;Initializing Frame&quot;)
  local frame = Instance.new(&quot;Frame&quot;)
  frame.Name = &quot;DialogFrame&quot;
  frame.Position = UDim2.new(0,0,0,0)
  frame.Size = UDim2.new(0,0,0,0)
  frame.BackgroundTransparency = 1
  frame.Parent = game.Players.LocalPlayer.PlayerGui.Dialogs.ControlFrame.BottomLeftControl
  initialize(frame)

  --print(&quot;Adding Dialogs&quot;)
  game.CollectionService.ItemAdded:connect(function(obj) if obj:IsA(&quot;Dialog&quot;) then addDialog(obj) end end)
  game.CollectionService.ItemRemoved:connect(function(obj) if obj:IsA(&quot;Dialog&quot;) then removeDialog(obj) end end)
  for i, obj in pairs(game.CollectionService:GetCollection(&quot;Dialog&quot;)) do
    if obj:IsA(&quot;Dialog&quot;) then
       addDialog(obj)
    end
  end
end

onLoad()</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="GuiMain" referent="RBX9">
			<Properties>
				<string name="Name">Health</string>
			</Properties>
			<Item class="Frame" referent="RBX10">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4285215356</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">tray</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-44</XO>
						<YS>1</YS>
						<YO>-26</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>170</XO>
						<YS>0</YS>
						<YO>18</YO>
					</UDim2>
					<token name="SizeConstraint">2</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX11">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/bkg.png</url></Content>
						<string name="Name">bkg</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX12">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/BarRed.png</url></Content>
						<string name="Name">barRed</string>
						<UDim2 name="Position">
							<XS>0.0189999994</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX13">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1.00000012</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">bar2</string>
						<UDim2 name="Position">
							<XS>0.0189999994</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.192000002</XS>
							<XO>0</XO>
							<YS>0.829999983</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="LocalScript" referent="RBX14">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Init</string>
							<ProtectedString name="Source">h = game.Players.LocalPlayer.Character.Humanoid
tray = script.Parent.Parent
base = tray.Parent
local lastHealth = 100
local lastHealth2 = 100
local maxWidth = 0.96

function UpdateGUI(health)
&#9;local width = (health / h.MaxHealth) * maxWidth
&#9;local height = 0.83
&#9;local lastX = tray.bar.Position.X.Scale
&#9;local x = 0.019 + (maxWidth - width)
&#9;local y = 0.1
&#9;
&#9;tray.bar.Position = UDim2.new(x,0,y, 0) 
&#9;tray.bar.Size = UDim2.new(width, 0, height, 0)
&#9;-- If more than 1/4 health, bar = green.  Else, bar = red.
&#9;if( (health / h.MaxHealth) &gt; 0.25 ) then
&#9;&#9;tray.barRed.Size = UDim2.new(0, 0, 0, 0)
&#9;else
&#9;&#9;tray.barRed.Position = tray.bar.Position
&#9;&#9;tray.barRed.Size = tray.bar.Size
&#9;&#9;tray.bar.Size = UDim2.new(0, 0, 0, 0)
&#9;end
&#9;
&#9;if ( (lastHealth - health) &gt; (h.MaxHealth / 10) ) then
&#9;&#9;lastHealth = health

&#9;&#9;if h.Health ~= h.MaxHealth then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;AnimateHurtOverlay()
&#9;&#9;&#9;end)
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;AnimateBars(x, y, lastX, height)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;else
&#9;&#9;lastHealth = health
&#9;end
end

function AnimateBars(x, y, lastX, height)
&#9;local width = math.abs(x - lastX)
&#9;if( x &gt; lastX ) then
&#9;&#9;x = lastX
&#9;end
&#9;tray.bar2.Position = UDim2.new(x,0, y, 0)
&#9;tray.bar2.Size = UDim2.new(width, 0, height, 0)
&#9;tray.bar2.BackgroundTransparency = 0
&#9;local GBchannels = 1
&#9;local j = 0.2

&#9;local i_total = 30
&#9;for i=1,i_total do
&#9;&#9;-- Increment Values
&#9;&#9;if (GBchannels &lt; 0.2) then
&#9;&#9;&#9;j = -j
&#9;&#9;end
&#9;&#9;GBchannels = GBchannels + j
&#9;&#9;if (i &gt; (i_total - 10)) then
&#9;&#9;&#9;tray.bar2.BackgroundTransparency = tray.bar2.BackgroundTransparency + 0.1
&#9;&#9;end
&#9;&#9;tray.bar2.BackgroundColor3 = Color3.new(1, GBchannels, GBchannels)
&#9;&#9;
&#9;&#9;wait(0.02)
&#9;end
end

function AnimateHurtOverlay()
&#9;-- Start:
&#9;-- overlay.Position = UDim2.new(0, 0, 0, -22)
&#9;-- overlay.Size = UDim2.new(1, 0, 1.15, 30)
&#9;
&#9;-- Finish:
&#9;-- overlay.Position = UDim2.new(-2, 0, -2, -22)
&#9;-- overlay.Size = UDim2.new(4.5, 0, 4.65, 30)
&#9;
&#9;overlay = base.hurtOverlay
&#9;overlay.Visible = true
&#9;overlay.Position = UDim2.new(-2, 0, -2, -22)
&#9;overlay.Size = UDim2.new(4.5, 0, 4.65, 30)
&#9;-- Animate In, fast
&#9;local i_total = 2
&#9;local wiggle_total = 0
&#9;local wiggle_i = 0.02
&#9;for i=1,i_total do
&#9;&#9;overlay.Position = UDim2.new( (-2 + (2 * (i/i_total)) + wiggle_total/2), 0, (-2 + (2 * (i/i_total)) + wiggle_total/2), -22 )
&#9;&#9;overlay.Size = UDim2.new( (4.5 - (3.5 * (i/i_total)) + wiggle_total), 0, (4.65 - (3.5 * (i/i_total)) + wiggle_total), 30 )
&#9;&#9;wait(0.01)
&#9;end
&#9;
&#9;i_total = 30
&#9;
&#9;wait(0.03)
&#9;
&#9;-- Animate Out, slow
&#9;for i=1,i_total do
&#9;&#9;if( math.abs(wiggle_total) &gt; (wiggle_i * 3) ) then
&#9;&#9;&#9;wiggle_i = -wiggle_i
&#9;&#9;end
&#9;&#9;wiggle_total = wiggle_total + wiggle_i
&#9;&#9;overlay.Position = UDim2.new( (0 - (2 * (i/i_total)) + wiggle_total/2), 0, (0 - (2 * (i/i_total)) + wiggle_total/2), -22 )
&#9;&#9;overlay.Size = UDim2.new( (1 + (3.5 * (i/i_total)) + wiggle_total), 0, (1.15 + (3.5 * (i/i_total)) + wiggle_total), 30 )
&#9;&#9;wait(0.01)
&#9;end
&#9;
&#9;-- Hide after we&apos;re done
&#9;overlay.Position = UDim2.new(10, 0, 0, 0)
&#9;overlay.Visible = false
end

h.Changed:connect(function()
&#9;UpdateGUI(h.Health)
&#9;if ( (lastHealth2 - h.Health) &gt; (h.MaxHealth / 10) ) then
&#9;&#9;lastHealth2 = h.Health
&#9;else
&#9;&#9;lastHealth2 = h.Health
&#9;end end)</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX15">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/Bar.png</url></Content>
						<string name="Name">bar</string>
						<UDim2 name="Position">
							<XS>0.0189999994</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.959999979</XS>
							<XO>0</XO>
							<YS>0.829999983</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX16">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/label.png</url></Content>
						<string name="Name">label</string>
						<UDim2 name="Position">
							<XS>0.680000007</XS>
							<XO>0</XO>
							<YS>0.300000012</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.25</XS>
							<XO>0</XO>
							<YS>0.349999994</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="ImageLabel" referent="RBX17">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4290164919</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<Content name="Image"><url>rbxasset://textures/healthgui/HurtOverlay.png</url></Content>
					<string name="Name">hurtOverlay</string>
					<UDim2 name="Position">
						<XS>2</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>-22</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1.1500001</YS>
						<YO>30</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX18">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Hide</string>
					<ProtectedString name="Source">while true do
&#9;game.Players.LocalPlayer.PlayerGui.HealthGUI.tray.Visible = false
&#9;game.Players.LocalPlayer.PlayerGui.HealthGUI.hurtOverlay.Visible = false
end</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX19">
			<Properties>
				<string name="Name">Menu</string>
			</Properties>
			<Item class="Frame" referent="RBX20">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ControlFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX21">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">BottomLeftControl</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-46</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>130</XO>
							<YS>0</YS>
							<YO>46</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageButton" referent="RBX22">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/Exit.png</url></Content>
							<bool name="Modal">false</bool>
							<string name="Name">Exit</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>2</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>56</XO>
								<YS>0</YS>
								<YO>41</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX23">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">BottomRightControl</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-180</XO>
							<YS>1</YS>
							<YO>-41</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>180</XO>
							<YS>0</YS>
							<YO>41</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX24">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">TopLeftControl</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="NotificationBox" referent="RBX25">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">NotificationBox</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-200</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0.419999987</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX26">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MenuScript</string>
					<ProtectedString name="Source">-- fixed by iago#6808 -- 
-- version 0.25 --
-- changelog: --
-- 100% finished settings menu --
-- report abuse is still in work --

local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local steps = 10
&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then

&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,10)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(10, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (10 - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end
&#9;

local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

-- A Few Script Globals
local gui = script.Parent.ControlFrame

local helpButton = nil
local updateCameraDropDownSelection = nil
local updateVideoCaptureDropDownSelection = nil
local tweenTime = 0.2

local mouseLockLookScreenUrl = &quot;http://www.roblox.com/asset?id=54071825&quot;
local classicLookScreenUrl = &quot;http://www.roblox.com/Asset?id=45915798&quot;

local hasGraphicsSlider = true
local GraphicsQualityLevels = 10
local recordingVideo = false

local currentMenuSelection = nil
local lastMenuSelection = {}

local defaultPosition = UDim2.new(0,0,0,0)
local newGuiPlaces = {0,41324860}

local centerDialogs = {}
local mainShield = nil

local inStudioMode = false

local macClient = false
local success, isMac = pcall(function() return not game.GuiService.IsWindows end)
macClient = success and isMac

local function Color3I(r,g,b)
  return Color3.new(r/255,g/255,b/255)
end

local function robloxLock(instance)
end

function resumeGameFunction(shield)
&#9;shield.Settings:TweenPosition(UDim2.new(0.5, -262,-0.5, -200),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;delay(tweenTime,function()
&#9;&#9;shield.Visible = false
&#9;&#9;for i = 1, #centerDialogs do
&#9;&#9;&#9;centerDialogs[i].Visible = false
&#9;&#9;&#9;game.GuiService:RemoveCenterDialog(centerDialogs[i])
&#9;&#9;end

&#9;&#9;settingsButton.Active = true
&#9;&#9;currentMenuSelection = nil
&#9;&#9;lastMenuSelection = {}&#9;&#9;
&#9;end)
end

function goToMenu(container,menuName, moveDirection,size,position)
&#9;if type(menuName) ~= &quot;string&quot; then return end
&#9;
&#9;table.insert(lastMenuSelection,currentMenuSelection)
&#9;if menuName == &quot;GameMainMenu&quot; then
&#9;&#9;lastMenuSelection = {}
&#9;end

&#9;local containerChildren = container:GetChildren()
&#9;local selectedMenu = false
&#9;for i = 1, #containerChildren do
&#9;&#9;if containerChildren[i].Name == menuName then
&#9;&#9;&#9;containerChildren[i].Visible = true
&#9;&#9;&#9;currentMenuSelection = {container = container,name = menuName, direction = moveDirection, lastSize = size}
&#9;&#9;&#9;selectedMenu = true
&#9;&#9;&#9;if size and position then
&#9;&#9;&#9;&#9;containerChildren[i]:TweenSizeAndPosition(size,position,Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;elseif size then
&#9;&#9;&#9;&#9;containerChildren[i]:TweenSizeAndPosition(size,UDim2.new(0.5,-size.X.Offset/2,0.5,-size.Y.Offset/2),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;containerChildren[i]:TweenPosition(UDim2.new(0,0,0,0),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;if moveDirection == &quot;left&quot; then
&#9;&#9;&#9;&#9;containerChildren[i]:TweenPosition(UDim2.new(-1,-525,0,0),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;elseif moveDirection == &quot;right&quot; then
&#9;&#9;&#9;&#9;containerChildren[i]:TweenPosition(UDim2.new(1,525,0,0),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;elseif moveDirection == &quot;up&quot; then
&#9;&#9;&#9;&#9;containerChildren[i]:TweenPosition(UDim2.new(0,0,-1,-400),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;elseif moveDirection == &quot;down&quot; then
&#9;&#9;&#9;&#9;containerChildren[i]:TweenPosition(UDim2.new(0,0,1,400),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;end
&#9;&#9;&#9;delay(tweenTime,function()
&#9;&#9;&#9;&#9;containerChildren[i].Visible = false
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end&#9;
end

function resetLocalCharacter()
&#9;local player = game.Players.LocalPlayer
&#9;if player then
&#9;&#9;if player.Character and player.Character:FindFirstChild(&quot;Humanoid&quot;) then
&#9;&#9;&#9;player.Character.Humanoid.Health = 0
&#9;&#9;end
&#9;end
end

local function createTextButton(text,style,fontSize,buttonSize,buttonPosition)
&#9;local newTextButton = Instance.new(&quot;TextButton&quot;)
&#9;newTextButton.Font = Enum.Font.Arial
&#9;newTextButton.FontSize = fontSize
&#9;newTextButton.Size = buttonSize
&#9;newTextButton.Position = buttonPosition
&#9;newTextButton.Style = style
&#9;newTextButton.TextColor3 = Color3.new(1,1,1)
&#9;newTextButton.Text = text
&#9;return newTextButton
end

local function CreateTextButtons(frame, buttons, yPos, ySize)
&#9;if #buttons &lt; 1 then
&#9;&#9;error(&quot;Must have more than one button&quot;)
&#9;end

&#9;local buttonNum = 1
&#9;local buttonObjs = {}

&#9;local function toggleSelection(button)
&#9;&#9;for i, obj in ipairs(buttonObjs) do
&#9;&#9;&#9;if obj == button then
&#9;&#9;&#9;&#9;obj.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(function() toggleSelection(button) obj.Function() end)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;
&#9;toggleSelection(buttonObjs[1])

&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

function setRecordGui(recording, stopRecordButton, recordVideoButton)
&#9;if recording then 
&#9;&#9;stopRecordButton.Visible = true
&#9;&#9;recordVideoButton.Text = &quot;Stop Recording&quot;
&#9;else
&#9;&#9;stopRecordButton.Visible = false
&#9;&#9;recordVideoButton.Text = &quot;Record Video&quot;
&#9;end
end

function recordVideoClick(recordVideoButton, stopRecordButton)
&#9;recordingVideo = not recordingVideo
&#9;setRecordGui(recordingVideo, stopRecordButton, recordVideoButton)
end

function backToGame(buttonClicked, shield, settingsButton)
&#9;buttonClicked.Parent.Parent.Parent.Parent.Visible = false
&#9;shield.Visible = false
&#9;for i = 1, #centerDialogs do
&#9;&#9;game.GuiService:RemoveCenterDialog(centerDialogs[i])
&#9;&#9;centerDialogs[i].Visible = false
&#9;end
&#9;centerDialogs = {}
&#9;game.GuiService:RemoveCenterDialog(shield)
&#9;settingsButton.Active = true
end

function setDisabledState(guiObject)
&#9;if not guiObject then return end
&#9;
&#9;if guiObject:IsA(&quot;TextLabel&quot;) then
&#9;&#9;guiObject.TextTransparency = 0.9
&#9;elseif guiObject:IsA(&quot;TextButton&quot;) then
&#9;&#9;guiObject.TextTransparency = 0.9
&#9;&#9;guiObject.Active = false
&#9;else
&#9;&#9;if guiObject[&quot;ClassName&quot;] then
&#9;&#9;&#9;print(&quot;setDisabledState() got object of unsupported type.  object type is &quot;,guiObject.ClassName)
&#9;&#9;end
&#9;end
end

local function createHelpDialog(baseZIndex)

&#9;if helpButton == nil then
&#9;&#9;if gui:FindFirstChild(&quot;TopLeftControl&quot;) and gui.TopLeftControl:FindFirstChild(&quot;Help&quot;) then
&#9;&#9;&#9;helpButton = gui.TopLeftControl.Help
&#9;&#9;elseif gui:FindFirstChild(&quot;BottomRightControl&quot;) and gui.BottomRightControl:FindFirstChild(&quot;Help&quot;) then
&#9;&#9;&#9;helpButton = gui.BottomRightControl.Help
&#9;&#9;end
&#9;end

&#9;local shield = Instance.new(&quot;Frame&quot;)
&#9;shield.Name = &quot;HelpDialogShield&quot;
&#9;shield.Active = true
&#9;shield.Visible = false
&#9;shield.Size = UDim2.new(1,0,1,0)
&#9;shield.BackgroundColor3 = Color3I(51,51,51)
&#9;shield.BorderColor3 = Color3I(27,42,53)
&#9;shield.BackgroundTransparency = 0.4
&#9;shield.ZIndex = baseZIndex + 1
   shield.Parent = gui

&#9;local helpDialog = Instance.new(&quot;Frame&quot;)
&#9;helpDialog.Name = &quot;HelpDialog&quot;
&#9;helpDialog.Style = Enum.FrameStyle.RobloxRound
&#9;helpDialog.Position = UDim2.new(.2, 0, .2, 0)
&#9;helpDialog.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;helpDialog.Active = true
&#9;helpDialog.Parent = shield

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = &quot;Keyboard &amp; Mouse Controls&quot;
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.Position = UDim2.new(0, 0, 0.025, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0, 40)
&#9;titleLabel.TextColor3 = Color3.new(1,1,1)
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.Parent = helpDialog

&#9;local buttonRow = Instance.new(&quot;Frame&quot;)
&#9;buttonRow.Name = &quot;Buttons&quot;
&#9;buttonRow.Position = UDim2.new(0.1, 0, .07, 40)
&#9;buttonRow.Size = UDim2.new(0.8, 0, 0, 45)
&#9;buttonRow.BackgroundTransparency = 1
&#9;buttonRow.Parent = helpDialog

&#9;local imageFrame = Instance.new(&quot;Frame&quot;)
&#9;imageFrame.Name = &quot;ImageFrame&quot;
&#9;imageFrame.Position = UDim2.new(0.05, 0, 0.075, 80)
&#9;imageFrame.Size = UDim2.new(0.9, 0, .9, -120)
&#9;imageFrame.BackgroundTransparency = 1
&#9;imageFrame.Parent = helpDialog

&#9;local layoutFrame = Instance.new(&quot;Frame&quot;)
&#9;layoutFrame.Name = &quot;LayoutFrame&quot;
&#9;layoutFrame.Position = UDim2.new(0.5, 0, 0, 0)
&#9;layoutFrame.Size = UDim2.new(1.5, 0, 1, 0)
&#9;layoutFrame.BackgroundTransparency = 1
&#9;layoutFrame.SizeConstraint = Enum.SizeConstraint.RelativeYY
&#9;layoutFrame.Parent = imageFrame

&#9;local image = Instance.new(&quot;ImageLabel&quot;)
&#9;image.Name = &quot;Image&quot;
&#9;if UserSettings().GameSettings.ControlMode == Enum.ControlMode[&quot;Mouse Lock Switch&quot;] then
&#9;&#9;image.Image = mouseLockLookScreenUrl
&#9;else
&#9;&#9;image.Image = classicLookScreenUrl
&#9;end
&#9;image.Position = UDim2.new(-0.5, 0, 0, 0)
&#9;image.Size = UDim2.new(1, 0, 1, 0)
&#9;image.BackgroundTransparency = 1
&#9;image.Parent = layoutFrame
&#9;
&#9;local buttons = {}
&#9;buttons[1] = {}
&#9;buttons[1].Text = &quot;Look&quot;
&#9;buttons[1].Function = function()
&#9;&#9;if UserSettings().GameSettings.ControlMode == Enum.ControlMode[&quot;Mouse Lock Switch&quot;] then
&#9;&#9;&#9;image.Image = mouseLockLookScreenUrl
&#9;&#9;else
&#9;&#9;&#9;image.Image = classicLookScreenUrl
&#9;&#9;end
&#9;end 
&#9;buttons[2] = {}
&#9;buttons[2].Text = &quot;Move&quot;
&#9;buttons[2].Function = function() 
&#9;&#9;image.Image = &quot;http://www.roblox.com/Asset?id=45915811&quot;
&#9;end 
&#9;buttons[3] = {}
&#9;buttons[3].Text = &quot;Gear&quot;
&#9;buttons[3].Function = function() 
&#9;&#9;image.Image = &quot;http://www.roblox.com/Asset?id=45917596&quot;
&#9;end
&#9;buttons[4] = {}
&#9;buttons[4].Text = &quot;Zoom&quot;
&#9;buttons[4].Function = function() &#9;
&#9;&#9;image.Image = &quot;http://www.roblox.com/Asset?id=45915825&quot;
&#9;end 

&#9;CreateTextButtons(buttonRow, buttons, UDim.new(0, 0), UDim.new(1,0))
&#9;
&#9;&#9;
&#9;-- set up listeners for type of mouse mode, but keep constructing gui at same time
&#9;delay(0, function()
&#9;&#9;waitForChild(gui,&quot;UserSettingsShield&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield,&quot;Settings&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield.Settings,&quot;SettingsStyle&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield.Settings.SettingsStyle, &quot;GameSettingsMenu&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield.Settings.SettingsStyle.GameSettingsMenu, &quot;CameraField&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield.Settings.SettingsStyle.GameSettingsMenu.CameraField, &quot;DropDownMenuButton&quot;)
&#9;&#9;gui.UserSettingsShield.Settings.SettingsStyle.GameSettingsMenu.CameraField.DropDownMenuButton.Changed:connect(function(prop)
&#9;&#9;&#9;if prop ~= &quot;Text&quot; then return end
&#9;&#9;&#9;if buttonRow.Button1.Style == Enum.ButtonStyle.RobloxButtonDefault then -- only change if this is the currently selected panel
&#9;&#9;&#9;&#9;if gui.UserSettingsShield.Settings.SettingsStyle.GameSettingsMenu.CameraField.DropDownMenuButton.Text == &quot;Classic&quot; then
&#9;&#9;&#9;&#9;&#9;image.Image = classicLookScreenUrl
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;image.Image = mouseLockLookScreenUrl
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end)


&#9;local okBtn = Instance.new(&quot;TextButton&quot;)
&#9;okBtn.Name = &quot;OkBtn&quot;
&#9;okBtn.Text = &quot;OK&quot;
&#9;okBtn.Modal = true
&#9;okBtn.Size = UDim2.new(0.3, 0, 0, 45)
&#9;okBtn.Position = UDim2.new(0.35, 0, .975, -50)
&#9;okBtn.Font = Enum.Font.Arial
&#9;okBtn.FontSize = Enum.FontSize.Size18
&#9;okBtn.BackgroundTransparency = 1
&#9;okBtn.TextColor3 = Color3.new(1,1,1)
&#9;okBtn.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;okBtn.MouseButton1Click:connect(
&#9;&#9;function()
&#9;&#9;&#9;gui.HelpDialogShield.Visible = false
&#9;&#9;end)
&#9;okBtn.Parent = helpDialog


&#9;return shield
end

local function createLeaveConfirmationMenu(baseZIndex,shield)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;LeaveConfirmationMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;frame.Position = UDim2.new(0,0,2,400)
&#9;frame.ZIndex = baseZIndex + 4
&#9;
&#9;local yesButton = createTextButton(&quot;Leave&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size24,UDim2.new(0,128,0,50),UDim2.new(0,313,0.8,0))
&#9;yesButton.Name = &quot;YesButton&quot;
&#9;yesButton.ZIndex = baseZIndex + 4
&#9;yesButton.Parent = frame
&#9;yesButton.Modal = true
&#9;yesButton:SetVerb(&quot;Exit&quot;)
&#9;
&#9;local noButton = createTextButton(&quot;Stay&quot;,Enum.ButtonStyle.RobloxButtonDefault,Enum.FontSize.Size24,UDim2.new(0,128,0,50),UDim2.new(0,90,0.8,0))
&#9;noButton.Name = &quot;NoButton&quot;
&#9;noButton.Parent = frame
&#9;noButton.ZIndex = baseZIndex + 4
&#9;noButton.MouseButton1Click:connect(function()
&#9;&#9;goToMenu(shield.Settings.SettingsStyle,&quot;GameMainMenu&quot;,&quot;down&quot;,UDim2.new(0,525,0,430))
&#9;&#9;shield.Settings:TweenSize(UDim2.new(0,525,0,430),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;end)
&#9;
&#9;local leaveText = Instance.new(&quot;TextLabel&quot;)
&#9;leaveText.Name = &quot;LeaveText&quot;
&#9;leaveText.Text = &quot;Leave this game?&quot;
&#9;leaveText.Size = UDim2.new(1,0,0.8,0)
&#9;leaveText.TextWrap = true
&#9;leaveText.TextColor3 = Color3.new(1,1,1)
&#9;leaveText.Font = Enum.Font.ArialBold
&#9;leaveText.FontSize = Enum.FontSize.Size36
&#9;leaveText.BackgroundTransparency = 1
&#9;leaveText.ZIndex = baseZIndex + 4
&#9;leaveText.Parent = frame
&#9;
&#9;return frame
end

local function createResetConfirmationMenu(baseZIndex,shield)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ResetConfirmationMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;frame.Position = UDim2.new(0,0,2,400)
&#9;frame.ZIndex = baseZIndex + 4
   frame.Parent = gui

&#9;
&#9;local yesButton = createTextButton(&quot;Reset&quot;,Enum.ButtonStyle.RobloxButtonDefault,Enum.FontSize.Size24,UDim2.new(0,128,0,50),UDim2.new(0,313,0,299))
&#9;yesButton.Name = &quot;YesButton&quot;
&#9;yesButton.ZIndex = baseZIndex + 4
&#9;yesButton.Parent = frame
&#9;yesButton.Modal  = true
&#9;yesButton.MouseButton1Click:connect(function()
&#9;&#9;resumeGameFunction(shield)
&#9;&#9;resetLocalCharacter()
&#9;end)
&#9;
&#9;local noButton = createTextButton(&quot;Cancel&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size24,UDim2.new(0,128,0,50),UDim2.new(0,90,0,299))
&#9;noButton.Name = &quot;NoButton&quot;
&#9;noButton.Parent = frame
&#9;noButton.ZIndex = baseZIndex + 4
&#9;noButton.MouseButton1Click:connect(function()
&#9;&#9;goToMenu(shield.Settings.SettingsStyle,&quot;GameMainMenu&quot;,&quot;down&quot;,UDim2.new(0,525,0,430))
&#9;&#9;shield.Settings:TweenSize(UDim2.new(0,525,0,430),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;end)
&#9;
&#9;local resetCharacterText = Instance.new(&quot;TextLabel&quot;)
&#9;resetCharacterText.Name = &quot;ResetCharacterText&quot;
&#9;resetCharacterText.Text = &quot;Are you sure you want to reset your character?&quot;
&#9;resetCharacterText.Size = UDim2.new(1,0,0.8,0)
&#9;resetCharacterText.TextWrap = true
&#9;resetCharacterText.TextColor3 = Color3.new(1,1,1)
&#9;resetCharacterText.Font = Enum.Font.ArialBold
&#9;resetCharacterText.FontSize = Enum.FontSize.Size36
&#9;resetCharacterText.BackgroundTransparency = 1
&#9;resetCharacterText.ZIndex = baseZIndex + 4
&#9;resetCharacterText.Parent = frame
&#9;
&#9;local fineResetCharacterText = resetCharacterText:Clone()
&#9;fineResetCharacterText.Name = &quot;FineResetCharacterText&quot;
&#9;fineResetCharacterText.Text = &quot;You will be put back on a spawn point&quot;
&#9;fineResetCharacterText.Size = UDim2.new(0,303,0,18)
&#9;fineResetCharacterText.Position = UDim2.new(0, 109, 0, 215)
&#9;fineResetCharacterText.FontSize = Enum.FontSize.Size18
&#9;fineResetCharacterText.Parent = frame
&#9;
&#9;return frame
end

local function createGameMainMenu(baseZIndex, shield)
&#9;local gameMainMenuFrame = Instance.new(&quot;Frame&quot;)
&#9;gameMainMenuFrame.Name = &quot;GameMainMenu&quot;
&#9;gameMainMenuFrame.BackgroundTransparency = 1
&#9;gameMainMenuFrame.Size = UDim2.new(1,0,1,0)
&#9;gameMainMenuFrame.ZIndex = baseZIndex + 4
&#9;gameMainMenuFrame.Parent = script.Parent.UserSettingsShield.Settings.SettingsStyle

&#9;-- GameMainMenu Children
&#9;
&#9;local gameMainMenuTitle = Instance.new(&quot;TextLabel&quot;)
&#9;gameMainMenuTitle.Name = &quot;Title&quot;
&#9;gameMainMenuTitle.Text = &quot;Game Menu&quot;
&#9;gameMainMenuTitle.BackgroundTransparency = 1
&#9;gameMainMenuTitle.TextStrokeTransparency = 0
&#9;gameMainMenuTitle.Font = Enum.Font.ArialBold
&#9;gameMainMenuTitle.FontSize = Enum.FontSize.Size36
&#9;gameMainMenuTitle.Size = UDim2.new(1,0,0,36)
&#9;gameMainMenuTitle.Position = UDim2.new(0,0,0,4)
&#9;gameMainMenuTitle.TextColor3 = Color3.new(1,1,1)
&#9;gameMainMenuTitle.ZIndex = baseZIndex + 4
&#9;gameMainMenuTitle.Parent = gameMainMenuFrame
&#9;
&#9;local robloxHelpButton = createTextButton(&quot;Help&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size18,UDim2.new(0,164,0,50),UDim2.new(0,82,0,256))
&#9;robloxHelpButton.Name = &quot;HelpButton&quot;
&#9;robloxHelpButton.ZIndex = baseZIndex + 4
&#9;robloxHelpButton.Parent = gameMainMenuFrame
&#9;helpButton = robloxHelpButton
&#9;&#9;&#9;
&#9;local helpDialog = createHelpDialog(baseZIndex)
&#9;helpDialog.Parent = gui
&#9;&#9;
&#9;helpButton.MouseButton1Click:connect(
&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;helpDialog.Visible = true
&#9;&#9;&#9;&#9;&#9;mainShield.Visible = false
&#9;&#9;end)
&#9;helpButton.Active = true
&#9;
&#9;local helpShortcut = Instance.new(&quot;TextLabel&quot;)
&#9;helpShortcut.Name = &quot;HelpShortcutText&quot;
&#9;helpShortcut.Text = &quot;F1&quot;
&#9;helpShortcut.Visible = false
&#9;helpShortcut.BackgroundTransparency = 1
&#9;helpShortcut.Font = Enum.Font.Arial
&#9;helpShortcut.FontSize = Enum.FontSize.Size12
&#9;helpShortcut.Position = UDim2.new(0,85,0,0)
&#9;helpShortcut.Size = UDim2.new(0,30,0,30)
&#9;helpShortcut.TextColor3 = Color3.new(0,1,0)
&#9;helpShortcut.ZIndex = baseZIndex + 4
&#9;helpShortcut.Parent = robloxHelpButton
&#9;
&#9;local screenshotButton = createTextButton(&quot;Screenshot&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size18,UDim2.new(0,168,0,50),UDim2.new(0,254,0,256))
&#9;screenshotButton.Name = &quot;ScreenshotButton&quot;
&#9;screenshotButton.ZIndex = baseZIndex + 4
&#9;screenshotButton.Parent = shield.Settings.SettingsStyle.GameMainMenu
&#9;screenshotButton.Visible = not macClient
&#9;screenshotButton:SetVerb(&quot;Screenshot&quot;)
&#9;
&#9;local screenshotShortcut = helpShortcut:clone()
&#9;screenshotShortcut.Name = &quot;ScreenshotShortcutText&quot;
&#9;screenshotShortcut.Text = &quot;PrintSc&quot;
&#9;screenshotShortcut.Position = UDim2.new(0,118,0,0)
&#9;screenshotShortcut.Visible = true
&#9;screenshotShortcut.Parent = screenshotButton

&#9;local recordVideoButton = createTextButton(&quot;Record Video&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size18,UDim2.new(0,168,0,50),UDim2.new(0,254,0,306))
&#9;recordVideoButton.Name = &quot;RecordVideoButton&quot;
&#9;recordVideoButton.ZIndex = baseZIndex + 4
&#9;recordVideoButton.Parent = gameMainMenuFrame
&#9;recordVideoButton.Visible = not macClient
&#9;recordVideoButton:SetVerb(&quot;RecordToggle&quot;)
&#9;
&#9;local recordVideoShortcut = helpShortcut:clone()
&#9;recordVideoShortcut.Visible = hasGraphicsSlider
&#9;recordVideoShortcut.Name = &quot;RecordVideoShortcutText&quot;
&#9;recordVideoShortcut.Text = &quot;F12&quot;
&#9;recordVideoShortcut.Position = UDim2.new(0,120,0,0)
&#9;recordVideoShortcut.Parent = recordVideoButton
&#9;
&#9;local stopRecordButton = Instance.new(&quot;ImageButton&quot;)
&#9;stopRecordButton.Name = &quot;StopRecordButton&quot;
&#9;stopRecordButton.BackgroundTransparency = 1
&#9;stopRecordButton.Image = &quot;rbxasset://textures/ui/RecordStop.png&quot;
&#9;stopRecordButton.Size = UDim2.new(0,59,0,27)
&#9;stopRecordButton:SetVerb(&quot;RecordToggle&quot;)
&#9;stopRecordButton.MouseButton1Click:connect(function() stopRecordButton.Visible = false end)
&#9;recordVideoButton.MouseButton1Click:connect(function() stopRecordButton.Visible = true game.Players.LocalPlayer.PlayerGui.Menu.UserSettingsShield.Visible = false end)
&#9;stopRecordButton.Visible = false
&#9;stopRecordButton.Parent = gui
&#9;
&#9;local reportAbuseButton = createTextButton(&quot;Report Abuse&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size18,UDim2.new(0,164,0,50),UDim2.new(0,82,0,306))
&#9;reportAbuseButton.Name = &quot;ReportAbuseButton&quot;
&#9;reportAbuseButton.ZIndex = baseZIndex + 4
&#9;reportAbuseButton.Parent = gameMainMenuFrame
   reportAbuseButton.Active = true
&#9;
&#9;local leaveGameButton = createTextButton(&quot;Leave Game&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size24,UDim2.new(0,340,0,50),UDim2.new(0,82,0,358))
&#9;leaveGameButton.Name = &quot;LeaveGameButton&quot;
&#9;leaveGameButton.ZIndex = baseZIndex + 4
&#9;leaveGameButton.Parent = gameMainMenuFrame

&#9;
&#9;local resumeGameButton = createTextButton(&quot;Resume Game&quot;,Enum.ButtonStyle.RobloxButtonDefault,Enum.FontSize.Size24,UDim2.new(0,340,0,50),UDim2.new(0,82,0,54))
&#9;resumeGameButton.Name = &quot;resumeGameButton&quot;
&#9;resumeGameButton.ZIndex = baseZIndex + 4
&#9;resumeGameButton.Parent = gameMainMenuFrame
&#9;resumeGameButton.Modal = true
&#9;resumeGameButton.MouseButton1Click:connect(function() resumeGameFunction(shield) end)
&#9;
&#9;local gameSettingsButton = createTextButton(&quot;Game Settings&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size24,UDim2.new(0,340,0,50),UDim2.new(0,82,0,156))
&#9;gameSettingsButton.Name = &quot;SettingsButton&quot;
&#9;gameSettingsButton.ZIndex = baseZIndex + 4
&#9;gameSettingsButton.Parent = gameMainMenuFrame


&#9;
&#9;if game:FindFirstChild(&quot;LoadingGuiService&quot;) and #game.LoadingGuiService:GetChildren() &gt; 0 then
&#9;&#9;local gameSettingsButton = createTextButton(&quot;Game Instructions&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size24,UDim2.new(0,340,0,50),UDim2.new(0,82,0,207))
&#9;&#9;gameSettingsButton.Name = &quot;GameInstructions&quot;
&#9;&#9;gameSettingsButton.ZIndex = baseZIndex + 4
&#9;&#9;gameSettingsButton.Parent = gameMainMenuFrame
&#9;&#9;gameSettingsButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if game:FindFirstChild(&quot;Players&quot;) and game.Players[&quot;LocalPlayer&quot;] then
&#9;&#9;&#9;&#9;local loadingGui = game.Players.LocalPlayer:FindFirstChild(&quot;PlayerLoadingGui&quot;)
&#9;&#9;&#9;&#9;if loadingGui then
&#9;&#9;&#9;&#9;&#9;loadingGui.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
&#9;
&#9;local resetButton = createTextButton(&quot;Reset Character&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size24,UDim2.new(0,340,0,50),UDim2.new(0,82,0,105))
&#9;resetButton.Name = &quot;ResetButton&quot;
&#9;resetButton.ZIndex = baseZIndex + 4
&#9;resetButton.Parent = gameMainMenuFrame
&#9;
&#9;return gameMainMenuFrame
end


local function createGameSettingsMenu(baseZIndex, shield)
&#9;local gameSettingsMenuFrame = Instance.new(&quot;Frame&quot;)
&#9;gameSettingsMenuFrame.Name = &quot;GameSettingsMenu&quot;
&#9;gameSettingsMenuFrame.BackgroundTransparency = 1
&#9;gameSettingsMenuFrame.Size = UDim2.new(1,0,1,0)
&#9;gameSettingsMenuFrame.ZIndex = baseZIndex + 4
&#9;
&#9;local title = Instance.new(&quot;TextLabel&quot;)
&#9;title.Name = &quot;Title&quot;
&#9;title.Text = &quot;Settings&quot;
&#9;title.Size = UDim2.new(1,0,0,48)
&#9;title.Position = UDim2.new(0,9,0,-9)
&#9;title.Font = Enum.Font.ArialBold
&#9;title.FontSize = Enum.FontSize.Size36
&#9;title.TextColor3 = Color3.new(1,1,1)
&#9;title.ZIndex = baseZIndex + 4
&#9;title.BackgroundTransparency = 1
&#9;title.Parent = gameSettingsMenuFrame
&#9;
&#9;
&#9;--[[
&#9;local studioText = Instance.new(&quot;TextLabel&quot;)
&#9;studioText.Visible = false
&#9;studioText.Name = &quot;StudioText&quot;
&#9;studioText.Text = &quot;Studio Mode&quot;
&#9;studioText.Size = UDim2.new(0,95,0,18)
&#9;studioText.Position = UDim2.new(0,62,0,179)
&#9;studioText.Font = Enum.Font.Arial
&#9;studioText.FontSize = Enum.FontSize.Size18
&#9;studioText.TextColor3 = Color3.new(1,1,1)
&#9;studioText.ZIndex = baseZIndex + 4
&#9;studioText.BackgroundTransparency = 1
&#9;studioText.Parent = gameSettingsMenuFrame
&#9;
&#9;local studioShortcut = fullscreenShortcut:clone()
&#9;studioShortcut.Name = &quot;StudioShortcutText&quot;
&#9;studioShortcut.Visible = false -- TODO: turn back on when f2 hack is fixed
&#9;studioShortcut.Text = &quot;F2&quot;
&#9;studioShortcut.Position = UDim2.new(0,154,0,175)
&#9;studioShortcut.Parent = gameSettingsMenuFrame
&#9;
&#9;local studioCheckbox = nil
&#9;--]]


&#9;local itemTop = 35
&#9;----------------------------------------------------------------------------------------------------
&#9;--  C A M E R A    C O N T R O L S
&#9;----------------------------------------------------------------------------------------------------

&#9;if not touchClient then
&#9;&#9;local cameraLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;cameraLabel.Name = &quot;CameraLabel&quot;
&#9;&#9;cameraLabel.Text = &quot;Character &amp; Camera Controls&quot;
&#9;&#9;cameraLabel.Font = Enum.Font.Arial
&#9;&#9;cameraLabel.FontSize = Enum.FontSize.Size18
&#9;&#9;cameraLabel.Position = UDim2.new(0,31,0,itemTop + 6)
&#9;&#9;cameraLabel.Size = UDim2.new(0,224,0,18)
&#9;&#9;cameraLabel.TextColor3 = Color3I(255,255,255)
&#9;&#9;cameraLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;cameraLabel.BackgroundTransparency = 1
&#9;&#9;cameraLabel.ZIndex = baseZIndex + 4
&#9;&#9;cameraLabel.Parent = gameSettingsMenuFrame

      local mouseLockLabel = nil

&#9;&#9;local enumItems = Enum.ControlMode:GetEnumItems()
&#9;&#9;local enumNames = {}
&#9;&#9;local enumNameToItem = {}
&#9;&#9;for i,obj in ipairs(enumItems) do
&#9;&#9;&#9;enumNames[i] = obj.Name
&#9;&#9;&#9;enumNameToItem[obj.Name] = obj
&#9;&#9;end

&#9;&#9;local cameraDropDown
&#9;&#9;cameraDropDown, updateCameraDropDownSelection = RbxGui.CreateDropDownMenu(enumNames, 
&#9;&#9;&#9;function(text) 
&#9;&#9;&#9;&#9;UserSettings().GameSettings.ControlMode = enumNameToItem[text] 
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;pcall(function()
&#9;&#9;&#9;&#9;&#9;if mouseLockLabel and UserSettings().GameSettings.ControlMode == Enum.ControlMode[&quot;Mouse Lock Switch&quot;] then
&#9;&#9;&#9;&#9;&#9;&#9;mouseLockLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;elseif mouseLockLabel then
&#9;&#9;&#9;&#9;&#9;&#9;mouseLockLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;cameraDropDown.Name = &quot;CameraField&quot;
&#9;&#9;cameraDropDown.ZIndex = baseZIndex + 4
&#9;&#9;cameraDropDown.DropDownMenuButton.ZIndex = baseZIndex + 4
&#9;&#9;cameraDropDown.DropDownMenuButton.Icon.ZIndex = baseZIndex + 4
&#9;&#9;cameraDropDown.Position = UDim2.new(0, 270, 0, itemTop)
&#9;&#9;cameraDropDown.Size = UDim2.new(0,200,0,32)
&#9;&#9;cameraDropDown.Parent = gameSettingsMenuFrame

&#9;&#9;itemTop = itemTop + 35
&#9;end

&#9;----------------------------------------------------------------------------------------------------
&#9;--  V I D E O   C A P T U R E   S E T T I N G S
&#9;----------------------------------------------------------------------------------------------------

&#9;local syncVideoCaptureSetting = nil

&#9;if not macClient and not touchClient then
&#9;&#9;local videoCaptureLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;videoCaptureLabel.Name = &quot;VideoCaptureLabel&quot;
&#9;&#9;videoCaptureLabel.Text = &quot;After Capturing Video&quot;
&#9;&#9;videoCaptureLabel.Font = Enum.Font.Arial
&#9;&#9;videoCaptureLabel.FontSize = Enum.FontSize.Size18
&#9;&#9;videoCaptureLabel.Position = UDim2.new(0,32,0,itemTop + 6)
&#9;&#9;videoCaptureLabel.Size = UDim2.new(0,164,0,18)
&#9;&#9;videoCaptureLabel.BackgroundTransparency = 1
&#9;&#9;videoCaptureLabel.TextColor3 = Color3I(255,255,255)
&#9;&#9;videoCaptureLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;videoCaptureLabel.ZIndex = baseZIndex + 4
&#9;&#9;videoCaptureLabel.Parent = gameSettingsMenuFrame

&#9;&#9;local videoNames = {}
&#9;&#9;local videoNameToItem = {}
&#9;&#9;videoNames[1] = &quot;Just Save to Disk&quot;
&#9;&#9;videoNameToItem[videoNames[1]] = Enum.UploadSetting[&quot;Never&quot;]
&#9;&#9;videoNames[2] = &quot;Upload to YouTube&quot;
&#9;&#9;videoNameToItem[videoNames[2]] = Enum.UploadSetting[&quot;Ask me first&quot;]

&#9;&#9;local videoCaptureDropDown = nil
&#9;&#9;videoCaptureDropDown, updateVideoCaptureDropDownSelection = RbxGui.CreateDropDownMenu(videoNames, 
&#9;&#9;&#9;function(text) 
&#9;&#9;&#9;&#9;UserSettings().GameSettings.VideoUploadPromptBehavior = videoNameToItem[text]
&#9;&#9;&#9;end)
&#9;&#9;videoCaptureDropDown.Name = &quot;VideoCaptureField&quot;
&#9;&#9;videoCaptureDropDown.ZIndex = baseZIndex + 4
&#9;&#9;videoCaptureDropDown.DropDownMenuButton.ZIndex = baseZIndex + 4
&#9;&#9;videoCaptureDropDown.DropDownMenuButton.Icon.ZIndex = baseZIndex + 4
&#9;&#9;videoCaptureDropDown.Position = UDim2.new(0, 270, 0, itemTop)
&#9;&#9;videoCaptureDropDown.Size = UDim2.new(0,200,0,32)
&#9;&#9;videoCaptureDropDown.Parent = gameSettingsMenuFrame

&#9;&#9;syncVideoCaptureSetting = function()
&#9;&#9;&#9;if UserSettings().GameSettings.VideoUploadPromptBehavior == Enum.UploadSetting[&quot;Never&quot;] then
&#9;&#9;&#9;&#9;updateVideoCaptureDropDownSelection(videoNames[1])
&#9;&#9;&#9;elseif UserSettings().GameSettings.VideoUploadPromptBehavior == Enum.UploadSetting[&quot;Ask me first&quot;] then
&#9;&#9;&#9;&#9;updateVideoCaptureDropDownSelection(videoNames[2])
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;UserSettings().GameSettings.VideoUploadPromptBehavior = Enum.UploadSetting[&quot;Ask me first&quot;]
&#9;&#9;&#9;&#9;updateVideoCaptureDropDownSelection(videoNames[2])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;itemTop = itemTop + 35
&#9;end
&#9;

&#9;----------------------------------------------------------------------------------------------------
&#9;--  C U S T O M    C A M E R A    C O N T R O L S
&#9;----------------------------------------------------------------------------------------------------


&#9;----------------------------------------------------------------------------------------------------
&#9;-- F U L L  S C R E E N    M O D E
&#9;----------------------------------------------------------------------------------------------------

&#9;local fullscreenText = nil
&#9;local fullscreenShortcut = nil
&#9;local fullscreenCheckbox = nil

&#9;if not touchClient then
&#9;&#9;fullscreenText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;fullscreenText.Name = &quot;FullscreenText&quot;
&#9;&#9;fullscreenText.Text = &quot;Fullscreen Mode&quot;
&#9;&#9;fullscreenText.Size = UDim2.new(0,124,0,18)
&#9;&#9;fullscreenText.Position = UDim2.new(0,62,0,itemTop + 2)
&#9;&#9;fullscreenText.Font = Enum.Font.Arial
&#9;&#9;fullscreenText.FontSize = Enum.FontSize.Size18
&#9;&#9;fullscreenText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;fullscreenText.ZIndex = baseZIndex + 4
&#9;&#9;fullscreenText.BackgroundTransparency = 1
&#9;&#9;fullscreenText.Parent = gameSettingsMenuFrame
&#9;&#9;
&#9;&#9;fullscreenShortcut = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;fullscreenShortcut.Visible = hasGraphicsSlider
&#9;&#9;fullscreenShortcut.Name = &quot;FullscreenShortcutText&quot;
&#9;&#9;fullscreenShortcut.Text = &quot;F11&quot;
&#9;&#9;fullscreenShortcut.BackgroundTransparency = 1
&#9;&#9;fullscreenShortcut.Font = Enum.Font.Arial
&#9;&#9;fullscreenShortcut.FontSize = Enum.FontSize.Size12
&#9;&#9;fullscreenShortcut.Position = UDim2.new(0,186,0,itemTop - 4)
&#9;&#9;fullscreenShortcut.Size = UDim2.new(0,30,0,30)
&#9;&#9;fullscreenShortcut.TextColor3 = Color3.new(0,1,0)
&#9;&#9;fullscreenShortcut.ZIndex = baseZIndex + 4
&#9;&#9;fullscreenShortcut.Parent = gameSettingsMenuFrame
&#9;&#9;
&#9;&#9;fullscreenCheckbox = createTextButton(&quot;&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size18,UDim2.new(0,25,0,25),UDim2.new(0,30,0,itemTop))
&#9;&#9;fullscreenCheckbox.Name = &quot;FullscreenCheckbox&quot;
&#9;&#9;fullscreenCheckbox.ZIndex = baseZIndex + 4
&#9;&#9;fullscreenCheckbox.Parent = gameSettingsMenuFrame
&#9;&#9;fullscreenCheckbox:SetVerb(&quot;ToggleFullScreen&quot;)
&#9;&#9;if UserSettings().GameSettings:InFullScreen() then fullscreenCheckbox.Text = &quot;X&quot; end
&#9;&#9;if hasGraphicsSlider then
&#9;&#9;&#9;UserSettings().GameSettings.FullscreenChanged:connect(function(isFullscreen)
&#9;&#9;&#9;&#9;if isFullscreen then
&#9;&#9;&#9;&#9;&#9;fullscreenCheckbox.Text = &quot;X&quot;
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;fullscreenCheckbox.Text = &quot;&quot;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;fullscreenCheckbox.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if fullscreenCheckbox.Text == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;fullscreenCheckbox.Text = &quot;X&quot;
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;fullscreenCheckbox.Text = &quot;&quot;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)&#9;
&#9;&#9;end
&#9;end



&#9;----------------------------------------------------------------------------------------------------
&#9;-- G R A P H I C S    S L I D E R
&#9;----------------------------------------------------------------------------------------------------
&#9;if hasGraphicsSlider then
&#9;&#9;local qualityText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;qualityText.Name = &quot;QualityText&quot;
&#9;&#9;qualityText.Text = &quot;Graphics Quality&quot;
&#9;&#9;qualityText.Size = UDim2.new(0,128,0,18)
&#9;&#9;qualityText.Position = UDim2.new(0,30,0,239)
&#9;&#9;qualityText.Font = Enum.Font.Arial
&#9;&#9;qualityText.FontSize = Enum.FontSize.Size18
&#9;&#9;qualityText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;qualityText.ZIndex = baseZIndex + 4
&#9;&#9;qualityText.BackgroundTransparency = 1
&#9;&#9;qualityText.Parent = gameSettingsMenuFrame
&#9;&#9;qualityText.Visible = not inStudioMode
&#9;&#9;
&#9;&#9;local autoText = qualityText:clone()
&#9;&#9;autoText.Name = &quot;AutoText&quot;
&#9;&#9;autoText.Text = &quot;Auto&quot;
&#9;&#9;autoText.Position = UDim2.new(0,183,0,214)
&#9;&#9;autoText.TextColor3 = Color3.new(128/255,128/255,128/255)
&#9;&#9;autoText.Size = UDim2.new(0,34,0,18)
&#9;&#9;autoText.Parent = gameSettingsMenuFrame
&#9;&#9;autoText.Visible = not inStudioMode
&#9;&#9;
&#9;&#9;local fasterText = autoText:clone()
&#9;&#9;fasterText.Name = &quot;FasterText&quot;
&#9;&#9;fasterText.Text = &quot;Faster&quot;
&#9;&#9;fasterText.Position = UDim2.new(0,185,0,274)
&#9;&#9;fasterText.TextColor3 = Color3.new(95,95,95)
&#9;&#9;fasterText.FontSize = Enum.FontSize.Size14
&#9;&#9;fasterText.Parent = gameSettingsMenuFrame
&#9;&#9;fasterText.Visible = not inStudioMode
&#9;&#9;
&#9;&#9;local fasterShortcut = fullscreenShortcut:clone()
&#9;&#9;fasterShortcut.Name = &quot;FasterShortcutText&quot;
&#9;&#9;fasterShortcut.Text = &quot;F10 + Shift&quot;
&#9;&#9;fasterShortcut.Position = UDim2.new(0,185,0,283)
&#9;&#9;fasterShortcut.Parent = gameSettingsMenuFrame
&#9;&#9;fasterShortcut.Visible = not inStudioMode
&#9;&#9;
&#9;&#9;local betterQualityText = autoText:clone()
&#9;&#9;betterQualityText.Name = &quot;BetterQualityText&quot;
&#9;&#9;betterQualityText.Text = &quot;Better Quality&quot;
&#9;&#9;betterQualityText.TextWrap = true
&#9;&#9;betterQualityText.Size = UDim2.new(0,41,0,28)
&#9;&#9;betterQualityText.Position = UDim2.new(0,390,0,269)
&#9;&#9;betterQualityText.TextColor3 = Color3.new(95,95,95)
&#9;&#9;betterQualityText.FontSize = Enum.FontSize.Size14
&#9;&#9;betterQualityText.Parent = gameSettingsMenuFrame
&#9;&#9;betterQualityText.Visible = not inStudioMode
&#9;&#9;
&#9;&#9;local betterQualityShortcut = fullscreenShortcut:clone()
&#9;&#9;betterQualityShortcut.Name = &quot;BetterQualityShortcut&quot;
&#9;&#9;betterQualityShortcut.Text = &quot;F10&quot;
&#9;&#9;betterQualityShortcut.Position = UDim2.new(0,394,0,288)
&#9;&#9;betterQualityShortcut.Parent = gameSettingsMenuFrame
&#9;&#9;betterQualityShortcut.Visible = not inStudioMode
&#9;&#9;
&#9;&#9;local autoGraphicsButton = createTextButton(&quot;X&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size18,UDim2.new(0,25,0,25),UDim2.new(0,187,0,239))
&#9;&#9;autoGraphicsButton.Name = &quot;AutoGraphicsButton&quot;
&#9;&#9;autoGraphicsButton.ZIndex = baseZIndex + 4
&#9;&#9;autoGraphicsButton.Parent = gameSettingsMenuFrame
&#9;&#9;autoGraphicsButton.Visible = not inStudioMode
&#9;&#9;
&#9;&#9;local graphicsSlider, graphicsLevel = RbxGui.CreateSlider(GraphicsQualityLevels,150,UDim2.new(0, 230, 0, 280)) -- graphics - 1 because slider starts at 1 instead of 0
&#9;&#9;graphicsSlider.Parent = gameSettingsMenuFrame
&#9;&#9;graphicsSlider.Bar.ZIndex = baseZIndex + 4
&#9;&#9;graphicsSlider.Bar.Slider.ZIndex = baseZIndex + 5
&#9;&#9;graphicsSlider.Visible = not inStudioMode
&#9;&#9;graphicsLevel.Value = math.floor((settings().Rendering:GetMaxQualityLevel() - 1)/2)
&#9;&#9;
&#9;&#9;local graphicsSetter = Instance.new(&quot;TextBox&quot;)
&#9;&#9;graphicsSetter.Name = &quot;GraphicsSetter&quot;
&#9;&#9;graphicsSetter.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;graphicsSetter.BorderColor3 = Color3.new(128/255,128/255,128/255)
&#9;&#9;graphicsSetter.Size = UDim2.new(0,50,0,25)
&#9;&#9;graphicsSetter.Position = UDim2.new(0,450,0,269)
&#9;&#9;graphicsSetter.TextColor3 = Color3.new(1,1,1)
&#9;&#9;graphicsSetter.Font = Enum.Font.Arial
&#9;&#9;graphicsSetter.FontSize = Enum.FontSize.Size18
&#9;&#9;graphicsSetter.Text = &quot;Auto&quot;
&#9;&#9;graphicsSetter.ZIndex = 1
&#9;&#9;graphicsSetter.TextWrap = true
&#9;&#9;graphicsSetter.Parent = gameSettingsMenuFrame
&#9;&#9;graphicsSetter.Visible = not inStudioMode

&#9;&#9;local isAutoGraphics = true
&#9;&#9;if not inStudioMode then
&#9;&#9;&#9;isAutoGraphics = (UserSettings().GameSettings.SavedQualityLevel == Enum.SavedQualitySetting.Automatic)
&#9;&#9;else
&#9;&#9;&#9;settings().Rendering.EnableFRM = false
&#9;&#9;end
&#9;&#9;
&#9;&#9;local listenToGraphicsLevelChange = true
&#9;&#9;
&#9;&#9;local function setAutoGraphicsGui(active)
&#9;&#9;&#9;isAutoGraphics = active
&#9;&#9;&#9;if active then
&#9;&#9;&#9;&#9;autoGraphicsButton.Text = &quot;X&quot;
&#9;&#9;&#9;&#9;betterQualityText.ZIndex = 1
&#9;&#9;&#9;&#9;betterQualityShortcut.ZIndex = 1
&#9;&#9;&#9;&#9;fasterShortcut.ZIndex = 1
&#9;&#9;&#9;&#9;fasterText.ZIndex = 1
&#9;&#9;&#9;&#9;graphicsSlider.Bar.ZIndex = 1
&#9;&#9;&#9;&#9;graphicsSlider.Bar.Slider.ZIndex = 1
&#9;&#9;&#9;&#9;graphicsSetter.ZIndex = 1
&#9;&#9;&#9;&#9;graphicsSetter.Text = &quot;Auto&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;autoGraphicsButton.Text = &quot;&quot;
&#9;&#9;&#9;&#9;graphicsSlider.Bar.ZIndex = baseZIndex + 4
&#9;&#9;&#9;&#9;graphicsSlider.Bar.Slider.ZIndex = baseZIndex + 5
&#9;&#9;&#9;&#9;betterQualityShortcut.ZIndex = baseZIndex + 4
&#9;&#9;&#9;&#9;fasterShortcut.ZIndex = baseZIndex + 4
&#9;&#9;&#9;&#9;betterQualityText.ZIndex = baseZIndex + 4
&#9;&#9;&#9;&#9;fasterText.ZIndex = baseZIndex + 4
&#9;&#9;&#9;&#9;graphicsSetter.ZIndex = baseZIndex + 4
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function goToAutoGraphics()
&#9;&#9;&#9;setAutoGraphicsGui(true)
&#9;&#9;&#9;
&#9;&#9;&#9;UserSettings().GameSettings.SavedQualityLevel = Enum.SavedQualitySetting.Automatic
&#9;&#9;&#9;
&#9;&#9;&#9;settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic
&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;local function setGraphicsQualityLevel(newLevel)
&#9;&#9;&#9;local percentage = newLevel/GraphicsQualityLevels
&#9;&#9;&#9;local newSetting = math.floor((settings().Rendering:GetMaxQualityLevel() - 1) * percentage)
&#9;&#9;&#9;if newSetting == 20 then -- Level 20 is the same as level 21, except it doesn&apos;t render ambient occlusion
&#9;&#9;&#9;&#9;newSetting = 21
&#9;&#9;&#9;elseif newLevel == 1 then -- make sure we can go to lowest settings (for terrible computers)
&#9;&#9;&#9;&#9;newSetting = 1
&#9;&#9;&#9;elseif newSetting &gt; settings().Rendering:GetMaxQualityLevel() then
&#9;&#9;&#9;&#9;newSetting = settings().Rendering:GetMaxQualityLevel() - 1
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;UserSettings().GameSettings.SavedQualityLevel = newLevel
&#9;&#9;&#9;settings().Rendering.QualityLevel = newSetting
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function goToManualGraphics(explicitLevel)
&#9;&#9;&#9; setAutoGraphicsGui(false)
&#9;&#9;&#9;
&#9;&#9;&#9;if explicitLevel then
&#9;&#9;&#9;&#9;graphicsLevel.Value = explicitLevel
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;graphicsLevel.Value = math.floor((settings().Rendering.AutoFRMLevel/(settings().Rendering:GetMaxQualityLevel() - 1)) * GraphicsQualityLevels)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if explicitLevel == graphicsLevel.Value then -- make sure we are actually in right graphics mode
&#9;&#9;&#9;&#9;setGraphicsQualityLevel(graphicsLevel.Value)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if not explicitLevel then
&#9;&#9;&#9;&#9;UserSettings().GameSettings.SavedQualityLevel = graphicsLevel.Value
&#9;&#9;&#9;end
&#9;&#9;&#9;graphicsSetter.Text = tostring(graphicsLevel.Value)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function showAutoGraphics()
&#9;&#9;&#9;autoText.ZIndex = baseZIndex + 4
&#9;&#9;&#9;autoGraphicsButton.ZIndex = baseZIndex + 4
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function hideAutoGraphics()
&#9;&#9;&#9;autoText.ZIndex = 1
&#9;&#9;&#9;autoGraphicsButton.ZIndex = 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function showManualGraphics()
&#9;&#9;&#9;graphicsSlider.Bar.ZIndex = baseZIndex + 4
&#9;&#9;&#9;graphicsSlider.Bar.Slider.ZIndex = baseZIndex + 5
&#9;&#9;&#9;betterQualityShortcut.ZIndex = baseZIndex + 4
&#9;&#9;&#9;fasterShortcut.ZIndex = baseZIndex + 4
&#9;&#9;&#9;betterQualityText.ZIndex = baseZIndex + 4
&#9;&#9;&#9;fasterText.ZIndex = baseZIndex + 4
&#9;&#9;&#9;graphicsSetter.ZIndex = baseZIndex + 4
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function hideManualGraphics()
&#9;&#9;&#9;betterQualityText.ZIndex = 1
&#9;&#9;&#9;betterQualityShortcut.ZIndex = 1
&#9;&#9;&#9;fasterShortcut.ZIndex = 1
&#9;&#9;&#9;fasterText.ZIndex = 1
&#9;&#9;&#9;graphicsSlider.Bar.ZIndex = 1
&#9;&#9;&#9;graphicsSlider.Bar.Slider.ZIndex = 1
&#9;&#9;&#9;graphicsSetter.ZIndex = 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function translateSavedQualityLevelToInt(savedQualityLevel)
&#9;&#9;&#9;if savedQualityLevel == Enum.SavedQualitySetting.Automatic then
&#9;&#9;&#9;&#9;return 0
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel1 then
&#9;&#9;&#9;&#9;return 1
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel2 then
&#9;&#9;&#9;&#9;return 2
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel3 then
&#9;&#9;&#9;&#9;return 3
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel4 then
&#9;&#9;&#9;&#9;return 4
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel5 then
&#9;&#9;&#9;&#9;return 5
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel6 then
&#9;&#9;&#9;&#9;return 6
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel7 then
&#9;&#9;&#9;&#9;return 7
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel8 then
&#9;&#9;&#9;&#9;return 8
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel9 then
&#9;&#9;&#9;&#9;return 9
&#9;&#9;&#9;elseif savedQualityLevel == Enum.SavedQualitySetting.QualityLevel10 then
&#9;&#9;&#9;&#9;return 10
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function enableGraphicsWidget()
&#9;&#9;&#9;settings().Rendering.EnableFRM = true
&#9;&#9;&#9;
&#9;&#9;&#9;isAutoGraphics = (UserSettings().GameSettings.SavedQualityLevel == Enum.SavedQualitySetting.Automatic)
&#9;&#9;&#9;if isAutoGraphics then
&#9;&#9;&#9;&#9;showAutoGraphics()
&#9;&#9;&#9;&#9;goToAutoGraphics()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;showAutoGraphics()
&#9;&#9;&#9;&#9;showManualGraphics()
&#9;&#9;&#9;&#9;goToManualGraphics(translateSavedQualityLevelToInt(UserSettings().GameSettings.SavedQualityLevel))
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function disableGraphicsWidget()
&#9;&#9;&#9;hideManualGraphics()
&#9;&#9;&#9;hideAutoGraphics()
&#9;&#9;&#9;settings().Rendering.EnableFRM = false
&#9;&#9;end
&#9;&#9;
&#9;&#9;graphicsSetter.FocusLost:connect(function()
&#9;&#9;&#9;if isAutoGraphics then 
&#9;&#9;&#9;&#9;graphicsSetter.Text = tostring(graphicsLevel.Value)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local newGraphicsValue = tonumber(graphicsSetter.Text)
&#9;&#9;&#9;if newGraphicsValue == nil then
&#9;&#9;&#9;&#9;graphicsSetter.Text = tostring(graphicsLevel.Value)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if newGraphicsValue &lt; 1 then newGraphicsValue = 1
&#9;&#9;&#9;elseif newGraphicsValue &gt;= settings().Rendering:GetMaxQualityLevel() then
&#9;&#9;&#9;&#9;newGraphicsValue = settings().Rendering:GetMaxQualityLevel() - 1
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;graphicsLevel.Value = newGraphicsValue
&#9;&#9;&#9;setGraphicsQualityLevel(graphicsLevel.Value)
&#9;&#9;&#9;graphicsSetter.Text = tostring(graphicsLevel.Value)
&#9;&#9;end)
&#9;&#9;
&#9;&#9;graphicsLevel.Changed:connect(function(prop)
&#9;&#9;&#9;if isAutoGraphics then return end
&#9;&#9;&#9;if not listenToGraphicsLevelChange then return end
&#9;&#9;&#9;
&#9;&#9;&#9;graphicsSetter.Text = tostring(graphicsLevel.Value)
&#9;&#9;&#9;setGraphicsQualityLevel(graphicsLevel.Value)
&#9;&#9;end)
&#9;&#9;
&#9;&#9;-- setup our graphic mode on load
&#9;&#9;if inStudioMode or UserSettings().GameSettings.SavedQualityLevel == Enum.SavedQualitySetting.Automatic then
&#9;&#9;&#9;if inStudioMode then
&#9;&#9;&#9;&#9;settings().Rendering.EnableFRM = false
&#9;&#9;&#9;&#9;disableGraphicsWidget()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;settings().Rendering.EnableFRM = true
&#9;&#9;&#9;&#9;goToAutoGraphics()
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;settings().Rendering.EnableFRM = true
&#9;&#9;&#9;goToManualGraphics(translateSavedQualityLevelToInt(UserSettings().GameSettings.SavedQualityLevel))
&#9;&#9;end
&#9;&#9;
&#9;&#9;autoGraphicsButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if inStudioMode and not game.Players.LocalPlayer then return end
&#9;&#9;&#9;
&#9;&#9;&#9;if not isAutoGraphics then
&#9;&#9;&#9;&#9;goToAutoGraphics()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;goToManualGraphics(graphicsLevel.Value)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;local lastUpdate = nil
&#9;&#9;game.GraphicsQualityChangeRequest:connect(function(graphicsIncrease)
&#9;&#9;&#9;if isAutoGraphics then return end -- only can set graphics in manual mode
&#9;&#9;&#9;
&#9;&#9;&#9;if graphicsIncrease then
&#9;&#9;&#9;&#9;if (graphicsLevel.Value + 1) &gt; GraphicsQualityLevels then return end
&#9;&#9;&#9;&#9;graphicsLevel.Value = graphicsLevel.Value + 1
&#9;&#9;&#9;&#9;graphicsSetter.Text = tostring(graphicsLevel.Value)
&#9;&#9;&#9;&#9;setGraphicsQualityLevel(graphicsLevel.Value)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game:GetService(&quot;GuiService&quot;):SendNotification(&quot;Graphics Quality&quot;,
&#9;&#9;&#9;&#9;&#9;&quot;Increased to (&quot; .. graphicsSetter.Text .. &quot;)&quot;,
&#9;&#9;&#9;&#9;&#9;&quot;&quot;,
&#9;&#9;&#9;&#9;&#9;2,
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if (graphicsLevel.Value - 1) &lt;= 0 then return end
&#9;&#9;&#9;&#9;graphicsLevel.Value = graphicsLevel.Value - 1
&#9;&#9;&#9;&#9;graphicsSetter.Text = tostring(graphicsLevel.Value)
&#9;&#9;&#9;&#9;setGraphicsQualityLevel(graphicsLevel.Value)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game:GetService(&quot;GuiService&quot;):SendNotification(&quot;Graphics Quality&quot;,
&#9;&#9;&#9;&#9;&#9;&quot;Decreased to (&quot; .. graphicsSetter.Text .. &quot;)&quot;,
&#9;&#9;&#9;&#9;&#9;&quot;&quot;,
&#9;&#9;&#9;&#9;&#9;2,
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;game.Players.PlayerAdded:connect(function(player)
&#9;&#9;&#9;if player == game.Players.LocalPlayer and inStudioMode then
&#9;&#9;&#9;&#9;enableGraphicsWidget()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;game.Players.PlayerRemoving:connect(function(player)
&#9;&#9;&#9;if player == game.Players.LocalPlayer and inStudioMode then
&#9;&#9;&#9;&#9;disableGraphicsWidget()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;&#9;studioCheckbox = createTextButton(&quot;&quot;,Enum.ButtonStyle.RobloxButton,Enum.FontSize.Size18,UDim2.new(0,25,0,25),UDim2.new(0,30,0,176))
&#9;&#9;studioCheckbox.Name = &quot;StudioCheckbox&quot;
&#9;&#9;studioCheckbox.ZIndex = baseZIndex + 4
&#9;&#9;--studioCheckbox.Parent = gameSettingsMenuFrame -- todo: enable when studio h4x aren&apos;t an issue anymore
&#9;&#9;studioCheckbox:SetVerb(&quot;TogglePlayMode&quot;)
&#9;&#9;studioCheckbox.Visible = false -- todo: enabled when studio h4x aren&apos;t an issue anymore
&#9;&#9;
&#9;&#9;local wasManualGraphics = (settings().Rendering.QualityLevel ~= Enum.QualityLevel.Automatic)
&#9;&#9;if inStudioMode and not game.Players.LocalPlayer then
&#9;&#9;&#9;studioCheckbox.Text = &quot;X&quot;
&#9;&#9;&#9;disableGraphicsWidget()
&#9;&#9;elseif inStudioMode then
&#9;&#9;&#9;studioCheckbox.Text = &quot;X&quot;
&#9;&#9;&#9;enableGraphicsWidget()
&#9;&#9;end
&#9;&#9;if hasGraphicsSlider then
&#9;&#9;&#9; UserSettings().GameSettings.StudioModeChanged:connect(function(isStudioMode)
&#9;&#9;&#9;&#9;inStudioMode = isStudioMode
&#9;&#9;&#9;&#9;if isStudioMode then
&#9;&#9;&#9;&#9;&#9;wasManualGraphics = (settings().Rendering.QualityLevel ~= Enum.QualityLevel.Automatic)
&#9;&#9;&#9;&#9;&#9;goToAutoGraphics()
&#9;&#9;&#9;&#9;&#9;studioCheckbox.Text = &quot;X&quot;
&#9;&#9;&#9;&#9;&#9;autoGraphicsButton.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;autoText.ZIndex = 1
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;if wasManualGraphics then
&#9;&#9;&#9;&#9;&#9;&#9;goToManualGraphics()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;studioCheckbox.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;autoGraphicsButton.ZIndex = baseZIndex + 4
&#9;&#9;&#9;&#9;&#9;autoText.ZIndex = baseZIndex + 4
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;studioCheckbox.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if not studioCheckbox.Active then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if studioCheckbox.Text == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;studioCheckbox.Text = &quot;X&quot;
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;studioCheckbox.Text = &quot;&quot;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end
&#9;

&#9;if game:FindFirstChild(&quot;NetworkClient&quot;) then -- we are playing online
&#9;&#9;setDisabledState(studioText)
&#9;&#9;setDisabledState(studioShortcut)
&#9;&#9;setDisabledState(studioCheckbox)
&#9;end
&#9;

&#9;----------------------------------------------------------------------------------------------------
&#9;--  O K    B U T T O N
&#9;----------------------------------------------------------------------------------------------------


&#9;local backButton
&#9;if hasGraphicsSlider then
&#9;&#9;backButton = createTextButton(&quot;OK&quot;,Enum.ButtonStyle.RobloxButtonDefault,Enum.FontSize.Size24,UDim2.new(0,180,0,50),UDim2.new(0,170,0,330))
&#9;&#9;backButton.Modal = true
&#9;else
&#9;&#9;backButton = createTextButton(&quot;OK&quot;,Enum.ButtonStyle.RobloxButtonDefault,Enum.FontSize.Size24,UDim2.new(0,180,0,50),UDim2.new(0,170,0,270))
&#9;&#9;backButton.Modal = true
&#9;end
&#9;
&#9;backButton.Name = &quot;BackButton&quot;
&#9;backButton.ZIndex = baseZIndex + 4
&#9;backButton.Parent = gameSettingsMenuFrame
&#9;
&#9;return gameSettingsMenuFrame
end



if LoadLibrary then
  RbxGui = t
  local baseZIndex = 0
if UserSettings then

   
   local createReportAbuseDialog = function()

&#9;waitForChild(game,&quot;Players&quot;)
&#9;waitForProperty(game.Players, &quot;LocalPlayer&quot;)
&#9;local localPlayer = game.Players.LocalPlayer
&#9;
&#9;local reportAbuseButton
&#9;waitForChild(script.Parent,&quot;UserSettingsShield&quot;)
&#9;waitForChild(script.Parent.UserSettingsShield, &quot;Settings&quot;)
&#9;waitForChild(script.Parent.UserSettingsShield.Settings,&quot;SettingsStyle&quot;)
&#9;waitForChild(script.Parent.UserSettingsShield.Settings.SettingsStyle,&quot;GameMainMenu&quot;)
&#9;waitForChild(script.Parent.UserSettingsShield.Settings.SettingsStyle.GameMainMenu, &quot;ReportAbuseButton&quot;)
&#9;reportAbuseButton = script.Parent.UserSettingsShield.Settings.SettingsStyle.GameMainMenu.ReportAbuseButton

&#9;local shield = Instance.new(&quot;TextButton&quot;)
&#9;shield.Name = &quot;ReportAbuseShield&quot;
&#9;shield.Text = &quot;&quot;
&#9;shield.AutoButtonColor = false
&#9;shield.Active = true
&#9;shield.Visible = false
&#9;shield.Size = UDim2.new(1,0,1,0)
&#9;shield.BackgroundColor3 = Color3I(51,51,51)
&#9;shield.BorderColor3 = Color3I(27,42,53)
&#9;shield.BackgroundTransparency = 0.4
&#9;shield.ZIndex = baseZIndex + 1

&#9;local closeAndResetDialgo

&#9;local messageBoxButtons = {}
&#9;messageBoxButtons[1] = {}
&#9;messageBoxButtons[1].Text = &quot;Ok&quot;
&#9;messageBoxButtons[1].Modal = true
&#9;messageBoxButtons[1].Function = function() closeAndResetDialog() end 
&#9;local calmingMessageBox = RbxGui.CreateMessageDialog(&quot;Thanks for your report!&quot;, &quot;Our moderators will review the chat logs and determine what happened.  The other user is probably just trying to make you mad.\n\nIf anyone used swear words, inappropriate language, or threatened you in real life, please report them for Bad Words or Threats&quot;, messageBoxButtons)
&#9;calmingMessageBox.Visible = false
&#9;calmingMessageBox.Parent = shield

&#9;local recordedMessageBox = RbxGui.CreateMessageDialog(&quot;Thanks for your report!&quot;,&quot;We&apos;ve recorded your report for evaluation.&quot;, messageBoxButtons)
&#9;recordedMessageBox.Visible = false
&#9;recordedMessageBox.Parent = shield

&#9;local normalMessageBox = RbxGui.CreateMessageDialog(&quot;Thanks for your report!&quot;, &quot;Our moderators will review the chat logs and determine what happened.&quot;, messageBoxButtons)
&#9;normalMessageBox.Visible = false
&#9;normalMessageBox.Parent = shield

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Settings&quot;
&#9;frame.Position = UDim2.new(0.5, -250, 0.5, -200)
&#9;frame.Size = UDim2.new(0.0, 500, 0.0, 400)
&#9;frame.BackgroundTransparency = 1
&#9;frame.Active = true
&#9;frame.Parent = shield

&#9;local settingsFrame = Instance.new(&quot;Frame&quot;)
&#9;settingsFrame.Name = &quot;ReportAbuseStyle&quot;
&#9;settingsFrame.Size = UDim2.new(1, 0, 1, 0)
&#9;settingsFrame.Style = Enum.FrameStyle.RobloxRound
&#9;settingsFrame.Active = true
&#9;settingsFrame.ZIndex = baseZIndex + 1
&#9;settingsFrame.Parent = frame

&#9;local title = Instance.new(&quot;TextLabel&quot;)
&#9;title.Name = &quot;Title&quot;
&#9;title.Text = &quot;Report Abuse&quot;
&#9;title.TextColor3 = Color3I(221,221,221)
&#9;title.Position = UDim2.new(0.5, 0, 0, 30)
&#9;title.Font = Enum.Font.ArialBold
&#9;title.FontSize = Enum.FontSize.Size36
&#9;title.ZIndex = baseZIndex + 2
&#9;title.Parent = settingsFrame

&#9;local description = Instance.new(&quot;TextLabel&quot;)
&#9;description.Name = &quot;Description&quot;
&#9;description.Text = &quot;This will send a complete report to a moderator.  The moderator will review the chat log and take appropriate action.&quot;
&#9;description.TextColor3 = Color3I(221,221,221)
&#9;description.Position = UDim2.new(0, 0, 0, 55)
&#9;description.Size = UDim2.new(1, 0, 0, 40)
&#9;description.BackgroundTransparency = 1
&#9;description.Font = Enum.Font.Arial
&#9;description.FontSize = Enum.FontSize.Size18
&#9;description.TextWrap = true
&#9;description.ZIndex = baseZIndex + 2
&#9;description.TextXAlignment = Enum.TextXAlignment.Left
&#9;description.TextYAlignment = Enum.TextYAlignment.Top
&#9;description.Parent = settingsFrame

&#9;local playerLabel = Instance.new(&quot;TextLabel&quot;)
&#9;playerLabel.Name = &quot;PlayerLabel&quot;
&#9;playerLabel.Text = &quot;Which player?&quot;
&#9;playerLabel.BackgroundTransparency = 1
&#9;playerLabel.Font = Enum.Font.Arial
&#9;playerLabel.FontSize = Enum.FontSize.Size18
&#9;playerLabel.Position = UDim2.new(0.025,0,0,100)
&#9;playerLabel.Size &#9;   = UDim2.new(0.4,0,0,36)
&#9;playerLabel.TextColor3 = Color3I(255,255,255)
&#9;playerLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;playerLabel.ZIndex = baseZIndex + 2
&#9;playerLabel.Parent = settingsFrame

&#9;local abusingPlayer = nil
&#9;local abuse = nil
&#9;local submitReportButton = nil

&#9;local updatePlayerSelection = nil
&#9;local createPlayersDropDown = function()
&#9;&#9;local players = game:GetService(&quot;Players&quot;)
&#9;&#9;local playerNames = {}
&#9;&#9;local nameToPlayer = {}
&#9;&#9;local children = players:GetChildren()
&#9;&#9;local pos = 1
&#9;&#9;if children then
&#9;&#9;   for i, player in ipairs(children) do
&#9;&#9;&#9;&#9;if player:IsA(&quot;Player&quot;) and player ~= localPlayer then
&#9;&#9;&#9;&#9;&#9;playerNames[pos] = player.Name
&#9;&#9;&#9;&#9;&#9;nameToPlayer[player.Name] = player
&#9;&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;local playerDropDown = nil
&#9;&#9;playerDropDown, updatePlayerSelection = RbxGui.CreateDropDownMenu(playerNames, 
&#9;&#9;&#9;function(playerName) 
&#9;&#9;&#9;&#9;abusingPlayer = nameToPlayer[playerName] 
&#9;&#9;&#9;&#9;if abuse and abusingPlayer then
&#9;&#9;&#9;&#9;&#9;submitReportButton.Active = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;playerDropDown.Name = &quot;PlayersComboBox&quot;
&#9;&#9;playerDropDown.ZIndex = baseZIndex + 2
&#9;&#9;playerDropDown.Position = UDim2.new(.425, 0, 0, 102)
&#9;&#9;playerDropDown.Size = UDim2.new(.55,0,0,32)
&#9;&#9;
&#9;&#9;return playerDropDown
&#9;end
&#9;
&#9;local abuseLabel = Instance.new(&quot;TextLabel&quot;)
&#9;abuseLabel.Name = &quot;AbuseLabel&quot;
&#9;abuseLabel.Text = &quot;Type of Abuse:&quot;
&#9;abuseLabel.Font = Enum.Font.Arial
&#9;abuseLabel.BackgroundTransparency = 1
&#9;abuseLabel.FontSize = Enum.FontSize.Size18
&#9;abuseLabel.Position = UDim2.new(0.025,0,0,140)
&#9;abuseLabel.Size = UDim2.new(0.4,0,0,36)
&#9;abuseLabel.TextColor3 = Color3I(255,255,255)
&#9;abuseLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;abuseLabel.ZIndex = baseZIndex + 2
&#9;abuseLabel.Parent = settingsFrame

&#9;local abuses = {&quot;Swearing&quot;,&quot;Bullying&quot;,&quot;Scamming&quot;,&quot;Dating&quot;,&quot;Cheating/Exploiting&quot;,&quot;Personal Questions&quot;,&quot;Offsite Links&quot;,&quot;Bad Model or Script&quot;,&quot;Bad Username&quot;}
&#9;local abuseDropDown, updateAbuseSelection = RbxGui.CreateDropDownMenu(abuses, 
&#9;&#9;function(abuseText) 
&#9;&#9;&#9;abuse = abuseText 
&#9;&#9;&#9;if abuse and abusingPlayer then
&#9;&#9;&#9;&#9;submitReportButton.Active = true
&#9;&#9;&#9;end
&#9;&#9;end, true)
&#9;abuseDropDown.Name = &quot;AbuseComboBox&quot;
&#9;abuseDropDown.ZIndex = baseZIndex + 2
&#9;abuseDropDown.Position = UDim2.new(0.425, 0, 0, 142)
&#9;abuseDropDown.Size = UDim2.new(0.55,0,0,32)
&#9;abuseDropDown.Parent = settingsFrame

&#9;local shortDescriptionLabel = Instance.new(&quot;TextLabel&quot;)
&#9;shortDescriptionLabel.Name = &quot;ShortDescriptionLabel&quot;
&#9;shortDescriptionLabel.Text = &quot;Short Description: (optional)&quot;
&#9;shortDescriptionLabel.Font = Enum.Font.Arial
&#9;shortDescriptionLabel.FontSize = Enum.FontSize.Size18
&#9;shortDescriptionLabel.Position = UDim2.new(0.025,0,0,180)
&#9;shortDescriptionLabel.Size = UDim2.new(0.95,0,0,36)
&#9;shortDescriptionLabel.TextColor3 = Color3I(255,255,255)
&#9;shortDescriptionLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;shortDescriptionLabel.BackgroundTransparency = 1
&#9;shortDescriptionLabel.ZIndex = baseZIndex + 2
&#9;shortDescriptionLabel.Parent = settingsFrame

&#9;local shortDescriptionWrapper = Instance.new(&quot;Frame&quot;)
&#9;shortDescriptionWrapper.Name = &quot;ShortDescriptionWrapper&quot;
&#9;shortDescriptionWrapper.Position = UDim2.new(0.025,0,0,220)
&#9;shortDescriptionWrapper.Size = UDim2.new(0.95,0,1,-310)
&#9;shortDescriptionWrapper.BackgroundColor3 = Color3I(0,0,0)
&#9;shortDescriptionWrapper.BorderSizePixel = 0
&#9;shortDescriptionWrapper.ZIndex = baseZIndex + 2
&#9;shortDescriptionWrapper.Parent = settingsFrame

&#9;local shortDescriptionBox = Instance.new(&quot;TextBox&quot;)
&#9;shortDescriptionBox.Name = &quot;TextBox&quot;
&#9;shortDescriptionBox.Text = &quot;&quot;
&#9;shortDescriptionBox.ClearTextOnFocus = false
&#9;shortDescriptionBox.Font = Enum.Font.Arial
&#9;shortDescriptionBox.FontSize = Enum.FontSize.Size18
&#9;shortDescriptionBox.Position = UDim2.new(0,3,0,3)
&#9;shortDescriptionBox.Size = UDim2.new(1,-6,1,-6)
&#9;shortDescriptionBox.TextColor3 = Color3I(255,255,255)
&#9;shortDescriptionBox.TextXAlignment = Enum.TextXAlignment.Left
&#9;shortDescriptionBox.TextYAlignment = Enum.TextYAlignment.Top
&#9;shortDescriptionBox.TextWrap = true
&#9;shortDescriptionBox.BackgroundColor3 = Color3I(0,0,0)
&#9;shortDescriptionBox.BorderSizePixel = 0
&#9;shortDescriptionBox.ZIndex = baseZIndex + 2
&#9;shortDescriptionBox.Parent = shortDescriptionWrapper

&#9;submitReportButton = Instance.new(&quot;TextButton&quot;)
&#9;submitReportButton.Name = &quot;SubmitReportBtn&quot;
&#9;submitReportButton.Active = false
&#9;submitReportButton.Modal = true
&#9;submitReportButton.Font = Enum.Font.Arial
&#9;submitReportButton.FontSize = Enum.FontSize.Size18
&#9;submitReportButton.Position = UDim2.new(0.1, 0, 1, -80)
&#9;submitReportButton.Size = UDim2.new(0.35,0,0,50)
&#9;submitReportButton.AutoButtonColor = true
&#9;submitReportButton.Style = Enum.ButtonStyle.RobloxButtonDefault 
&#9;submitReportButton.Text = &quot;Submit Report&quot;
&#9;submitReportButton.TextColor3 = Color3I(255,255,255)
&#9;submitReportButton.ZIndex = baseZIndex + 2
&#9;submitReportButton.Parent = settingsFrame

&#9;submitReportButton.MouseButton1Click:connect(function()
&#9;&#9;if submitReportButton.Active then
&#9;&#9;&#9;if abuse and abusingPlayer then
&#9;&#9;&#9;&#9;frame.Visible = false
&#9;&#9;&#9;&#9;game.Players:ReportAbuse(abusingPlayer, abuse, shortDescriptionBox.Text)
&#9;&#9;&#9;&#9;if abuse == &quot;Cheating/Exploiting&quot; then
&#9;&#9;&#9;&#9;&#9;recordedMessageBox.Visible = true
&#9;&#9;&#9;&#9;elseif abuse == &quot;Bullying&quot; or abuse == &quot;Swearing&quot; then
&#9;&#9;&#9;&#9;&#9;calmingMessageBox.Visible = true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;normalMessageBox.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;closeAndResetDialog()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelBtn&quot;
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.Position = UDim2.new(0.55, 0, 1, -80)
&#9;cancelButton.Size = UDim2.new(0.35,0,0,50)
&#9;cancelButton.AutoButtonColor = true
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault 
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.TextColor3 = Color3I(255,255,255)
&#9;cancelButton.ZIndex = baseZIndex + 2
&#9;cancelButton.Parent = settingsFrame

&#9;closeAndResetDialog = function()

&#9;&#9;settingsButton.Active = true
&#9;&#9;currentMenuSelection = nil
&#9;&#9;lastMenuSelection = {}
&#9;&#9;--Delete old player combo box
&#9;&#9;local oldComboBox = settingsFrame:FindFirstChild(&quot;PlayersComboBox&quot;)
&#9;&#9;if oldComboBox then
&#9;&#9;&#9;oldComboBox.Parent = nil
&#9;&#9;end
&#9;&#9;
&#9;&#9;abusingPlayer = nil updatePlayerSelection(nil)
&#9;&#9;abuse = nil updateAbuseSelection(nil)
&#9;&#9;submitReportButton.Active = false
&#9;&#9;shortDescriptionBox.Text = &quot;&quot;
&#9;&#9;frame.Visible = true
&#9;&#9;calmingMessageBox.Visible = false
&#9;&#9;recordedMessageBox.Visible = false
&#9;&#9;normalMessageBox.Visible = false
&#9;&#9;shield.Visible = false&#9;&#9;
&#9;&#9;reportAbuseButton.Active = true
&#9;&#9;game.GuiService:RemoveCenterDialog(shield)
&#9;end

&#9;cancelButton.MouseButton1Click:connect(closeAndResetDialog)
&#9;
&#9;reportAbuseButton.MouseButton1Click:connect(
&#9;&#9;function() 
&#9;&#9;&#9;createPlayersDropDown().Parent = settingsFrame
&#9;&#9;&#9;table.insert(centerDialogs,shield)
&#9;&#9;&#9;game.GuiService:AddCenterDialog(shield, Enum.CenterDialogType.ModalDialog, 
&#9;&#9;&#9;&#9;--ShowFunction
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;reportAbuseButton.Active = true
&#9;&#9;&#9;&#9;&#9;shield.Visible = true
&#9;&#9;&#9;&#9;&#9;mainShield.Visible = false
&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;--HideFunction
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;reportAbuseButton.Active = true
&#9;&#9;&#9;&#9;&#9;shield.Visible = false
&#9;&#9;&#9;&#9;end)
&#9;&#9;end)

&#9;return shield
end

&#9;local createSettingsDialog = function()
&#9;&#9;waitForChild(gui,&quot;BottomLeftControl&quot;)
&#9;&#9;settingsButton = gui.BottomLeftControl:FindFirstChild(&quot;SettingsButton&quot;)
&#9;&#9;
&#9;&#9;if settingsButton == nil then
&#9;&#9;&#9;settingsButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;&#9;settingsButton.Name = &quot;SettingsButton&quot;
&#9;&#9;&#9;settingsButton.Image = &quot;rbxasset://textures/ui/SettingsButton.png&quot;
&#9;&#9;&#9;settingsButton.BackgroundTransparency = 1
&#9;&#9;&#9;settingsButton.Active = false
&#9;&#9;&#9;settingsButton.Size = UDim2.new(0,54,0,46)
&#9;&#9;&#9;settingsButton.Position = UDim2.new(0,2,0,50)
&#9;&#9;&#9;settingsButton.Parent = gui
         settingsButton.MouseButton1Click:connect(function()
&#9;&#9;    goToMenu(shield.Settings.SettingsStyle,&quot;GameMainMenu&quot;,&quot;down&quot;,UDim2.new(0,525,0,430))
&#9;&#9;    shield.Settings:TweenSize(UDim2.new(0,525,0,430),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;     end)
&#9;&#9;end

&#9;&#9;local shield = Instance.new(&quot;TextButton&quot;)
&#9;&#9;shield.Text = &quot;&quot;
&#9;&#9;shield.Name = &quot;UserSettingsShield&quot;
&#9;&#9;shield.Active = true
&#9;&#9;shield.AutoButtonColor = false
&#9;&#9;shield.Visible = false
&#9;&#9;shield.Size = UDim2.new(1,0,1,0)
&#9;&#9;shield.BackgroundColor3 = Color3I(51,51,51)
&#9;&#9;shield.BorderColor3 = Color3I(27,42,53)
&#9;&#9;shield.BackgroundTransparency = 0.4
&#9;&#9;shield.ZIndex = baseZIndex + 2
      shield.Parent = script.Parent
&#9;&#9;mainShield = shield

&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Settings&quot;
&#9;&#9;frame.Position = UDim2.new(0.5, -262, -0.5, -200)
&#9;&#9;frame.Size = UDim2.new(0, 525, 0, 430)
&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = shield

&#9;&#9;local settingsFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;settingsFrame.Name = &quot;SettingsStyle&quot;
&#9;&#9;settingsFrame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;settingsFrame.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;settingsFrame.Active = true
&#9;&#9;settingsFrame.ZIndex = baseZIndex + 3
&#9;&#9;settingsFrame.Parent = frame
&#9;&#9;
&#9;   local gameSettingsMenu = createGameSettingsMenu(baseZIndex, shield)
&#9;&#9;gameSettingsMenu.Parent = settingsFrame

      local gameReportAbuse = createReportAbuseDialog()
      gameReportAbuse.Parent = script.Parent

&#9;&#9;local gameMainMenu = createGameMainMenu(baseZIndex, shield)
&#9;&#9;gameMainMenu.Parent = settingsFrame
&#9;&#9;

 
&#9;&#9;gameMainMenu.ScreenshotButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;
&#9;&#9;end)
&#9;&#9;

&#9;&#9;

&#9;&#9;
&#9;&#9;function localPlayerChange()
&#9;&#9;&#9;gameMainMenu.ResetButton.Visible = game.Players.LocalPlayer
&#9;&#9;&#9;if game.Players.LocalPlayer then
&#9;&#9;&#9;&#9;settings().Rendering.EnableFRM = true
&#9;&#9;&#9;elseif inStudioMode then
&#9;&#9;&#9;&#9;settings().Rendering.EnableFRM = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;gameMainMenu.ResetButton.Visible = game.Players.LocalPlayer
&#9;&#9;if game.Players.LocalPlayer ~= nil then
&#9;&#9;&#9;game.Players.LocalPlayer.Changed:connect(function()
&#9;&#9;&#9;&#9;localPlayerChange()
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;waitForProperty(game.Players,&quot;LocalPlayer&quot;)
&#9;&#9;&#9;&#9;gameMainMenu.ResetButton.Visible = game.Players.LocalPlayer
&#9;&#9;&#9;&#9;game.Players.LocalPlayer.Changed:connect(function()
&#9;&#9;&#9;&#9;&#9;localPlayerChange()
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;gameMainMenu.ReportAbuseButton.Visible = game:FindFirstChild(&quot;NetworkClient&quot;)
&#9;&#9;if not gameMainMenu.ReportAbuseButton.Visible then
&#9;&#9;&#9;game.ChildAdded:connect(function(child)
&#9;&#9;&#9;&#9;if child:IsA(&quot;NetworkClient&quot;) then
&#9;&#9;&#9;&#9;&#9;gameMainMenu.ReportAbuseButton.Visible = game:FindFirstChild(&quot;NetworkClient&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;

      
&#9;&#9;gameMainMenu.ResetButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;ResetConfirmationMenu&quot;,&quot;up&quot;,UDim2.new(0,525,0,370))
&#9;&#9;end)
&#9;&#9;
&#9;&#9;gameMainMenu.LeaveGameButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;LeaveConfirmationMenu&quot;,&quot;down&quot;,UDim2.new(0,525,0,300))
&#9;&#9;end)
&#9;&#9;
&#9;
&#9;&#9;&#9;
&#9;&#9;local gameSettingsMenu = createGameSettingsMenu(baseZIndex, shield)
&#9;&#9;gameSettingsMenu.Visible = false
&#9;&#9;gameSettingsMenu.Parent = settingsFrame

&#9;&#9;gameMainMenu.LeaveGameButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;LeaveConfirmationMenu&quot;,&quot;down&quot;,UDim2.new(0,525,0,300))
&#9;&#9;end)

&#9;&#9;gameMainMenu.SettingsButton.MouseButton1Click:connect(function() 
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;GameSettingsMenu&quot;,&quot;left&quot;,UDim2.new(0,525,0,350))
&#9;&#9;end)

&#9;&#9;gameSettingsMenu.BackButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;GameMainMenu&quot;,&quot;right&quot;,UDim2.new(0,525,0,430))
&#9;&#9;end)
&#9;&#9;
&#9;&#9;local resetConfirmationWindow = createResetConfirmationMenu(baseZIndex, shield)
&#9;&#9;resetConfirmationWindow.Visible = false
&#9;&#9;resetConfirmationWindow.Parent = settingsFrame
&#9;&#9;
&#9;&#9;local leaveConfirmationWindow = createLeaveConfirmationMenu(baseZIndex,shield)
&#9;&#9;leaveConfirmationWindow.Visible = false
&#9;&#9;leaveConfirmationWindow.Parent = settingsFrame

   

&#9;
&#9;&#9;
&#9;&#9;settingsButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;game.GuiService:AddCenterDialog(shield, Enum.CenterDialogType.ModalDialog,
&#9;&#9;&#9;&#9;&#9;--showFunction
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;settingsButton.Active = false
&#9;&#9;&#9;&#9;&#9;&#9;updateCameraDropDownSelection(UserSettings().GameSettings.ControlMode.Name)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if syncVideoCaptureSetting then
  &#9;&#9;&#9;&#9;&#9;&#9;&#9;syncVideoCaptureSetting()
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;goToMenu(settingsFrame,&quot;GameMainMenu&quot;,&quot;right&quot;,UDim2.new(0,525,0,430))
&#9;&#9;&#9;&#9;&#9;&#9;shield.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenPosition(UDim2.new(0.5, -262,0.5, -200),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenSize(UDim2.new(0,525,0,430),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;&#9;--hideFunction
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenPosition(UDim2.new(0.5, -262,-0.5, -200),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenSize(UDim2.new(0,525,0,430),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;&#9;&#9;&#9;shield.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;settingsButton.Active = true
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;return shield
&#9;end

&#9;
delay(0, function()
&#9;&#9;if settingsButton == nil then
&#9;&#9;&#9;settingsButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;&#9;settingsButton.Name = &quot;SettingsButton&quot;
&#9;&#9;&#9;settingsButton.Image = &quot;rbxasset://textures/ui/SettingsButton.png&quot;
&#9;&#9;&#9;settingsButton.BackgroundTransparency = 1
&#9;&#9;&#9;settingsButton.Active = false
&#9;&#9;&#9;settingsButton.Size = UDim2.new(0,54,0,46)
&#9;&#9;&#9;settingsButton.Position = UDim2.new(0,2,0,50)
&#9;&#9;&#9;settingsButton.Parent = gui.BottomLeftControl
&#9;&#9;end

&#9;&#9;local shield = Instance.new(&quot;TextButton&quot;)
&#9;&#9;shield.Text = &quot;&quot;
&#9;&#9;shield.Name = &quot;UserSettingsShield&quot;
&#9;&#9;shield.Active = true
&#9;&#9;shield.AutoButtonColor = false
&#9;&#9;shield.Visible = false
&#9;&#9;shield.Size = UDim2.new(1,0,1,0)
&#9;&#9;shield.BackgroundColor3 = Color3I(51,51,51)
&#9;&#9;shield.BorderColor3 = Color3I(27,42,53)
&#9;&#9;shield.BackgroundTransparency = 0.4
&#9;&#9;shield.ZIndex = baseZIndex + 2
      shield.Parent = script.Parent
&#9;&#9;mainShield = shield

 

&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Settings&quot;
&#9;&#9;frame.Position = UDim2.new(0.5, -262, -0.5, -200)
&#9;&#9;frame.Size = UDim2.new(0, 525, 0, 430)
&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = shield

&#9;&#9;local settingsFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;settingsFrame.Name = &quot;SettingsStyle&quot;
&#9;&#9;settingsFrame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;settingsFrame.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;settingsFrame.Active = true
&#9;&#9;settingsFrame.ZIndex = baseZIndex + 3
&#9;&#9;settingsFrame.Parent = frame
 
      

&#9;&#9;local resetConfirmationWindow = createResetConfirmationMenu(baseZIndex, shield)
&#9;&#9;resetConfirmationWindow.Visible = false
&#9;&#9;resetConfirmationWindow.Parent = settingsFrame

      local leaveConfirmationWindow = createLeaveConfirmationMenu(baseZIndex,shield)
&#9;&#9;leaveConfirmationWindow.Visible = false
&#9;&#9;leaveConfirmationWindow.Parent = settingsFrame


&#9;&#9;local gameMainMenu = createGameMainMenu(baseZIndex, shield)
&#9;&#9;gameMainMenu.Parent = settingsFrame

&#9;&#9;local gameSettingsMenu = createGameSettingsMenu(baseZIndex, shield)
&#9;&#9;gameSettingsMenu.Visible = false
&#9;&#9;gameSettingsMenu.Parent = settingsFrame
&#9;&#9;
&#9;&#9;gameMainMenu.SettingsButton.MouseButton1Click:connect(function() 
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;GameSettingsMenu&quot;,&quot;left&quot;,UDim2.new(0,525,0,350))
&#9;&#9;end)

&#9;&#9;gameSettingsMenu.BackButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;GameMainMenu&quot;,&quot;right&quot;,UDim2.new(0,525,0,430))
&#9;&#9;end)

      &#9;gameMainMenu.ResetButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;ResetConfirmationMenu&quot;,&quot;up&quot;,UDim2.new(0,525,0,370))
&#9;&#9;end)

      gameMainMenu.LeaveGameButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;goToMenu(settingsFrame,&quot;LeaveConfirmationMenu&quot;,&quot;up&quot;,UDim2.new(0,525,0,300))
&#9;&#9;end)
 
      

&#9;&#9;gameMainMenu.ScreenshotButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;
&#9;&#9;end)

&#9;&#9; settingsButton.MouseButton1Click:connect(function()
          goToMenu(settingsFrame,&quot;GameMainMenu&quot;,&quot;right&quot;,UDim2.new(0,525,0,430))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;shield.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;shield.Active = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenPosition(UDim2.new(0.5, -262,0.5, -200),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenSize(UDim2.new(0,525,0,430),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;     end)

      game:GetService(&quot;GuiService&quot;).EscapeKeyPressed:connect(function()
&#9;&#9;&#9;&#9;if shield.Visible == false then
                     goToMenu(settingsFrame,&quot;GameMainMenu&quot;,&quot;right&quot;,UDim2.new(0,525,0,430))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;shield.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;shield.Active = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenPosition(UDim2.new(0.5, -262,0.5, -200),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;settingsFrame.Parent:TweenSize(UDim2.new(0,525,0,430),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)
            elseif shield.Visible == true then
            resumeGameFunction(shield)    

end

end)


&#9;&#9;gui.BottomLeftControl.SettingsButton.Active = true
&#9;&#9;gui.BottomLeftControl.SettingsButton.Position = UDim2.new(0,2,0,-2)
&#9;&#9;
&#9;&#9;if mouseLockLabel and UserSettings().GameSettings.ControlMode == Enum.ControlMode[&quot;Mouse Lock Switch&quot;] then
&#9;&#9;&#9;mouseLockLabel.Visible = true
&#9;&#9;elseif mouseLockLabel then
&#9;&#9;&#9;mouseLockLabel.Visible = false
&#9;&#9;end
&#9;&#9;

local createSaveDialogs = function()
&#9;local shield = Instance.new(&quot;TextButton&quot;)
&#9;shield.Text = &quot;&quot;
&#9;shield.AutoButtonColor = false
&#9;shield.Name = &quot;SaveDialogShield&quot;
&#9;shield.Active = true
&#9;shield.Visible = false
&#9;shield.Size = UDim2.new(1,0,1,0)
&#9;shield.BackgroundColor3 = Color3I(51,51,51)
&#9;shield.BorderColor3 = Color3I(27,42,53)
&#9;shield.BackgroundTransparency = 0.4
&#9;shield.ZIndex = baseZIndex+1

&#9;local clearAndResetDialog
&#9;local save
&#9;local saveLocal
&#9;local dontSave
&#9;local cancel

&#9;local messageBoxButtons = {}
&#9;messageBoxButtons[1] = {}
&#9;messageBoxButtons[1].Text = &quot;Save&quot;
&#9;messageBoxButtons[1].Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;messageBoxButtons[1].Function = function() save() end 
&#9;messageBoxButtons[2] = {}
&#9;messageBoxButtons[2].Text = &quot;Cancel&quot;
&#9;messageBoxButtons[2].Function = function() cancel() end 
&#9;messageBoxButtons[3] = {}
&#9;messageBoxButtons[3].Text = &quot;Don&apos;t Save&quot;
&#9;messageBoxButtons[3].Function = function() dontSave() end 

&#9;local saveDialogMessageBox = RbxGui.CreateStyledMessageDialog(&quot;Unsaved Changes&quot;, &quot;Save your changes to ROBLOX before leaving?&quot;, &quot;Confirm&quot;, messageBoxButtons)
&#9;saveDialogMessageBox.Visible = true
&#9;saveDialogMessageBox.Parent = shield


&#9;local errorBoxButtons = {}

&#9;local buttonOffset = 1
&#9;if game.LocalSaveEnabled then
&#9;&#9;errorBoxButtons[buttonOffset] = {}
&#9;&#9;errorBoxButtons[buttonOffset].Text = &quot;Save to Disk&quot;
&#9;&#9;errorBoxButtons[buttonOffset].Function = function() saveLocal() end 
&#9;&#9;buttonOffset = buttonOffset + 1
&#9;end
&#9;errorBoxButtons[buttonOffset] = {}
&#9;errorBoxButtons[buttonOffset].Text = &quot;Keep Playing&quot;
&#9;errorBoxButtons[buttonOffset].Function = function() cancel() end 
&#9;errorBoxButtons[buttonOffset+1] = {}
&#9;errorBoxButtons[buttonOffset+1].Text = &quot;Don&apos;t Save&quot;
&#9;errorBoxButtons[buttonOffset+1].Function = function() dontSave() end 

&#9;local errorDialogMessageBox = RbxGui.CreateStyledMessageDialog(&quot;Upload Failed&quot;, &quot;Sorry, we could not save your changes to ROBLOX.&quot;, &quot;Error&quot;, errorBoxButtons)
&#9;errorDialogMessageBox.Visible = false
&#9;errorDialogMessageBox.Parent = shield

&#9;local spinnerDialog = Instance.new(&quot;Frame&quot;)
&#9;spinnerDialog.Name = &quot;SpinnerDialog&quot;
&#9;spinnerDialog.Style = Enum.FrameStyle.RobloxRound
&#9;spinnerDialog.Size = UDim2.new(0, 350, 0, 150)
&#9;spinnerDialog.Position = UDim2.new(.5, -175, .5, -75)
&#9;spinnerDialog.Visible = false
&#9;spinnerDialog.Active = true
&#9;spinnerDialog.Parent = shield

&#9;local waitingLabel = Instance.new(&quot;TextLabel&quot;)
&#9;waitingLabel.Name = &quot;WaitingLabel&quot;
&#9;waitingLabel.Text = &quot;Saving to ROBLOX...&quot;
&#9;waitingLabel.Font = Enum.Font.ArialBold
&#9;waitingLabel.FontSize = Enum.FontSize.Size18
&#9;waitingLabel.Position = UDim2.new(0.5, 25, 0.5, 0)
&#9;waitingLabel.TextColor3 = Color3.new(1,1,1)
&#9;waitingLabel.Parent = spinnerDialog

&#9;local spinnerFrame = Instance.new(&quot;Frame&quot;)
&#9;spinnerFrame.Name = &quot;Spinner&quot;
&#9;spinnerFrame.Size = UDim2.new(0, 80, 0, 80)
&#9;spinnerFrame.Position = UDim2.new(0.5, -150, 0.5, -40)
&#9;spinnerFrame.BackgroundTransparency = 1
&#9;spinnerFrame.Parent = spinnerDialog

&#9;local spinnerIcons = {}
&#9;local spinnerNum = 1
&#9;while spinnerNum &lt;= 8 do
&#9;&#9;local spinnerImage = Instance.new(&quot;ImageLabel&quot;)
&#9;   spinnerImage.Name = &quot;Spinner&quot;..spinnerNum
&#9;&#9;spinnerImage.Size = UDim2.new(0, 16, 0, 16)
&#9;&#9;spinnerImage.Position = UDim2.new(.5+.3*math.cos(math.rad(45*spinnerNum)), -8, .5+.3*math.sin(math.rad(45*spinnerNum)), -8)
&#9;&#9;spinnerImage.BackgroundTransparency = 1
&#9;   spinnerImage.Image = &quot;http://www.roblox.com/Asset?id=45880710&quot;
&#9;&#9;spinnerImage.Parent = spinnerFrame

&#9;   spinnerIcons[spinnerNum] = spinnerImage
&#9;   spinnerNum = spinnerNum + 1
&#9;end

&#9;save = function()
&#9;&#9;saveDialogMessageBox.Visible = false
&#9;&#9;
&#9;&#9;--Show the spinner dialog
&#9;&#9;spinnerDialog.Visible = true
&#9;&#9;local spin = true
&#9;&#9;--Make it spin
&#9;&#9;delay(0, function()
&#9;&#9;  local spinPos = 0
&#9;&#9;&#9;while spin do
&#9;&#9;&#9;&#9;local pos = 0

&#9;&#9;&#9;&#9;while pos &lt; 8 do
&#9;&#9;&#9;&#9;&#9;if pos == spinPos or pos == ((spinPos+1)%8) then
&#9;&#9;&#9;&#9;&#9;&#9;spinnerIcons[pos+1].Image = &quot;http://www.roblox.com/Asset?id=45880668&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;spinnerIcons[pos+1].Image = &quot;http://www.roblox.com/Asset?id=45880710&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;spinPos = (spinPos + 1) % 8
&#9;&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;&#9;--Do the save while the spinner is going, function will wait
&#9;&#9;local result = game:SaveToRoblox()
&#9;&#9;if not result then
&#9;&#9;&#9;--Try once more
&#9;&#9;&#9;result = game:SaveToRoblox()
&#9;&#9;end

&#9;&#9;--Hide the spinner dialog
&#9;&#9;spinnerDialog.Visible = false
&#9;&#9;--And cause the delay thread to stop
&#9;&#9;spin = false&#9;

&#9;&#9;--Now process the result
&#9;&#9;if result then
&#9;&#9;&#9;--Success, close
&#9;&#9;&#9;game:FinishShutdown(false)
&#9;&#9;&#9;clearAndResetDialog()
&#9;&#9;else
&#9;&#9;&#9;--Failure, show the second dialog prompt
&#9;&#9;&#9;errorDialogMessageBox.Visible = true
&#9;&#9;end
&#9;end

&#9;saveLocal = function()
&#9;&#9;errorDialogMessageBox.Visible = false
&#9;&#9;game:FinishShutdown(true)
&#9;&#9;clearAndResetDialog()
&#9;end

&#9;dontSave = function()
&#9;&#9;saveDialogMessageBox.Visible = false
&#9;&#9;errorDialogMessageBox.Visible = false
&#9;&#9;game:FinishShutdown(false)
&#9;&#9;clearAndResetDialog()
&#9;end
&#9;cancel = function()
&#9;&#9;saveDialogMessageBox.Visible = false
&#9;&#9;errorDialogMessageBox.Visible = false
&#9;&#9;clearAndResetDialog()
&#9;end

&#9;clearAndResetDialog = function()
&#9;&#9;saveDialogMessageBox.Visible = true
&#9;&#9;errorDialogMessageBox.Visible = false
&#9;&#9;spinnerDialog.Visible = false
&#9;&#9;shield.Visible = false
&#9;&#9;game.GuiService:RemoveCenterDialog(shield)
&#9;end


&#9;shield.Visible = false
&#9;return shield
end


local createChatBar = function()
&#9;--Only show a chat bar if we are a NetworkClient
&#9;waitForChild(game, &quot;NetworkClient&quot;)

&#9;waitForChild(game, &quot;Players&quot;)
&#9;waitForProperty(game.Players, &quot;LocalPlayer&quot;)
&#9;
&#9;local chatBar = Instance.new(&quot;Frame&quot;)
&#9;chatBar.Name = &quot;ChatBar&quot;
&#9;chatBar.Size = UDim2.new(1, 0, 0, 22)
&#9;chatBar.Position = UDim2.new(0, 0, 1, 0)
&#9;chatBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;chatBar.BorderSizePixel = 0

&#9;local chatBox = Instance.new(&quot;TextBox&quot;)
&#9;chatBox.Text = &quot;&quot;
&#9;chatBox.Visible = false
&#9;chatBox.Size = UDim2.new(1,-4,1,0)
&#9;chatBox.Position = UDim2.new(0,2,0,0)
&#9;chatBox.TextXAlignment = Enum.TextXAlignment.Left
&#9;chatBox.Font = Enum.Font.Arial
&#9;chatBox.ClearTextOnFocus = false
&#9;chatBox.FontSize = Enum.FontSize.Size14
&#9;chatBox.TextColor3 = Color3.new(1,1,1)
&#9;chatBox.BackgroundTransparency = 1
&#9;--chatBox.Parent = chatBar

&#9;local chatButton = Instance.new(&quot;TextButton&quot;)
&#9;chatButton.Size = UDim2.new(1,-4,1,0)
&#9;chatButton.Position = UDim2.new(0,2,0,0)
&#9;chatButton.AutoButtonColor = false
&#9;chatButton.Text = &quot;To chat click here or press \&quot;/\&quot; key&quot;
&#9;chatButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;chatButton.Font = Enum.Font.Arial
&#9;chatButton.FontSize = Enum.FontSize.Size14
&#9;chatButton.TextColor3 = Color3.new(1,1,1)
&#9;chatButton.BackgroundTransparency = 1
&#9;--chatButton.Parent = chatBar

&#9;local activateChat = function()
&#9;&#9;if chatBox.Visible then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;chatButton.Visible = false
&#9;&#9;chatBox.Text = &quot;&quot;
&#9;&#9;chatBox.Visible = true
&#9;&#9;chatBox:CaptureFocus()
&#9;end

&#9;chatButton.MouseButton1Click:connect(activateChat)

&#9;local hotKeyEnabled = true
&#9;local toggleHotKey = function(value)
&#9;&#9;hotKeyEnabled = value
&#9;end
&#9;
&#9;local guiService = game:GetService(&quot;GuiService&quot;)
&#9;local newChatMode = pcall(function()
&#9;&#9;--guiService:AddSpecialKey(Enum.SpecialKey.ChatHotkey)
&#9;&#9;--guiService.SpecialKeyPressed:connect(function(key) if key == Enum.SpecialKey.ChatHotkey and hotKeyEnabled then activateChat() end end)
&#9;end)
&#9;if not newChatMode then
&#9;&#9;--guiService:AddKey(&quot;/&quot;)
&#9;&#9;--guiService.KeyPressed:connect(function(key) if key == &quot;/&quot; and hotKeyEnabled then activateChat() end end)
&#9;end

&#9;chatBox.FocusLost:connect(
&#9;&#9;function(enterPressed)
&#9;&#9;&#9;if enterPressed then
&#9;&#9;&#9;&#9;if chatBox.Text ~= &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;local str = chatBox.Text
&#9;&#9;&#9;&#9;&#9;if string.sub(str, 1, 1) == &apos;%&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;game.Players:TeamChat(string.sub(str, 2))
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;game.Players:Chat(str)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;chatBox.Text = &quot;&quot;
&#9;&#9;&#9;chatBox.Visible = false
&#9;&#9;&#9;chatButton.Visible = true
&#9;&#9;end)

&#9;return chatBar, toggleHotKey
end

--Spawn a thread for the Save dialogs
local isSaveDialogSupported = pcall(function() local var = game.LocalSaveEnabled end)
if isSaveDialogSupported then
&#9;delay(0, 
&#9;&#9;function()
&#9;&#9;&#9;local saveDialogs = createSaveDialogs()
&#9;&#9;&#9;saveDialogs.Parent = gui
&#9;&#9;
&#9;&#9;&#9;game.RequestShutdown = function()
&#9;&#9;&#9;&#9;table.insert(centerDialogs,saveDialogs)
&#9;&#9;&#9;&#9;game.GuiService:AddCenterDialog(saveDialogs, Enum.CenterDialogType.QuitDialog,
&#9;&#9;&#9;&#9;&#9;--ShowFunction
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;saveDialogs.Visible = true 
&#9;&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;&#9;--HideFunction
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;saveDialogs.Visible = false
&#9;&#9;&#9;&#9;&#9;end)

&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end)
end


end)


--Spawn a thread for the Report Abuse dialogs
delay(0, 
&#9;function()
&#9;&#9;createReportAbuseDialog().Parent = script.Parent
&#9;&#9;waitForChild(gui,&quot;UserSettingsShield&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield, &quot;Settings&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield.Settings,&quot;SettingsStyle&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield.Settings.SettingsStyle,&quot;GameMainMenu&quot;)
&#9;&#9;waitForChild(gui.UserSettingsShield.Settings.SettingsStyle.GameMainMenu, &quot;ReportAbuseButton&quot;)
&#9;&#9;gui.UserSettingsShield.Settings.SettingsStyle.GameMainMenu.ReportAbuseButton.Active = true
&#9;end)

end --LoadLibrary if

end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX27">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Workaround</string>
					<ProtectedString name="Source">local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end


waitForChild(game, &quot;NetworkClient&quot;)

wait(0.1)
game.Players.LocalPlayer.PlayerGui.Menu.MenuScript.Disabled = true
game.Players.LocalPlayer.PlayerGui.Menu.MenuScript.Disabled = false

if game.NetworkClient == nil then
print(&quot;Playing solo, not using workaround.&quot;)
end

</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX28">
			<Properties>
				<string name="Name">Notifications</string>
			</Properties>
			<Item class="LocalScript" referent="RBX29">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Init</string>
					<ProtectedString name="Source">--rbxsig%DIuke4NUwBAugRhVX8zUGw0lNHksGNmUbxnUjItyfN6YfmsPF6w9OML1jkc9uaOFfrayWCJEroukxRmuvY9E5jVqOM8TBXgRXfyVoJsVQ+YRTUdE1U1Jn/X7+oh/W1LN8Ayn42HhTEVjEbpVV+BHAeQZpjZltXo5qyozomUTeQE=%
--rbxassetid%48488398%
function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end
function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForProperty(game.Players,&quot;LocalPlayer&quot;)
waitForChild(script.Parent,&quot;Popup&quot;)
waitForChild(script.Parent.Popup,&quot;AcceptButton&quot;)
script.Parent.Popup.AcceptButton.Modal = true

local localPlayer = game.Players.LocalPlayer
local acceptedTeleport = Instance.new(&quot;IntValue&quot;)

local friendRequestBlacklist = {}

local teleportEnabled = true

local makePopupInvisible = function()
&#9;if script.Parent.Popup then script.Parent.Popup.Visible = false end
end

function makeFriend(fromPlayer,toPlayer)
&#9;
&#9;local popup = script.Parent:FindFirstChild(&quot;Popup&quot;)
&#9;if popup == nil then return end -- there is no popup!
&#9;if popup.Visible then return end -- currently popping something, abort!
&#9;if friendRequestBlacklist[fromPlayer] then return end -- previously cancelled friend request, we don&apos;t want it!

&#9;popup.PopupText.Text = &quot;Accept Friend Request from &quot; .. tostring(fromPlayer.Name) .. &quot;?&quot;
&#9;popup.PopupImage.Image = &quot;http://www.roblox.com/thumbs/avatar.ashx?userId=&quot;..tostring(fromPlayer.userId)..&quot;&amp;x=352&amp;y=352&quot;
&#9;
&#9;showTwoButtons()
&#9;popup.Visible = true
&#9;popup.AcceptButton.Text = &quot;Accept&quot;
&#9;popup.DeclineButton.Text = &quot;Decline&quot;
&#9;popup:TweenSize(UDim2.new(0,330,0,350),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true)
&#9;
&#9;local yesCon, noCon

&#9;yesCon = popup.AcceptButton.MouseButton1Click:connect(function()
&#9;&#9;popup.Visible = false
&#9;&#9;toPlayer:RequestFriendship(fromPlayer)
&#9;&#9;if yesCon then yesCon:disconnect() end
&#9;&#9;if noCon then noCon:disconnect() end
&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;end)

&#9;noCon = popup.DeclineButton.MouseButton1Click:connect(function()
&#9;&#9;popup.Visible = false
&#9;&#9;toPlayer:RevokeFriendship(fromPlayer)
&#9;&#9;friendRequestBlacklist[fromPlayer] = true 
&#9;&#9;print(&quot;pop up blacklist&quot;)
&#9;&#9;if yesCon then yesCon:disconnect() end
&#9;&#9;if noCon then noCon:disconnect() end
&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;end)
end


game.Players.FriendRequestEvent:connect(function(fromPlayer,toPlayer,event)

&#9;-- if this doesn&apos;t involve me, then do nothing
&#9;if fromPlayer ~= localPlayer and toPlayer ~= localPlayer then return end

&#9;if fromPlayer == localPlayer then
&#9;&#9;if event == Enum.FriendRequestEvent.Accept then
&#9;&#9;&#9;game:GetService(&quot;GuiService&quot;):SendNotification(&quot;You are Friends&quot;,
&#9;&#9;&#9;&quot;With &quot; .. toPlayer.Name .. &quot;!&quot;,
&#9;&#9;&#9;&quot;http://www.roblox.com/thumbs/avatar.ashx?userId=&quot;..tostring(toPlayer.userId)..&quot;&amp;x=48&amp;y=48&quot;,
&#9;&#9;&#9;5,
&#9;&#9;&#9;function()
&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;elseif toPlayer == localPlayer then
&#9;&#9;if event == Enum.FriendRequestEvent.Issue then
&#9;&#9;&#9;if friendRequestBlacklist[fromPlayer] then return end -- previously cancelled friend request, we don&apos;t want it!
&#9;&#9;&#9;game:GetService(&quot;GuiService&quot;):SendNotification(&quot;Friend Request&quot;,
&#9;&#9;&#9;&#9;&quot;From &quot; .. fromPlayer.Name,
&#9;&#9;&#9;&#9;&quot;http://www.roblox.com/thumbs/avatar.ashx?userId=&quot;..tostring(fromPlayer.userId)..&quot;&amp;x=48&amp;y=48&quot;,
&#9;&#9;&#9;&#9;8,
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;makeFriend(fromPlayer,toPlayer)
&#9;&#9;&#9;&#9;end)
&#9;&#9;elseif event == Enum.FriendRequestEvent.Accept then
&#9;&#9;&#9;game:GetService(&quot;GuiService&quot;):SendNotification(&quot;You are Friends&quot;,
&#9;&#9;&#9;&quot;With &quot; .. fromPlayer.Name .. &quot;!&quot;,
&#9;&#9;&#9;&quot;http://www.roblox.com/thumbs/avatar.ashx?userId=&quot;..tostring(fromPlayer.userId)..&quot;&amp;x=48&amp;y=48&quot;,
&#9;&#9;&#9;5,
&#9;&#9;&#9;function()
&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end
end)

function showOneButton()
&#9;local popup = script.Parent:FindFirstChild(&quot;Popup&quot;)
&#9;if popup then
&#9;&#9;popup.OKButton.Visible = true
&#9;&#9;popup.DeclineButton.Visible = false
&#9;&#9;popup.AcceptButton.Visible = false
&#9;end
end

function showTwoButtons()
&#9;local popup = script.Parent:FindFirstChild(&quot;Popup&quot;)
&#9;if popup then
&#9;&#9;popup.OKButton.Visible = false
&#9;&#9;popup.DeclineButton.Visible = true
&#9;&#9;popup.AcceptButton.Visible = true
&#9;end&#9;
end

if teleportEnabled then
&#9;game:GetService(&quot;TeleportService&quot;).ErrorCallback = function(message)
&#9;&#9;local popup = script.Parent:FindFirstChild(&quot;Popup&quot;)
&#9;&#9;showOneButton()
&#9;&#9;popup.PopupText.Text = message
&#9;&#9;local clickCon
&#9;&#9;clickCon = popup.OKButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if clickCon then clickCon:disconnect() end
&#9;&#9;&#9;game.GuiService:RemoveCenterDialog(script.Parent:FindFirstChild(&quot;Popup&quot;))
&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;&#9;end)
&#9;&#9;game.GuiService:AddCenterDialog(script.Parent:FindFirstChild(&quot;Popup&quot;), Enum.CenterDialogType.QuitDialog,
&#9;&#9;&#9;--ShowFunction
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;showOneButton()
&#9;&#9;&#9;&#9;script.Parent:FindFirstChild(&quot;Popup&quot;).Visible = true 
&#9;&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,330,0,350),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true)
&#9;&#9;&#9;end,
&#9;&#9;&#9;--HideFunction
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;&#9;&#9;end)

&#9;end
&#9;game:GetService(&quot;TeleportService&quot;).ConfirmationCallback = function(message, placeId, spawnName)
&#9;&#9;local popup = script.Parent:FindFirstChild(&quot;Popup&quot;)
&#9;&#9;popup.PopupText.Text = message
&#9;&#9;popup.PopupImage.Image = &quot;&quot;
&#9;&#9;
&#9;&#9;local yesCon, noCon
&#9;&#9;
&#9;&#9;local function killCons()
&#9;&#9;&#9;if yesCon then yesCon:disconnect() end
&#9;&#9;&#9;if noCon then noCon:disconnect() end
&#9;&#9;&#9;game.GuiService:RemoveCenterDialog(script.Parent:FindFirstChild(&quot;Popup&quot;))
&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;&#9;end

&#9;&#9;yesCon = popup.AcceptButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;killCons()
&#9;&#9;&#9;local success, err = pcall(function() game:GetService(&quot;TeleportService&quot;):TeleportImpl(placeId,spawnName) end)
&#9;&#9;&#9;if not success then
&#9;&#9;&#9;&#9;showOneButton()
&#9;&#9;&#9;&#9;popup.PopupText.Text = err
&#9;&#9;&#9;&#9;local clickCon
&#9;&#9;&#9;&#9;clickCon = popup.OKButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;if clickCon then clickCon:disconnect() end
&#9;&#9;&#9;&#9;&#9;game.GuiService:RemoveCenterDialog(script.Parent:FindFirstChild(&quot;Popup&quot;))
&#9;&#9;&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;game.GuiService:AddCenterDialog(script.Parent:FindFirstChild(&quot;Popup&quot;), Enum.CenterDialogType.QuitDialog,
&#9;&#9;&#9;&#9;&#9;&#9;--ShowFunction
&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;showOneButton()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;script.Parent:FindFirstChild(&quot;Popup&quot;).Visible = true 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,330,0,350),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true)
&#9;&#9;&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;&#9;&#9;--HideFunction
&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;&#9;noCon = popup.DeclineButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;killCons()
&#9;&#9;&#9;local success = pcall(function() game:GetService(&quot;TeleportService&quot;):TeleportCancel() end)
&#9;&#9;end)

&#9;&#9;local centerDialogSuccess = pcall(function() game.GuiService:AddCenterDialog(script.Parent:FindFirstChild(&quot;Popup&quot;), Enum.CenterDialogType.QuitDialog,
&#9;&#9;&#9;&#9;&#9;&#9;--ShowFunction
&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;showTwoButtons()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;popup.AcceptButton.Text = &quot;Leave&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;popup.DeclineButton.Text = &quot;Stay&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;script.Parent:FindFirstChild(&quot;Popup&quot;).Visible = true 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,330,0,350),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true)
&#9;&#9;&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;&#9;&#9;--HideFunction
&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true,makePopupInvisible())
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;if centerDialogSuccess == false then
&#9;&#9;&#9;script.Parent:FindFirstChild(&quot;Popup&quot;).Visible = true 
&#9;&#9;&#9;popup.AcceptButton.Text = &quot;Leave&quot;
&#9;&#9;&#9;popup.DeclineButton.Text = &quot;Stay&quot;
&#9;&#9;&#9;popup:TweenSize(UDim2.new(0,330,0,350),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,1,true)
&#9;&#9;end
&#9;&#9;return true
&#9;&#9;&#9;&#9;&#9;
&#9;end
end</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX30">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PopupScript</string>
					<ProtectedString name="Source">--rbxsig%kFJjpVHvWkJX02PNT/54It5wEJZscSSdzAhjsXr0WtGNy+idQIKiWTiMUqEANPv/ST8P3B5jNDPtM9SNqR53nY9P6B1PAS08ik0AquNdrWORpnFHwksP3xC2ysi2Y1LsByVO2Uj0FikBhLe1CAVmlmX22AqbO/qNaL26sftSHT0=%
--rbxassetid%48488451%
--build our gui

local popupFrame = Instance.new(&quot;Frame&quot;)
popupFrame.Position = UDim2.new(0.5,-165,0.5,-175)
popupFrame.Size = UDim2.new(0,330,0,350)
popupFrame.Style = Enum.FrameStyle.RobloxRound
popupFrame.ZIndex = 4
popupFrame.Name = &quot;Popup&quot;
popupFrame.Visible = false
popupFrame.Parent = script.Parent

local darken = popupFrame:clone()
darken.Size = UDim2.new(1,16,1,16)
darken.Position = UDim2.new(0,-8,0,-8)
darken.Name = &quot;Darken&quot;
darken.ZIndex = 1
darken.Parent = popupFrame

local acceptButton = Instance.new(&quot;TextButton&quot;)
acceptButton.Position = UDim2.new(0,20,0,270)
acceptButton.Size = UDim2.new(0,100,0,50)
acceptButton.Font = Enum.Font.ArialBold
acceptButton.FontSize = Enum.FontSize.Size24
acceptButton.Style = Enum.ButtonStyle.RobloxButton
acceptButton.TextColor3 = Color3.new(248/255,248/255,248/255)
acceptButton.Text = &quot;Yes&quot;
acceptButton.ZIndex = 5
acceptButton.Name = &quot;AcceptButton&quot;
acceptButton.Parent = popupFrame

local declineButton = acceptButton:clone()
declineButton.Position = UDim2.new(1,-120,0,270)
declineButton.Text = &quot;No&quot;
declineButton.Name = &quot;DeclineButton&quot;
declineButton.Parent = popupFrame

local popupImage = Instance.new(&quot;ImageLabel&quot;)
popupImage.BackgroundTransparency = 1
popupImage.Position = UDim2.new(0.5,-140,0,0)
popupImage.Size = UDim2.new(0,280,0,280)
popupImage.ZIndex = 3
popupImage.Name = &quot;PopupImage&quot;
popupImage.Parent = popupFrame

local backing = Instance.new(&quot;ImageLabel&quot;)
backing.BackgroundTransparency = 1
backing.Size = UDim2.new(1,0,1,0)
backing.Image = &quot;http://www.roblox.com/asset/?id=47574181&quot;
backing.Name = &quot;Backing&quot;
backing.ZIndex = 2
backing.Parent = popupImage

local popupText = Instance.new(&quot;TextLabel&quot;)
popupText.Name = &quot;PopupText&quot;
popupText.Size = UDim2.new(1,0,0.8,0)
popupText.Font = Enum.Font.ArialBold
popupText.FontSize = Enum.FontSize.Size36
popupText.BackgroundTransparency = 1
popupText.Text = &quot;Hello I&apos;m a popup&quot;
popupText.TextColor3 = Color3.new(248/255,248/255,248/255)
popupText.TextWrap = true
popupText.ZIndex = 5
popupText.Parent = popupFrame

script:remove()</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX31">
			<Properties>
				<string name="Name">Playerlist</string>
			</Properties>
			<Item class="LocalScript" referent="RBX32">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Init</string>
					<ProtectedString name="Source">--fixed by Carrot#0559
--for non corescript use
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;button.RobloxLocked = true
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end
&#9;

--rbxsig%bMgJMPt2chG7JIOhV0y5so/4dL1lRGiT3ELG0LsKh4QrqkG8sRdndraomuViGbDkVOWLXwIilzkhlSJSCjgZ9zXp6fS+SekW/n/RVWjNLA/gPThKLVxP6HmHRK9WTzIQ4ZTXjBmaExcdxBb1remqDPHWHlO2QoxZBqHs5sDGlQI=%
--rbxassetid%48488235%
local RbxGui

local ADMINS =
{
iagoMAO = &quot;rbxasset://textures/ui/admins/iagoMAO.png&quot;,
winsupermario1234 = &quot;rbxasset://textures/ui/admins/winsupermario1234.png&quot;,
Carrot = &quot;rbxasset://textures/ui/admins/carrot.png&quot;,
coke = &quot;rbxasset://textures/ui/admins/coke.png&quot;,
khanglegos = &quot;rbxasset://textures/ui/admins/khanglegos.png&quot;,
QuackIAttack = &quot;rbxasset://textures/ui/admins/QuackIAttack.png&quot;,
romulo27 = &quot;rbxasset://textures/ui/admins/romulo27.png&quot;,
TheLivingBee = &quot;rbxasset://textures/ui/admins/TheLivingBee.png&quot;,
OliverA = 1,
kinery = 1,
Peridorky =1,
Bitl = &quot;rbxasset://textures/ui/admins/bitl.png&quot;,
Raymonf = &quot;rbxasset://textures/ui/admins/Raymonf.png&quot;,
}

local localTesting = true

local screen = script.Parent
local screenResizeCon = nil

local friendWord = &quot;Friend&quot;
local friendWordLowercase = &quot;friend&quot;

local elementNames = {}
local elementNameToElement = {}

local privilegeOwner = 255
local privilegeAdmin = 240
local privilegeMember = 128
local privilegeVisitor = 10
local privilegeBanned = 0

local inContextMenu = false
local contextMenu3d = false

local bigEasingStyle = Enum.EasingStyle.Back
local smallEasingStyle = Enum.EasingStyle.Quart

local personalServerContextAdded = false
local personalServerPlace = false
local success = pcall(function() personalServerPlace = game.IsPersonalServer end)
if not success then
&#9;personalServerPlace = false
end

local friendRequestBlacklist = {}
local otherPlayerBlacklist = {}

local currentSortName = &quot;&quot;

local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local function waitForProperty(instance, prop)
&#9;while not instance[prop] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

local function Color3I(r,g,b)
  return Color3.new(r/255,g/255,b/255)
end

function robloxLock(instance)
end

function ArrayRemove(t, obj)
&#9;for i, obj2 in ipairs(t) do
&#9;&#9;if obj == obj2 then
&#9;&#9;&#9;table.remove(t, i)
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

local function getPlayers()
&#9;local result = {}
   local players = game:GetService(&quot;Players&quot;):GetChildren()
&#9;if players then
&#9;&#9;for i, player in ipairs(players) do
&#9;&#9;&#9;if player:IsA(&quot;Player&quot;) then 
&#9;&#9;&#9;&#9;table.insert(result, player)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return result
end

local brickColorTable = {}
for i = 0, 63 do
   brickColorTable[BrickColor.palette(i).Name] = BrickColor.palette(i).Color
end

local function remapColor(i, j)
  brickColorTable[BrickColor.palette(i).Name] = BrickColor.palette(j).Color
end

remapColor(13, 12)
remapColor(14, 12)
remapColor(15, 12)
remapColor(61, 29)
remapColor(63, 62)
remapColor(56, 50)
remapColor(45, 53)
remapColor(51, 20)
remapColor(4, 20)
remapColor(59, 35)
remapColor(60, 29)

local function getColor(brickColor)
  if brickColorTable[brickColor.Name] then
&#9;return brickColorTable[brickColor.Name] 
  else
    return brickColor.Color;
  end
end



local function getTeams()
&#9;local result = {}
&#9;local teams = game:GetService(&quot;Teams&quot;):GetChildren()
&#9;for i, team in ipairs(teams) do
&#9;&#9;if team:IsA(&quot;Team&quot;) then 
&#9;&#9;&#9;table.insert(result, team)
&#9;&#9;end
&#9;end
&#9;return result&#9;
end

local supportFriends = true
local currentBoardType = &quot;PlayerList&quot;
local currentStatCount = 0

local createBoardsFunction = nil


local playerTable = {}
local teamTable = {}
local teamColorTable&#9;= {}

local removePlayerFunction = nil
local recreatePlayerFunction = nil
local addPlayerFunction = function(player)
&#9;if recreatePlayerFunction then
&#9;&#9;recreatePlayerFunction(player)
&#9;end
end
local sortPlayerListsFunction = nil

local minimizedState = nil
local bigWindowImposter = nil
local smallWindowPosition = UDim2.new(0, -20, 0,5)
local smallWindowSize = UDim2.new(1,0,1,0)
local bigWindowSize = UDim2.new(0.6,0,0.6,0) 
local bigWindowPosition = UDim2.new(.2, 0, .2,0)

local smallWindowHeaderYSize = 32

local debounceTeamsChanged = false

local currentWindowState = &quot;Small&quot;
local previousWindowState = nil
local transitionWindowsFunction = nil

local container = nil
local topRightTrayContainer = nil

local playerContextMenu = nil
local contextMenuElements = {}
local updateContextMenuItems = nil

local function addContextMenuLabel(getText1, getText2, isVisible)
&#9;local t = {}
&#9;t.Type = &quot;Label&quot;
&#9;t.GetText1 = getText1
&#9;t.GetText2 = getText2
&#9;t.IsVisible = isVisible
&#9;table.insert(contextMenuElements, t)
end
local function addContextMenuButton(text, isVisible, isActive, doIt)
&#9;local t = {}
&#9;t.Text = text
&#9;t.Type = &quot;Button&quot;
&#9;t.IsVisible = isVisible
&#9;t.IsActive = isActive
&#9;t.DoIt = doIt
&#9;table.insert(contextMenuElements, t)
end

local function getFriendStatus(player)
&#9;if player == game.Players.LocalPlayer then
&#9;&#9;return Enum.FriendStatus.NotFriend
&#9;else
&#9;&#9;local success, result = pcall(function() return game.Players.LocalPlayer:GetFriendStatus(player) end)
&#9;&#9;if success then
&#9;&#9;&#9;return result
&#9;&#9;else
&#9;&#9;&#9;return Enum.FriendStatus.NotFriend
&#9;&#9;end
&#9;end
end


local function getPrivilegeType(player)
&#9;local rank = player.PersonalServerRank
&#9;if rank &gt;= privilegeOwner then
&#9;&#9;return privilegeOwner
&#9;elseif rank &lt; privilegeOwner and rank &gt;= privilegeAdmin then
&#9;&#9;return privilegeAdmin
&#9;elseif rank &lt; privilegeAdmin and rank &gt;= privilegeMember then
&#9;&#9;return privilegeMember
&#9;elseif rank &lt; privilegeMember and rank &gt;= privilegeVisitor then
&#9;&#9;return privilegeVisitor
&#9;else
&#9;&#9;return privilegeBanned
&#9;end
end

--Populate the ContextMenus
addContextMenuLabel(
&#9;--GetText1
&#9;function(player) 
&#9;&#9;return &quot;Loading...&quot;
&#9;end,
&#9;--GetText2
&#9;nil,
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return getFriendStatus(player) == Enum.FriendStatus.Unknown
&#9;end)

addContextMenuButton(&quot;Send &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) &#9;
&#9;&#9;return (not otherPlayerBlacklist[player]) and (getFriendStatus(player) == Enum.FriendStatus.NotFriend)
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt?
&#9;function(player) 
&#9;&#9;otherPlayerBlacklist[player] = true
&#9;&#9;return game.Players.LocalPlayer:RequestFriendship(player)
&#9;end
)
addContextMenuButton(&quot;Un&quot; .. friendWordLowercase, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return getFriendStatus(player) == Enum.FriendStatus.Friend
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player)
&#9;&#9;return game.Players.LocalPlayer:RevokeFriendship(player)
&#9;end
)
addContextMenuButton(&quot;Accept &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return (not friendRequestBlacklist[player]) and (getFriendStatus(player) == Enum.FriendStatus.FriendRequestReceived)
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player)
&#9;&#9;return game.Players.LocalPlayer:RequestFriendship(player)
&#9;end
)

addContextMenuButton(&quot;Deny &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return getFriendStatus(player) == Enum.FriendStatus.FriendRequestReceived
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player) 
&#9;&#9;friendRequestBlacklist[player] = true
&#9;&#9;return game.Players.LocalPlayer:RevokeFriendship(player)
&#9;end
)

addContextMenuButton(&quot;Cancel &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return false -- disable cancel request for now (can lead to griefing)
&#9;&#9;--return getFriendStatus(player) == Enum.FriendStatus.FriendRequestSent
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player) 
&#9;&#9;otherPlayerBlacklist[player] = false
&#9;&#9;return game.Players.LocalPlayer:RevokeFriendship(player)
&#9;end
)

function addPersonalServerContext()
&#9;if personalServerContextAdded then return end
&#9;personalServerContextAdded = true
&#9;addContextMenuButton(&quot;Ban&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin and (getPrivilegeType(player) &lt; privilegeAdmin) )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;player.PersonalServerRank = privilegeBanned
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Promote to Visitor&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin ) and ( getPrivilegeType(player) == privilegeBanned )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Promote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Promote to Member&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin ) and ( getPrivilegeType(player) == privilegeVisitor )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Promote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Promote to Admin&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) == privilegeOwner ) and ( getPrivilegeType(player) == privilegeMember )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Promote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Demote to Member&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) == privilegeOwner ) and ( getPrivilegeType(player) == privilegeAdmin )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Demote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Demote to Visitor&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin ) and ( getPrivilegeType(player) == privilegeMember )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Demote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
end

local function setupBuildToolManagement()
&#9;local buildToolManagerAssetId = 64164692
&#9;game:GetService(&quot;ScriptContext&quot;):AddCoreScript(buildToolManagerAssetId,game.Players.LocalPlayer,&quot;BuildToolManager&quot;)
end


local function getStatColumns(players)
&#9;for i, player in ipairs(players) do
&#9;&#9;local leaderstats = player:FindFirstChild(&quot;leaderstats&quot;)
&#9;&#9;if leaderstats then
&#9;&#9;&#9;local stats = {} 
&#9;&#9;&#9;local children = leaderstats:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, stat in ipairs(children) do
&#9;&#9;&#9;&#9;&#9;if stat:IsA(&quot;IntValue&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(stats, stat)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--TODO: This should check for IntValue only but current ScoreHud does not
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(stats, stat)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return stats
&#9;&#9;end&#9;&#9;
&#9;end
&#9;return nil
end

local function determineBoardType()
&#9;local players = getPlayers()
&#9;
&#9;local foundLeaderstats = false
&#9;local numStats = 0
&#9;local foundTeam = false

&#9;local stats = getStatColumns(players)
&#9;if stats then
&#9;&#9;foundLeaderstats = true
&#9;&#9;numStats = #stats
&#9;end

&#9;for i, player in ipairs(players) do
&#9;&#9;if not foundTeam then
&#9;&#9;&#9;if not player.Neutral then
&#9;&#9;&#9;&#9;foundTeam = true
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if foundLeaderstats and foundTeam then
&#9;&#9;return &quot;TeamScore&quot;, numStats
&#9;elseif foundLeaderstats then
&#9;&#9;return &quot;PlayerScore&quot;, numStats
&#9;elseif foundTeam then
&#9;&#9;return &quot;TeamList&quot;, numStats
&#9;else
&#9;&#9;return &quot;PlayerList&quot;, numStats
&#9;end
end

local function toggleBigWindow()
&#9;if container == nil then
&#9;&#9;return
&#9;end

&#9;if currentWindowState == &quot;Big&quot; then
&#9;&#9;--Hide it
&#9;&#9;if previousWindowState == nil or previousWindowState == &quot;Big&quot; or previousWindowState == &quot;None&quot; then
&#9;&#9;&#9;transitionWindowsFunction(&quot;None&quot;)
&#9;&#9;else
&#9;&#9;&#9;transitionWindowsFunction(&quot;Small&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;previousWindowState = currentWindowState
&#9;&#9;transitionWindowsFunction(&quot;Big&quot;)
&#9;end
end
local previousBigPlayerList = nil
local function rebuildBoard(owner, boardType, numStats)
&#9;if topRightTrayContainer == nil then
&#9;&#9;topRightTrayContainer = owner:FindFirstChild(&quot;PlayerListTopRightFrame&quot;)
&#9;&#9;if topRightTrayContainer == nil then
&#9;&#9;&#9;topRightTrayContainer = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;topRightTrayContainer.Name = &quot;PlayerListTopRightFrame&quot;
&#9;&#9;&#9;topRightTrayContainer.BackgroundTransparency = 1
&#9;&#9;&#9;topRightTrayContainer.Size = UDim2.new(0.2, 16, 0.42, 16)
&#9;&#9;&#9;topRightTrayContainer.Position = UDim2.new(0.8, 0, 0, 0)
&#9;&#9;&#9;topRightTrayContainer.Parent = container
&#9;&#9;end
&#9;end
&#9;if minimizedState == nil then
&#9;&#9;minimizedState = Instance.new(&quot;Frame&quot;)
&#9;&#9;minimizedState.Name = &quot;MinimizedPlayerlist&quot;
&#9;&#9;minimizedState.BackgroundTransparency = 1
&#9;&#9;minimizedState.Position = UDim2.new(1, -166, 0,0)
&#9;&#9;minimizedState.Size = UDim2.new(0, 151, 0, 30)
&#9;&#9;
&#9;&#9;playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;GoSmallButton&quot;
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_hidden_small.png&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 35, 0, 30)
&#9;&#9;playerListButton.Position = UDim2.new(1, -35, 0, 0)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;transitionWindowsFunction(&quot;Small&quot;)
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = minimizedState

&#9;&#9;minimizedState.Visible = false
&#9;&#9;robloxLock(minimizedState)
&#9;&#9;minimizedState.Parent = topRightTrayContainer
&#9;end
&#9;if bigWindowImposter == nil then
&#9;&#9;bigWindowImposter = owner:FindFirstChild(&quot;BigPlayerListWindowImposter&quot;)
&#9;&#9;if bigWindowImposter == nil then
&#9;&#9;&#9;bigWindowImposter = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;bigWindowImposter.Name = &quot;BigPlayerListWindowImposter&quot;
&#9;&#9;&#9;bigWindowImposter.Visible = false
&#9;&#9;&#9;bigWindowImposter.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;bigWindowImposter.BackgroundTransparency = 0.7
&#9;&#9;&#9;bigWindowImposter.BorderSizePixel = 0
&#9;&#9;&#9;bigWindowImposter.Size = UDim2.new(0.4, 7, 0.4, 7)
&#9;&#9;&#9;bigWindowImposter.Position = UDim2.new(0.3, 0, 0.3, 0)
&#9;&#9;&#9;robloxLock(bigWindowImposter)
&#9;&#9;&#9;bigWindowImposter.Parent = container
&#9;&#9;end
&#9;end
&#9;if container == nil or container ~= owner then
&#9;&#9;container = owner

&#9;&#9;topRightTrayContainer.Parent = container
&#9;&#9;bigWindowImposter.Parent = container
&#9;end

&#9;local smallVisible = true
&#9;local bigVisible = false
&#9;if container then
&#9;&#9;if topRightTrayContainer then
&#9;&#9;&#9;--Delete the old boards
&#9;&#9;&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;&#9;&#9;smallVisible = topRightTrayContainer.SmallPlayerlist.Visible
&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist.Parent = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;&#9;bigVisible = container.BigPlayerlist.Visible or (previousBigPlayerList ~= nil)
&#9;&#9;&#9;container.BigPlayerlist.Parent = nil
&#9;&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local smallBoard, bigBoard = createBoardsFunction(boardType, numStats)
&#9;if smallBoard then
&#9;&#9;smallBoard.Visible = smallVisible
&#9;&#9;smallBoard.Parent = topRightTrayContainer
&#9;&#9;recalculateSmallPlayerListSize(smallBoard)
&#9;end
&#9;if bigBoard then
&#9;&#9;if bigVisible then
&#9;&#9;&#9;previousBigPlayerList = bigBoard
&#9;&#9;&#9;local centerDialogSupported, msg = pcall(function() game.GuiService:AddCenterDialog(previousBigPlayerList, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = true
&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = false
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;&#9;bigBoard.Visible = bigVisible
&#9;&#9;else
&#9;&#9;&#9;bigBoard.Visible = false
&#9;&#9;end
&#9;&#9;bigBoard.Parent = container
&#9;end
&#9;return container
end

function recalculateSmallPlayerListSize(smallPlayerList)
&#9;waitForChild(smallPlayerList,&quot;ScrollingArea&quot;)
&#9;waitForChild(smallPlayerList.ScrollingArea, &quot;ScrollingFrame&quot;)
&#9;local scrollingFrame = smallPlayerList.ScrollingArea.ScrollingFrame
&#9;local playerLines = scrollingFrame:GetChildren()

&#9;local totalPlayerListSize = 0
&#9;for i = 1, #playerLines do
&#9;&#9;totalPlayerListSize = totalPlayerListSize + playerLines[i].AbsoluteSize.Y
&#9;end
&#9;
&#9;if not smallPlayerList.Parent then return end

&#9;local yOffset = math.max(0,(smallPlayerList.Size.Y.Scale * smallPlayerList.Parent.AbsoluteSize.Y) - totalPlayerListSize - smallWindowHeaderYSize)
&#9;smallPlayerList.Size = UDim2.new(smallPlayerList.Size.X.Scale,smallPlayerList.Size.X.Offset,smallPlayerList.Size.Y.Scale,-yOffset)
end


local function showBigPlayerWindow()
&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;if container.BigPlayerlist.Visible then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;
&#9;bigWindowImposter.Visible = true
&#9;bigWindowImposter:TweenSizeAndPosition(bigWindowSize, bigWindowPosition, Enum.EasingDirection.Out, bigEasingStyle, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then 
&#9;&#9;&#9;&#9;bigWindowImposter.Visible = false 
&#9;&#9;&#9;&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;&#9;&#9;&#9;container.BigPlayerlist.Visible = true
&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;end)
end

local function hideBigPlayerWindow(completed)
&#9;if playerContextMenu then
&#9;&#9;playerContextMenu.Visible = false
&#9;end
&#9;
&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;if container.BigPlayerlist.Visible == false and bigWindowImposter.Visible == false then
&#9;&#9;&#9;if completed then
&#9;&#9;&#9;&#9;completed()
&#9;&#9;&#9;end
&#9;&#9;&#9;--Already completely hidden
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;container.BigPlayerlist.Visible = false
&#9;end

&#9;local completedFunction = completed
&#9;bigWindowImposter.Visible = true
&#9;bigWindowImposter:TweenSizeAndPosition(UDim2.new(0.4, 0, 0.4, 0), UDim2.new(0.3, 0, 0.3, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quart, 0.15, true,
&#9;&#9;function(state) 
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then 
&#9;&#9;&#9;&#9;bigWindowImposter.Visible = false 
&#9;&#9;&#9;&#9;if completedFunction then
&#9;&#9;&#9;&#9;&#9;completedFunction()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end
local function hideSmallPlayerWindow(completed)
&#9;if playerContextMenu then
&#9;&#9;playerContextMenu.Visible = false
&#9;end
&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;local completedFunction = completed
&#9;&#9;if topRightTrayContainer.SmallPlayerlist.Visible then
&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist:TweenPosition(UDim2.new(1,0,smallWindowPosition.Y.Scale, smallWindowPosition.Y.Offset), Enum.EasingDirection.Out, smallEasingStyle, 0.3, true, 
&#9;&#9;&#9;&#9;function(state) 
&#9;&#9;&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then 
&#9;&#9;&#9;&#9;&#9;&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if completedFunction then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;completedFunction()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if completed then
&#9;&#9;completed()
&#9;end
end


transitionWindowsFunction = function(desiredState)
&#9;if desiredState == &quot;Big&quot; then
&#9;&#9;minimizedState.Visible = false
&#9;&#9;hideSmallPlayerWindow()
&#9;
&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;if previousBigPlayerList ~= container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;&#9;&#9;previousBigPlayerList = container:FindFirstChild(&quot;BigPlayerlist&quot;)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;previousBigPlayerList = container:FindFirstChild(&quot;BigPlayerlist&quot;)
&#9;&#9;end

&#9;&#9;if previousBigPlayerList then
&#9;&#9;&#9;local firstShow = false
&#9;&#9;&#9;local centerDialogSupported, msg = pcall(function() game.GuiService:AddCenterDialog(previousBigPlayerList, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;if not firstShow then
&#9;&#9;&#9;&#9;&#9;&#9;showBigPlayerWindow()
&#9;&#9;&#9;&#9;&#9;&#9;firstShow = true
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;if previousBigPlayerList then
&#9;&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;&#9;if centerDialogSupported == false then
&#9;&#9;&#9;&#9;print(&quot;Exception&quot;, msg)
&#9;&#9;&#9;&#9;showBigPlayerWindow()
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;showBigPlayerWindow()
&#9;&#9;end
&#9;&#9;currentWindowState = &quot;Big&quot;
&#9;elseif desiredState == &quot;Small&quot; then
&#9;&#9;minimizedState.Visible = false
&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;end
&#9;&#9;
&#9;&#9;hideBigPlayerWindow()
&#9;&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;&#9;if not topRightTrayContainer.SmallPlayerlist.Visible or topRightTrayContainer.SmallPlayerlist.Position ~= smallWindowPosition then
&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist.Visible = true
&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist:TweenPosition(smallWindowPosition, Enum.EasingDirection.Out, smallEasingStyle, 0.3, true)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;currentWindowState = &quot;Small&quot;
&#9;elseif desiredState == &quot;None&quot; then
&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;end
&#9;&#9;
&#9;&#9;local smallDone = false
&#9;&#9;local bigDone = false
&#9;&#9;hideSmallPlayerWindow(
&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;smallDone = true 
&#9;&#9;&#9;&#9;if bigDone and smallDone then
&#9;&#9;&#9;&#9;&#9;minimizedState.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;hideBigPlayerWindow(&#9;&#9;&#9;
&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;bigDone = true 
&#9;&#9;&#9;&#9;if bigDone and smallDone then
&#9;&#9;&#9;&#9;&#9;minimizedState.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)&#9;&#9;
&#9;&#9;currentWindowState = &quot;None&quot;
&#9;end
end

local function getStatValuesForPlayer(player)
&#9;local leaderstats = player:FindFirstChild(&quot;leaderstats&quot;)
&#9;if leaderstats then
&#9;&#9;local children = leaderstats:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;local result = {}
&#9;&#9;&#9;--Just go based on position
&#9;&#9;&#9;for i, stat in ipairs(children) do
&#9;&#9;&#9;&#9;if stat:IsA(&quot;IntValue&quot;) then
&#9;&#9;&#9;&#9;&#9;table.insert(result, stat)
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;table.insert(result, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;return result, leaderstats
&#9;&#9;end
&#9;end
&#9;return nil
end

--ChildAdded on Player (if it&apos;s name is &quot;leaderstats&quot;)

if UserSettings and LoadLibrary then

&#9;RbxGui,msg = t

&#9;local function createTeamName(name, color)
&#9;&#9;local fontHeight = 20
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Team-&quot; .. name
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;frame.BackgroundTransparency = 0.5
&#9;&#9;frame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;frame.Size = UDim2.new(1, 0, 0, fontHeight)
&#9;&#9;frame.Position = UDim2.new(0,0,0,0)

&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;label.Name = &quot;NameLabel&quot;
&#9;&#9;label.Text = &quot; &quot; .. name
&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;label.FontSize = Enum.FontSize.Size18
&#9;&#9;label.Position = UDim2.new(0,0,0,0)
&#9;&#9;label.Size = UDim2.new(1,0,1,0)
&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;label.BackgroundTransparency = 0.5
&#9;&#9;label.BackgroundColor3 = getColor(color)
&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;local changeFunc = nil
&#9;&#9;label, changeFunc = RbxGui.AutoTruncateTextObject(label)
&#9;&#9;label.Parent = frame
&#9;&#9;
&#9;&#9;return frame, changeFunc
&#9;end

&#9;local function getFriendStatusIcon(friendStatus)
&#9;&#9;if friendStatus == Enum.FriendStatus.Unknown or friendStatus == Enum.FriendStatus.NotFriend then
&#9;&#9;&#9;return nil
&#9;&#9;elseif friendStatus == Enum.FriendStatus.Friend then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/PlayerlistFriendIcon.png&quot;
&#9;&#9;elseif friendStatus == Enum.FriendStatus.FriendRequestSent then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/PlayerlistFriendRequestSentIcon.png&quot;
&#9;&#9;elseif friendStatus == Enum.FriendStatus.FriendRequestReceived then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/PlayerlistFriendRequestReceivedIcon.png&quot;
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FriendStatus: &quot; .. friendStatus)
&#9;&#9;end
&#9;end

&#9;function getMembershipTypeIcon(membershipType,playerName)
&#9;if ADMINS[playerName]~=nil then
&#9;&#9;if ADMINS[playerName] == 1 then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/admins/default.png&quot;
&#9;&#9;else
&#9;&#9;&#9;return ADMINS[playerName]
&#9;&#9;end
&#9;elseif membershipType == Enum.MembershipType.None then
&#9;&#9;return &quot;&quot;
&#9;elseif membershipType == Enum.MembershipType.BuildersClub then
&#9;&#9;return &quot;rbxasset://textures/ui/TinyBcIcon.png&quot;
&#9;elseif membershipType == Enum.MembershipType.TurboBuildersClub then
&#9;&#9;return &quot;rbxasset://textures/ui/TinyTbcIcon.png&quot;
&#9;elseif membershipType == Enum.MembershipType.OutrageousBuildersClub then
&#9;&#9;return &quot;rbxasset://textures/ui/TinyObcIcon.png&quot;
&#9;else
&#9;&#9;error(&quot;Unknown membershipType&quot; .. membershipType)
&#9;end&#9;
end





&#9;local function updatePlayerFriendStatus(nameObject, friendStatus)
&#9;&#9;local fontHeight = 20

&#9;&#9;local friendIconImage = getFriendStatusIcon(friendStatus)
&#9;&#9;nameObject.MembershipTypeLabel.FriendStatusLabel.Visible = (friendIconImage ~= nil)

&#9;&#9;if friendIconImage ~= nil then 
&#9;&#9;&#9;--Show friend icon
&#9;&#9;&#9;nameObject.MembershipTypeLabel.FriendStatusLabel.Image = friendIconImage
&#9;&#9;&#9;nameObject.NameLabel.Position =UDim2.new(0,2*fontHeight,0,1)
&#9;&#9;&#9;nameObject.NameLabel.Size = UDim2.new(1,-2*fontHeight,1,-2)
&#9;&#9;else
&#9;&#9;&#9;--Hide the friend icon
&#9;&#9;&#9;nameObject.NameLabel.Position = UDim2.new(0,fontHeight+1,0,1)
&#9;&#9;&#9;nameObject.NameLabel.Size = UDim2.new(1,-(fontHeight+1),1,-2)
&#9;&#9;end
&#9;end
&#9;local function updatePlayerName(nameObject, membershipStatus, teamColor)
&#9;&#9;local fontHeight = 20

      local membershipType = membershipStatus
      local playerName = nameObject.NameLabel.Text

&#9;&#9;nameObject.Size = UDim2.new(1,0,0,fontHeight)
      nameObject.MembershipTypeLabel.Image = getMembershipTypeIcon(membershipType, playerName)
&#9;end

&#9;
&#9;local function updatePlayerNameColor(player, teamColor)
&#9;&#9;local function updatePlayerNameColorHelper(nameObject)
&#9;&#9;&#9;if teamColor ~= nil then
&#9;&#9;&#9;&#9;nameObject.NameLabel.TextColor3 = getColor(teamColor)
&#9;&#9;&#9;&#9;nameObject.NameLabel.FullNameLabel.TextColor3 = getColor(teamColor)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;nameObject.NameLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;nameObject.NameLabel.FullNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;updatePlayerNameColorHelper(playerTable[player].NameObjectSmall)
&#9;&#9;updatePlayerNameColorHelper(playerTable[player].NameObjectBig)
&#9;end


&#9;local function createPlayerName(name, membershipStatus, teamColor, friendStatus)
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Player_&quot; .. name
&#9;&#9;frame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;frame.BackgroundTransparency = 0.5
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;
&#9;&#9;local membershipStatusLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;membershipStatusLabel.Name = &quot;MembershipTypeLabel&quot;
&#9;&#9;membershipStatusLabel.BackgroundTransparency = 1
&#9;&#9;membershipStatusLabel.Size = UDim2.new(0,18,0,18)
&#9;&#9;membershipStatusLabel.Position = UDim2.new(0,0,0,0)
&#9;&#9;membershipStatusLabel.SizeConstraint = Enum.SizeConstraint.RelativeYY
&#9;&#9;membershipStatusLabel.Parent = frame

&#9;&#9;local friendStatusLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;friendStatusLabel.Name = &quot;FriendStatusLabel&quot;
&#9;&#9;friendStatusLabel.Visible = false
&#9;&#9;friendStatusLabel.BackgroundTransparency = 1
&#9;&#9;friendStatusLabel.Size = UDim2.new(1,0,1,0)
&#9;&#9;friendStatusLabel.Position = UDim2.new(1,0,0,0)
&#9;&#9;friendStatusLabel.Parent = membershipStatusLabel

&#9;&#9;local changeNameFunction
&#9;&#9;local nameLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;nameLabel.Name = &quot;NameLabel&quot;
&#9;&#9;nameLabel.Text = name
&#9;&#9;nameLabel.Font = Enum.Font.ArialBold
&#9;&#9;nameLabel.FontSize = Enum.FontSize.Size14
&#9;&#9;nameLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;nameLabel.BackgroundTransparency = 1
&#9;&#9;nameLabel.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;nameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;nameLabel, changeNameFunction = RbxGui.AutoTruncateTextObject(nameLabel)
&#9;&#9;nameLabel.Parent = frame
&#9;&#9;
&#9;&#9;updatePlayerName(frame, membershipStatus, teamColor)
&#9;&#9;if supportFriends and not friendRequestBlacklist[game.Players:FindFirstChild(name)] then
&#9;&#9;&#9;updatePlayerFriendStatus(frame, friendStatus)
&#9;&#9;else
&#9;&#9;&#9;updatePlayerFriendStatus(frame, Enum.FriendStatus.NotFriend)
&#9;&#9;end
&#9;&#9;return frame, changeNameFunction
&#9;end

&#9;local function createStatColumn(i, numColumns, isTeam, color3, isHeader, stat)
&#9;&#9;local textLabel = Instance.new(&quot;TextButton&quot;)
&#9;&#9;textLabel.Name = &quot;Stat&quot; .. i
&#9;&#9;textLabel.AutoButtonColor = false
&#9;&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;&#9;
&#9;&#9;if isHeader then
&#9;&#9;&#9;textLabel.FontSize = Enum.FontSize.Size18
&#9;&#9;else
&#9;&#9;&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;&#9;end
&#9;&#9;if isHeader or isTeam then
&#9;&#9;&#9;textLabel.Font = Enum.Font.ArialBold
&#9;&#9;else 
&#9;&#9;&#9;textLabel.Font = Enum.Font.Arial
&#9;&#9;end

&#9;&#9;if isTeam then
&#9;&#9;&#9;textLabel.BackgroundColor3 = color3
&#9;&#9;&#9;textLabel.Text = 0
&#9;&#9;else
&#9;&#9;&#9;textLabel.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;textLabel.Text = &quot;&quot;
&#9;&#9;end
&#9;&#9;textLabel.BackgroundTransparency = 1
&#9;&#9;if i == numColumns then
&#9;&#9;&#9;textLabel.Size = UDim2.new(1/numColumns, -6, 1, 0)
&#9;&#9;else
&#9;&#9;&#9;textLabel.Size = UDim2.new(1/numColumns, -4, 1, 0)
&#9;&#9;end
&#9;&#9;
&#9;&#9;textLabel.Position = UDim2.new((i-1) * (1/numColumns), 0, 0, 0)
&#9;&#9;
&#9;&#9;local truncLabel, changer = RbxGui.AutoTruncateTextObject(textLabel)
&#9;&#9;
&#9;&#9;if isHeader then
&#9;&#9;&#9;local mouseCon = {}
&#9;
&#9;&#9;&#9;mouseCon[1] = truncLabel.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 0.2
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseCon[2] = truncLabel.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 1
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;mouseCon[3] = truncLabel.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;sortPlayerListsFunction(truncLabel:GetChildren()[1].Name, (currentSortName == truncLabel:GetChildren()[1].Name) )
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 1
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;mouseCon[4] = truncLabel:GetChildren()[1].MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;sortPlayerListsFunction(textLabel.Name, (currentSortName == truncLabel.Name) )
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 1
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;mouseCon[5] = nil
&#9;&#9;&#9;mouseCon[5] = truncLabel.AncestryChanged:connect(function(child,parent)
&#9;&#9;&#9;&#9;if parent == nil then
&#9;&#9;&#9;&#9;&#9;for i,connection in pairs(mouseCon) do
&#9;&#9;&#9;&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;return truncLabel, changer
&#9;end

&#9;local function createStatHeaders(stats, numColumns, isBig)
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Headers&quot;
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;
&#9;&#9;local nameSize
&#9;&#9;if isBig then
&#9;&#9;&#9;nameSize = 0.5
&#9;&#9;elseif numColumns == 1 then
&#9;&#9;&#9;nameSize = 0.7
&#9;&#9;elseif numColumns == 2 then
&#9;&#9;&#9;nameSize = 0.6
&#9;&#9;else
&#9;&#9;&#9;nameSize = 0.45
&#9;&#9;end
&#9;&#9;frame.Size = UDim2.new(1-nameSize, 0, 1,0)
&#9;&#9;if isBig then
&#9;&#9;&#9;frame.Position = UDim2.new(nameSize,-25, 0,0)
&#9;&#9;else
&#9;&#9;&#9;frame.Position = UDim2.new(nameSize,0, 0,0)
&#9;&#9;end

&#9;&#9;local i = 1
&#9;&#9;while i &lt;= numColumns do
&#9;&#9;&#9;local headerColumn, changeText = createStatColumn(i, numColumns, false, nil, true,stats[i])
&#9;&#9;&#9;changeText(stats[i].Name)
&#9;&#9;&#9;headerColumn.Parent = frame
&#9;&#9;&#9;i = i + 1
&#9;&#9;end&#9;&#9;
&#9;&#9;return frame, textChangers
&#9;end

&#9;local function createStatColumns(nameObject, numColumns, isTeam, isBig) 
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = nameObject.Name .. &quot;_WithStats&quot;
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;frame.BackgroundColor3 = nameObject.BackgroundColor3
&#9;&#9;frame.BackgroundTransparency = nameObject.BackgroundTransparency
&#9;&#9;frame.Size = nameObject.Size
&#9;&#9;frame.Position = nameObject.Position

&#9;&#9;nameObject.BackgroundTransparency = 1

&#9;&#9;if numColumns == 0 then
&#9;&#9;&#9;nameObject.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;nameObject.Position = UDim2.new(0,0,0,0)
&#9;&#9;&#9;nameObject.Parent = frame
&#9;&#9;&#9;return frame
&#9;&#9;end

&#9;&#9;local statFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;statFrame.Name = &quot;Stats&quot;
&#9;&#9;if isTeam then
&#9;&#9;&#9;statFrame.BorderSizePixel = 0
&#9;&#9;&#9;statFrame.BackgroundColor3 = nameObject.NameLabel.BackgroundColor3
&#9;&#9;&#9;statFrame.BackgroundTransparency = nameObject.NameLabel.BackgroundTransparency
&#9;&#9;else
&#9;&#9;&#9;statFrame.BackgroundTransparency = 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;local nameSize
&#9;&#9;if isBig then
&#9;&#9;&#9;nameSize = 0.5
&#9;&#9;elseif numColumns == 1 then
&#9;&#9;&#9;nameSize = 0.7
&#9;&#9;elseif numColumns == 2 then
&#9;&#9;&#9;nameSize = 0.6
&#9;&#9;else
&#9;&#9;&#9;nameSize = 0.45
&#9;&#9;end
&#9;&#9;nameObject.Size = UDim2.new(nameSize, 0, 1, 0)
&#9;&#9;nameObject.Position = UDim2.new(0, 0, 0, 0)
&#9;&#9;statFrame.Size = UDim2.new(1-nameSize,0, 1,0)
&#9;&#9;statFrame.Position = UDim2.new(nameSize,0, 0,0)

&#9;&#9;nameObject.Parent = frame
&#9;&#9;statFrame.Parent = frame
&#9;&#9;
&#9;&#9;local textChangers = {}
&#9;&#9;local i = 1
&#9;&#9;while i &lt;= numColumns do
&#9;&#9;&#9;local statColumn, changeText = createStatColumn(i, numColumns, isTeam, statFrame.BackgroundColor3)
&#9;&#9;&#9;statColumn.Parent = statFrame
&#9;&#9;&#9;table.insert(textChangers, changeText)

&#9;&#9;&#9;i = i + 1
&#9;&#9;end&#9;&#9;
&#9;&#9;
&#9;&#9;return frame, statFrame, textChangers
&#9;end

&#9;local function createAlternatingRows(objects)
&#9;&#9;for i, line in ipairs(objects) do
&#9;&#9;&#9;if i % 2 == 0 then
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.95
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local removeFromTeam = nil

&#9;local function clearTableEntry(obj, tableInfo)
&#9;&#9;if tableInfo.MainObjectSmall then
&#9;&#9;&#9;tableInfo.MainObjectSmall.Parent = nil
&#9;&#9;&#9;tableInfo.MainObjectSmall = nil
&#9;&#9;end
&#9;&#9;if tableInfo.MainObjectBig then
&#9;&#9;&#9;tableInfo.MainObjectBig.Parent = nil
&#9;&#9;&#9;tableInfo.MainObjectBig = nil
&#9;&#9;end
&#9;&#9;if tableInfo.Connections then
&#9;&#9;&#9;for i, connection in ipairs(tableInfo.Connections) do
&#9;&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;end
&#9;&#9;&#9;tableInfo.Connections = nil
&#9;&#9;end
&#9;&#9;if tableInfo.LeaderStatConnections then
&#9;&#9;&#9;for i, connection in ipairs(tableInfo.LeaderStatConnections) do
&#9;&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;end
&#9;&#9;&#9;tableInfo.LeaderStatConnections = nil
&#9;&#9;end
&#9;&#9;if tableInfo.CurrentTeam then
&#9;&#9;&#9;removeFromTeam(obj)
&#9;&#9;&#9;tableInfo.CurrentTeam = nil
&#9;&#9;end
&#9;&#9;if tableInfo.Players then
&#9;&#9;&#9;for i, player in ipairs(tableInfo.Players) do
&#9;&#9;&#9;&#9;playerTable[player].CurrentTeam = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;tableInfo.Players = {}
&#9;&#9;end
&#9;&#9;if tableInfo.StatValues then
&#9;&#9;&#9;tableInfo.StatValues = nil
&#9;&#9;end
&#9;end
&#9;
&#9;local function resetPlayerTable()
&#9;&#9;for player, info in pairs(playerTable) do
&#9;&#9;&#9;clearTableEntry(player, info)
&#9;&#9;&#9;playerTable[player] = nil
&#9;&#9;end
&#9;&#9;playerTable = {}
&#9;end

&#9;local function resetTeamTable()
&#9;&#9;for team, info in pairs(teamTable) do
&#9;&#9;&#9;clearTableEntry(team, info)
&#9;&#9;&#9;teamTable[team] = nil
&#9;&#9;end
&#9;&#9;teamTable = {}
&#9;&#9;teamColorTable = {}
&#9;end

&#9;local function getBoardTypeInfo()
&#9;&#9;local isTeam  = (currentBoardType == &quot;TeamScore&quot; or currentBoardType == &quot;TeamList&quot;)
&#9;&#9;local isScore = (currentBoardType == &quot;TeamScore&quot; or currentBoardType == &quot;PlayerScore&quot;)
&#9;&#9;return isTeam, isScore
&#9;end


&#9;local function recomputeTeamScore(team, column)
&#9;&#9;if not team or team == &quot;Neutral&quot; then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function recomputeScoreHelper(statChangers)
&#9;&#9;&#9;if statChangers and column &lt;= #statChangers then
&#9;&#9;&#9;&#9;local sum = 0
&#9;&#9;&#9;&#9;for i, p in ipairs(teamTable[team].Players) do
&#9;&#9;&#9;&#9;&#9;if playerTable[p].StatValues and column &lt;= #playerTable[p].StatValues then
&#9;&#9;&#9;&#9;&#9;&#9;sum = sum + playerTable[p].StatValues[column].Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;statChangers[column](sum)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;recomputeScoreHelper(teamTable[team].StatChangersSmall)
&#9;&#9;recomputeScoreHelper(teamTable[team].StatChangersBig)
&#9;end
&#9;local function recomputeCompleteTeamScore(team)
&#9;&#9;local col = 1
&#9;&#9;while col &lt;= currentStatCount do
&#9;&#9;&#9;recomputeTeamScore(team, col)
&#9;&#9;&#9;col = col + 1
&#9;&#9;end
&#9;end
&#9;removeFromTeam = function(player)
&#9;&#9;if playerTable[player].CurrentTeam ~= nil and teamTable[playerTable[player].CurrentTeam] ~= nil then
&#9;&#9;&#9;ArrayRemove(teamTable[playerTable[player].CurrentTeam].Players, player)
&#9;&#9;&#9;recomputeCompleteTeamScore(playerTable[player].CurrentTeam)
&#9;&#9;&#9;playerTable[player].CurrentTeam = nil
&#9;&#9;end
&#9;end

&#9;local function assignToTeam(player)
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()

&#9;&#9;if isTeam then
&#9;&#9;&#9;local newTeam = nil

&#9;&#9;&#9;if player.Neutral or teamColorTable[player.TeamColor.Name] == nil then
&#9;&#9;&#9;&#9;newTeam = &quot;Neutral&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;newTeam = teamColorTable[player.TeamColor.Name] 
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;&#9;if playerTable[player].CurrentTeam == newTeam then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local oldTeam = playerTable[player].LastTeam
&#9;&#9;&#9;removeFromTeam(player)

&#9;&#9;&#9;playerTable[player].CurrentTeam = newTeam
&#9;&#9;&#9;
&#9;&#9;&#9;if teamTable[oldTeam] and teamTable[oldTeam][&quot;NameChangeFuncBig&quot;] then
&#9;&#9;&#9;&#9;if #teamTable[oldTeam].Players &lt; 1 then 
&#9;&#9;&#9;&#9;&#9;teamTable[oldTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. oldTeam.Name)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;teamTable[oldTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. oldTeam.Name .. &quot;  (&quot; .. tostring(#teamTable[oldTeam].Players) ..&quot;)&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if teamTable[newTeam] then
&#9;&#9;&#9;&#9;table.insert(teamTable[newTeam].Players, player)
&#9;&#9;&#9;&#9;if newTeam[&quot;Name&quot;] then
&#9;&#9;&#9;&#9;&#9;if teamTable[newTeam][&quot;NameChangeFuncBig&quot;] then
&#9;&#9;&#9;&#9;&#9;&#9;if #teamTable[newTeam].Players &lt; 1 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamTable[newTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. newTeam.Name)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamTable[newTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. newTeam.Name .. &quot;  (&quot; .. tostring(#teamTable[newTeam].Players) ..&quot;)&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;if newTeam == &quot;Neutral&quot; then
&#9;&#9;&#9;&#9;updatePlayerNameColor(player, nil)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;updatePlayerNameColor(player, player.TeamColor)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;playerTable[player].LastTeam = newTeam
&#9;&#9;&#9;
&#9;&#9;&#9;recomputeCompleteTeamScore(newTeam)
&#9;&#9;&#9;
&#9;&#9;&#9;--Relayout
&#9;&#9;&#9;if sortPlayerListsFunction then
&#9;&#9;&#9;&#9;sortPlayerListsFunction()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function buildTeamObject(team, numStatColumns, suffix)
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;local teamObject, changeFunc = createTeamName(team.Name, team.TeamColor)
&#9;&#9;teamObject.NameLabel.Text = &quot; &quot; .. team.Name .. &quot; (0)&quot;
&#9;&#9;if not teamTable[team] then
&#9;&#9;&#9;teamTable[team] = {} 
&#9;&#9;end
&#9;&#9;teamTable[team][&quot;NameObject&quot; .. suffix] = teamObject
&#9;&#9;teamTable[team][&quot;NameChangeFunc&quot; .. suffix] = changeFunc
&#9;&#9;if isScore then
&#9;&#9;&#9;local statObject
&#9;&#9;&#9;local textChangers
&#9;&#9;&#9;teamObject, statObject, textChangers = createStatColumns(teamObject, numStatColumns, true, suffix == &quot;Big&quot;)
&#9;&#9;&#9;teamTable[team][&quot;StatObject&quot; .. suffix] = statObject
&#9;&#9;&#9;teamTable[team][&quot;StatChangers&quot; .. suffix] = textChangers
&#9;&#9;end
&#9;&#9;teamTable[team][&quot;MainObject&quot; .. suffix] = teamObject
&#9;&#9;changeFunc(&quot; &quot; .. team.Name)
&#9;&#9;if not teamTable[team].Players then
&#9;&#9;&#9;teamTable[team].Players = {}
&#9;&#9;else
&#9;&#9;&#9;if suffix ~= &quot;Small&quot; and #teamTable[team].Players &gt; 0 then 
&#9;&#9;&#9;&#9;changeFunc(&quot; &quot; .. team.Name .. &quot;  (&quot; .. tostring(#teamTable[team].Players) ..&quot;)&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return teamObject
&#9;end
&#9;
&#9;local currentContextMenuPlayer = nil
&#9;local function updatePlayerContextMenu(player,x,y)
&#9;&#9;currentContextMenuPlayer = player
&#9;&#9;local elementHeight = 18
&#9;&#9;local function highlight(button)
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
&#9;&#9;end
&#9;&#9;local function clearHighlight(button)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;end
&#9;&#9;if playerContextMenu == nil then
&#9;&#9;&#9;elementNames = {}
&#9;&#9;&#9;elementNameToElement = {}
&#9;&#9;&#9;
&#9;&#9;&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;&#9;&#9;table.insert(elementNames, contextElement.Text)
&#9;&#9;&#9;&#9;elementNameToElement[tostring(contextElement.Text)] = contextElement
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;playerContextMenu = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;playerContextMenu.Name = &quot;PlayerListContextMenu&quot;
&#9;&#9;&#9;playerContextMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;&#9;playerContextMenu.Text = &quot;&quot;
&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;playerContextMenu.ZIndex = 4
&#9;&#9;&#9;
&#9;&#9;&#9;playerContextMenu.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;local menuChildren = playerContextMenu:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #menuChildren do
&#9;&#9;&#9;&#9;&#9;if menuChildren[i].Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;menuChildren[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;&#9;menuChildren[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;&#9;inContextMenu = false
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;playerContextMenu.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;inContextMenu = true
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;for i = 1, #elementNames do
&#9;&#9;&#9;&#9;local newElementButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;&#9;newElementButton.Name = &quot;ChoiceButton&quot;
&#9;&#9;&#9;&#9;newElementButton.Text = elementNames[i]
&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;newElementButton.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;newElementButton.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;newElementButton.TextWrap = true
&#9;&#9;&#9;&#9;newElementButton.Size = UDim2.new(1,0,0,elementHeight)
&#9;&#9;&#9;&#9;newElementButton.Position = UDim2.new(0,0,0,elementHeight * (i - 1))
&#9;&#9;&#9;&#9;newElementButton.ZIndex = playerContextMenu.ZIndex + 1
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;local element = elementNameToElement[newElementButton.Text]
&#9;&#9;&#9;&#9;&#9;pcall(function() element.DoIt(currentContextMenuPlayer) end)
&#9;&#9;&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.Parent = playerContextMenu
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;robloxLock(playerContextMenu)
&#9;&#9;&#9;playerContextMenu.Parent = script.Parent
&#9;&#9;&#9;
&#9;&#9;end
&#9;&#9;
&#9;&#9;local visibleElements = 0
&#9;&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;&#9;local isVisible = false

&#9;&#9;&#9;if contextElement.IsVisible then
&#9;&#9;&#9;&#9;local success, visible = pcall(function() return contextElement.IsVisible(currentContextMenuPlayer) end)
&#9;&#9;&#9;&#9;if success then 
&#9;&#9;&#9;&#9;&#9;isVisible = visible
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;Error in IsVisible call: &quot; .. visible)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;
&#9;&#9;&#9;if isVisible then
&#9;&#9;&#9;&#9;local foundElement = false
&#9;&#9;&#9;&#9;for i = 1, #elementNames do
&#9;&#9;&#9;&#9;&#9;if elementNames[i] == contextElement.Text then 
&#9;&#9;&#9;&#9;&#9;&#9;foundElement = true
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not foundElement then
&#9;&#9;&#9;&#9;&#9;table.insert(elementNames,contextElement.Text)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;visibleElements = visibleElements + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;for i = 1, #elementNames do
&#9;&#9;&#9;&#9;&#9;if elementNames[i] == contextElement.Text then 
&#9;&#9;&#9;&#9;&#9;&#9;table.remove(elementNames,i)
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;playerContextMenu.Size = UDim2.new(0, 150, 0, elementHeight + (elementHeight * visibleElements) )
&#9;&#9;
&#9;&#9;if x and y then
&#9;&#9;&#9;x = x - (playerContextMenu.AbsoluteSize.X/2)
&#9;&#9;&#9;if x + playerContextMenu.AbsoluteSize.X &gt;= script.Parent.AbsoluteSize.X then
&#9;&#9;&#9;&#9;x = script.Parent.AbsoluteSize.X - playerContextMenu.AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;playerContextMenu.Position = UDim2.new(0, x, 0, y - 3)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local elementPos = 0
&#9;&#9;local contextChildren = playerContextMenu:GetChildren()
&#9;&#9;for i = 1, #contextChildren do
&#9;&#9;&#9;if contextChildren[i]:IsA(&quot;GuiObject&quot;) and contextChildren[i].Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;contextChildren[i].Visible = false
&#9;&#9;&#9;&#9;for j = 1, #elementNames do
&#9;&#9;&#9;&#9;&#9;if elementNames[j] == contextChildren[i].Text then
&#9;&#9;&#9;&#9;&#9;&#9;contextChildren[i].Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;contextChildren[i].Position = UDim2.new(0,0,0,elementPos * elementHeight)
&#9;&#9;&#9;&#9;&#9;&#9;elementPos = elementPos + 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function playerContextMenuHasItems()
&#9;&#9;if playerContextMenu then
&#9;&#9;&#9;local children = playerContextMenu:GetChildren()
&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) and children[i].Name == &quot;ChoiceButton&quot; and children[i].Visible then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;local function showPlayerMenu(player, x, y)
&#9;&#9;updatePlayerContextMenu(player,x,y)
&#9;&#9;if not playerContextMenuHasItems() then return end -- don&apos;t show if we have nothing to show
&#9;&#9;playerContextMenu.Visible = true
&#9;end

&#9;local function buildPlayerObject(player, numStatColumns, suffix)
&#9;&#9;if not player then return nil end
&#9;&#9;
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()

&#9;&#9;local playerObject = nil
&#9;&#9;local changePlayerNameFunction = nil
&#9;&#9;local currentColor = nil
&#9;&#9;if isTeam and not player.Neutral then
&#9;&#9;&#9;currentColor = player.TeamColor.Color
&#9;&#9;else
&#9;&#9;&#9;currentColor = Color3.new(1,1,1)
&#9;&#9;end
&#9;&#9;&#9;playerObject, changePlayerNameFunction = createPlayerName(player.Name, player.MembershipType, currentColor, getFriendStatus(player))
&#9;&#9;
&#9;&#9;if not playerTable[player] then
&#9;&#9;&#9;playerTable[player] = {}
&#9;&#9;end
&#9;&#9;if not playerTable[player].Connections then
&#9;&#9;&#9;playerTable[player].Connections = {}
&#9;&#9;end
&#9;&#9;if not playerTable[player].CurrentTeam then
&#9;&#9;&#9;playerTable[player].CurrentTeam = nil
&#9;&#9;end
&#9;&#9;if not playerTable[player].LastTeam then
&#9;&#9;&#9;playerTable[player].LastTeam = nil
&#9;&#9;end
&#9;&#9;playerTable[player][&quot;NameObject&quot; .. suffix] = playerObject
&#9;&#9;playerTable[player][&quot;ChangeName&quot; .. suffix] = changePlayerNameFunction

&#9;&#9;if isScore then
&#9;&#9;&#9;local statObject = nil
&#9;&#9;&#9;local textChangers = nil
&#9;&#9;&#9;playerObject, statObject, textChangers = createStatColumns(playerObject, numStatColumns, false, suffix == &quot;Big&quot;)
&#9;&#9;&#9;playerTable[player][&quot;StatObject&quot; .. suffix]= statObject
&#9;&#9;&#9;playerTable[player][&quot;StatChangers&quot; .. suffix] = textChangers
&#9;&#9;&#9;
&#9;&#9;&#9;local statValues, leaderstats = getStatValuesForPlayer(player)
&#9;&#9;&#9;if not statValues or #statValues &lt; numStatColumns then
&#9;&#9;&#9;&#9;if not playerTable[player].LeaderStatConnections then
&#9;&#9;&#9;&#9;&#9;playerTable[player].LeaderStatConnections = {}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--Setup a listener to see when this data gets filled in
&#9;&#9;&#9;&#9;if not leaderstats then
&#9;&#9;&#9;&#9;&#9;--We don&apos;t even have a leaderstats child, wait for one
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;player.ChildAdded:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if child.Name == &quot;leaderstats&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--Connections will be torn down
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;child.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if prop == &quot;Name&quot; and child.Name == &quot;leaderstats&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--Connections will be torn down
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--We have a leaderstats, but not enough children, recreate if we get them
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;leaderstats.ChildAdded:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--TODO only look for IntValue
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;leaderstats.AncestryChanged:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--We got deleted, try again
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if statValues then
&#9;&#9;&#9;&#9;if not playerTable[player].StatValues then
&#9;&#9;&#9;&#9;&#9;playerTable[player].StatValues = {}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local pos = 1
&#9;&#9;&#9;&#9;while pos &lt;= numStatColumns and pos &lt;= #statValues do
&#9;&#9;&#9;&#9;&#9;local currentColumn = pos
&#9;&#9;&#9;&#9;&#9;local statValue = statValues[pos]
&#9;&#9;&#9;&#9;&#9;local statChanger = textChangers[pos]

&#9;&#9;&#9;&#9;&#9;local updateStat = function(val)
&#9;&#9;&#9;&#9;&#9;&#9;statChanger(val)
&#9;&#9;&#9;&#9;&#9;&#9;if playerTable[player] ~= nil then recomputeTeamScore(playerTable[player].CurrentTeam, currentColumn) end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if pos &gt; #playerTable[player].StatValues then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].StatValues, statValue)
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;if type(statValue) ~= &quot;number&quot; and statValue[&quot;Changed&quot;] then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;statValue.Changed:connect(updateStat)
&#9;&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;&#9;&#9;statValue.AncestryChanged:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;&#9;updateStat(statValue.Value)
&#9;&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if supportFriends and player ~= game.Players.LocalPlayer and player.userId &gt; 0 and  game.Players.LocalPlayer.userId &gt; 0 then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = playerObject.Name .. &quot;Button&quot;
&#9;&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;&#9;button.Active = false
&#9;&#9;&#9;button.Size = playerObject.Size
&#9;&#9;&#9;button.Position = playerObject.Position
&#9;&#9;&#9;button.BackgroundColor3 = playerObject.BackgroundColor3
&#9;&#9;&#9;
&#9;&#9;&#9;local secondButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;secondButton.Name = playerObject.Name .. &quot;RealButton&quot;
&#9;&#9;&#9;secondButton.Text = &quot;&quot;
&#9;&#9;&#9;secondButton.BackgroundTransparency = 1
&#9;&#9;&#9;secondButton.BackgroundColor3 = playerObject.BackgroundColor3
&#9;&#9;&#9;local theNameLabel = playerObject:findFirstChild(&quot;NameLabel&quot;,true)
&#9;&#9;&#9;if theNameLabel then
&#9;&#9;&#9;&#9;theNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;secondButton.Parent = theNameLabel
&#9;&#9;&#9;end
&#9;&#9;&#9;secondButton.Parent.BackgroundTransparency = 1
&#9;&#9;&#9;secondButton.Parent.Visible = true
&#9;&#9;&#9;secondButton.ZIndex = 2
&#9;&#9;&#9;secondButton.Size = UDim2.new(1,0,1,0)

&#9;&#9;&#9;local previousTransparency = nil
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function(x,y)
&#9;&#9;&#9;&#9;&#9;&#9;if playerContextMenu and playerContextMenu.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;end -- don&apos;t update if we currently see it
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerContextMenu(player,x,y)
&#9;&#9;&#9;&#9;&#9;&#9;if not playerContextMenuHasItems() then return end -- don&apos;t show if we have nothing to show
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if previousTransparency == nil then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;previousTransparency = secondButton.BackgroundTransparency
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;secondButton.Parent.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;if previousTransparency ~= nil then&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;previousTransparency = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;delay(0.01,function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if playerContextMenu and not inContextMenu then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;secondButton.Parent.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;
&#9;&#9;&#9;local mouseDownX, mouseDownY
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseButton1Down:connect(function(x,y) 
&#9;&#9;&#9;&#9;&#9;mouseDownX = x
&#9;&#9;&#9;&#9;&#9;mouseDownY = y
&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;showPlayerMenu(player, mouseDownX, secondButton.AbsolutePosition.Y + secondButton.AbsoluteSize.Y )
&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;playerObject.BackgroundTransparency = 1
&#9;&#9;&#9;playerObject.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;playerObject.Position = UDim2.new(0,0,0,0)
&#9;&#9;&#9;playerObject.Parent = button
&#9;&#9;&#9;
&#9;&#9;&#9;playerTable[player][&quot;MainObject&quot; .. suffix] = button
&#9;&#9;&#9;
&#9;&#9;&#9;playerObject = button
&#9;&#9;else
&#9;&#9;&#9;playerTable[player][&quot;MainObject&quot; .. suffix] = playerObject
&#9;&#9;&#9;
&#9;&#9;&#9;if player == game.Players.LocalPlayer and supportFriends then
&#9;&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;&#9;player.FriendStatusChanged:connect(
&#9;&#9;&#9;&#9;&#9;function(otherPlayer, friendStatus)
&#9;&#9;&#9;&#9;&#9;&#9;if friendRequestBlacklist[otherPlayer] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerFriendStatus(playerTable[otherPlayer][&quot;NameObject&quot; .. suffix], Enum.FriendStatus.NotFriend)
&#9;&#9;&#9;&#9;&#9;&#9;elseif playerTable[otherPlayer] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerFriendStatus(playerTable[otherPlayer][&quot;NameObject&quot; .. suffix], friendStatus)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;player.Changed:connect(
&#9;&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;&#9;if prop == &quot;MembershipType&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerName(playerTable[player][&quot;NameObject&quot; .. suffix], player.MembershipType, currentColor)
&#9;&#9;&#9;&#9;&#9;elseif prop == &quot;Name&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;playerTable[player][&quot;ChangeName&quot; .. suffix](player.Name)
&#9;&#9;&#9;&#9;&#9;elseif prop == &quot;Neutral&quot; or prop == &quot;TeamColor&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;assignToTeam(player)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;return playerObject
&#9;end

&#9;local function doSort(tableToSort, objectName, order, startPos, sortType, ascending)
&#9;&#9;local orderedPlayerTable = {}
&#9;&#9;getLocalPlayer = false
&#9;&#9;for i, player in ipairs(tableToSort) do
&#9;&#9;&#9;if playerTable[player] then
&#9;&#9;&#9;&#9;if playerTable[player][objectName] ~= nil then
&#9;&#9;&#9;&#9;&#9;if player ~= game.Players.LocalPlayer then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(orderedPlayerTable,playerTable[player][objectName])
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;getLocalPlayer = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if sortType == nil then -- default back to alphabetical sort
&#9;&#9;&#9;table.sort(orderedPlayerTable,function(a,b)
&#9;&#9;&#9;&#9;return string.lower(a:FindFirstChild(&quot;FullNameLabel&quot;,true).Text) &lt; string.lower(b:FindFirstChild(&quot;FullNameLabel&quot;,true).Text)
&#9;&#9;&#9;end)
&#9;&#9;else -- we are sorting by a value
&#9;&#9;&#9;table.sort(orderedPlayerTable,function(a,b)
&#9;&#9;&#9;&#9;if ascending then
&#9;&#9;&#9;&#9;&#9;currentSortName = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;return tonumber(a:FindFirstChild(sortType,true).Text) &gt; tonumber(b:FindFirstChild(sortType,true).Text)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;currentSortName = sortType
&#9;&#9;&#9;&#9;&#9;return tonumber(a:FindFirstChild(sortType,true).Text) &lt; tonumber(b:FindFirstChild(sortType,true).Text)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if getLocalPlayer and playerTable[game.Players.LocalPlayer] and playerTable[game.Players.LocalPlayer][objectName] then
&#9;&#9;&#9;table.insert(orderedPlayerTable,1,playerTable[game.Players.LocalPlayer][objectName])
&#9;&#9;end
&#9;&#9;for i = 1, #orderedPlayerTable do
&#9;&#9;&#9;order[orderedPlayerTable[i]] = startPos
&#9;&#9;&#9;startPos = startPos + 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;return startPos
&#9;end

&#9;local function orderScrollList(scrollOrder, objectName, scrollFrame, sortType, ascending)
&#9;&#9;local pos = 0
&#9;&#9;local order = {}
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;for i, obj in ipairs(scrollOrder) do
&#9;&#9;&#9;order[obj] = 0
&#9;&#9;end

&#9;&#9;if isTeam then
&#9;&#9;&#9;local teams = getTeams()
&#9;&#9;&#9;for i, team in ipairs(teams) do
&#9;&#9;&#9;&#9;if teamTable[team][objectName] then
&#9;&#9;&#9;&#9;&#9;order[teamTable[team][objectName]] = pos
&#9;&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pos = doSort(teamTable[team].Players, objectName, order, pos, sortType, ascending)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if #teamTable[&quot;Neutral&quot;].Players &gt; 0 then
&#9;&#9;&#9;&#9;teamTable[&quot;Neutral&quot;][objectName].Parent = scrollFrame
&#9;&#9;&#9;&#9;order[teamTable[&quot;Neutral&quot;][objectName]] = pos
&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;doSort(teamTable[&quot;Neutral&quot;].Players, objectName, order, pos, sortType, ascending)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;teamTable[&quot;Neutral&quot;][objectName].Parent = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local players = getPlayers()
&#9;&#9;&#9;doSort(players, objectName, order, pos, sortType, ascending)
&#9;&#9;end

&#9;&#9;table.sort(scrollOrder, 
&#9;&#9;&#9;function(a,b) 
&#9;&#9;&#9;&#9;return order[a] &lt; order[b] 
&#9;&#9;&#9;end)
&#9;end
&#9;
&#9;local function createPlayerListBasics(frame, isBig)
&#9;&#9;local headerFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;headerFrame.Name = &quot;Header&quot;
&#9;&#9;headerFrame.BackgroundTransparency = 1
&#9;&#9;headerFrame.Size = UDim2.new(1,-13,0,26)
&#9;&#9;headerFrame.Position = UDim2.new(0,0,0,0)
&#9;&#9;headerFrame.Parent = frame

&#9;&#9;local lowerPaneFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;lowerPaneFrame.Name = &quot;ScrollingArea&quot;
&#9;&#9;lowerPaneFrame.BackgroundTransparency = 1
&#9;&#9;lowerPaneFrame.Size = UDim2.new(1,-3,1,-26)
&#9;&#9;if not isBig then lowerPaneFrame.Size = UDim2.new(1,-3,1,-30) end
&#9;&#9;lowerPaneFrame.Position = UDim2.new(0,0,0,26)
&#9;&#9;lowerPaneFrame.Parent = frame

&#9;&#9;local scrollOrder = {}
&#9;&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll, scrollBar = RbxGui.CreateScrollingFrame(scrollOrder)

&#9;&#9;scrollBar.Size = UDim2.new(0, 17, 1, -36)
&#9;&#9;if isBig then scrollBar.Size = UDim2.new(0, 17, 1, -61) end
&#9;&#9;scrollBar.Parent = lowerPaneFrame

&#9;&#9;scrollFrame.Parent = lowerPaneFrame
&#9;&#9;scrollUp.Parent = lowerPaneFrame
&#9;&#9;scrollDown.Parent = lowerPaneFrame

&#9;&#9;if isBig then
&#9;&#9;&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;&#9;&#9;scrollUp.Position = UDim2.new(1,-41,0,5)
&#9;&#9;&#9;scrollDown.Position = UDim2.new(1,-41,1,-35)
&#9;&#9;&#9;scrollBar.Position = UDim2.new(1, -41, 0, 24)

&#9;&#9;&#9;scrollFrame.Size = UDim2.new(1,-48,1,-16)
&#9;&#9;&#9;headerFrame.Size = UDim2.new(1,-20,0,26)
&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;scrollBar.Position = UDim2.new(1, -15, 0, 14)
&#9;&#9;&#9;scrollBar.Size = UDim2.new(0,17,1,-36)
&#9;&#9;&#9;scrollFrame.Position = UDim2.new(0,1,0,0)
&#9;&#9;&#9;scrollUp.Position = UDim2.new(1,-15,0,-5)
&#9;&#9;&#9;scrollDown.Position = UDim2.new(1,-15,1,-20)
&#9;&#9;&#9;
&#9;&#9;&#9;lowerPaneFrame.Position = UDim2.new(0,0,0,30)

&#9;&#9;&#9;local toggleScrollBar = function(visible)
&#9;&#9;&#9;&#9;if visible then
&#9;&#9;&#9;&#9;&#9;scrollFrame.Size = UDim2.new(1,-16,1,0)
&#9;&#9;&#9;&#9;&#9;headerFrame.Size = UDim2.new(1,-16,0,smallWindowHeaderYSize)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;scrollFrame.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;&#9;&#9;headerFrame.Size = UDim2.new(1,0,0,smallWindowHeaderYSize)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;scrollUp.Visible = visible
&#9;&#9;&#9;&#9;scrollDown.Visible = visible
&#9;&#9;&#9;&#9;scrollBar.Visible = visible
&#9;&#9;&#9;end
&#9;&#9;&#9;scrollUp.Changed:connect(function(prop) 
&#9;&#9;&#9;&#9;if prop == &quot;Active&quot; then
&#9;&#9;&#9;&#9;&#9;toggleScrollBar(scrollUp.Active or scrollDown.Active)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;&#9;scrollDown.Changed:connect(function(prop) 
&#9;&#9;&#9;&#9;if prop == &quot;Active&quot; then
&#9;&#9;&#9;&#9;&#9;toggleScrollBar(scrollUp.Active or scrollDown.Active)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;&#9;toggleScrollBar(scrollUp.Active or scrollDown.Active)
&#9;&#9;end
&#9;&#9;return headerFrame, scrollFrame, recalculateScroll, scrollOrder
&#9;end
&#9;&#9;&#9;
&#9;createBoardsFunction = function (boardType, numStatColumns)
&#9;&#9;local updatePlayerCount = function()
&#9;&#9;&#9;return #getPlayers()
&#9;&#9;end
&#9;&#9;
&#9;&#9;local smallFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;smallFrame.Name = &quot;SmallPlayerlist&quot;
&#9;&#9;smallFrame.Position = smallWindowPosition
&#9;&#9;smallFrame.Active = false
&#9;&#9;smallFrame.Size = smallWindowSize
&#9;&#9;smallFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;smallFrame.BackgroundTransparency = 0.7
&#9;&#9;smallFrame.BorderSizePixel = 0

&#9;&#9;local bigFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;bigFrame.Name = &quot;BigPlayerlist&quot;
&#9;&#9;bigFrame.Size = bigWindowSize
&#9;&#9;bigFrame.Position = bigWindowPosition
&#9;&#9;bigFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;bigFrame.BackgroundTransparency = 0.7
&#9;&#9;bigFrame.BorderSizePixel = 0
&#9;&#9;bigFrame.Visible = false&#9;&#9;
&#9;&#9;
&#9;&#9;local bigFrameWrapper = Instance.new(&quot;Frame&quot;)
&#9;&#9;bigFrameWrapper.Name = &quot;Expander&quot;
&#9;&#9;bigFrameWrapper.Size = UDim2.new(1,21,1,16)
&#9;&#9;bigFrameWrapper.Position = UDim2.new(0, 0, 0,0)
&#9;&#9;bigFrameWrapper.BackgroundTransparency = 1
&#9;&#9;bigFrameWrapper.Parent = bigFrame

&#9;&#9;local smallHeaderFrame, scrollFrameSmall, recalculateScrollSmall, scrollOrderSmall = createPlayerListBasics(smallFrame, false)
&#9;&#9;local bigHeaderFrame, scrollFrameBig, recalculateScrollBig, scrollOrderBig = createPlayerListBasics(bigFrameWrapper, true)
&#9;&#9;
&#9;&#9;local playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;GoBigButton&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_small_maximize.png&quot;
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 35, 0, 29)
&#9;&#9;playerListButton.Position = UDim2.new(0, 0, 0, 0)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;toggleBigWindow()
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = smallHeaderFrame

&#9;&#9;playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;CloseButton&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_small_hide.png&quot;
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 38, 0, 29)
&#9;&#9;playerListButton.Position = UDim2.new(0, 35, 0, 0)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;transitionWindowsFunction(&quot;None&quot;)
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = smallHeaderFrame

&#9;&#9;playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;CloseButton&quot;
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_big_hide.png&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 29, 0, 29)
&#9;&#9;playerListButton.Position = UDim2.new(1, -30, 0.5, -13)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;toggleBigWindow()
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = bigHeaderFrame

&#9;&#9;local placeName = Instance.new(&quot;TextButton&quot;)
&#9;&#9;placeName.Name = &quot;PlaceName&quot;
&#9;&#9;placeName.Text = &quot; Players (&quot; .. tostring(updatePlayerCount()) .. &quot;)&quot;
&#9;&#9;placeName.AutoButtonColor = false
&#9;&#9;placeName.FontSize = Enum.FontSize.Size24
&#9;&#9;placeName.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;placeName.Font = Enum.Font.ArialBold
&#9;&#9;placeName.BorderSizePixel = 0
&#9;&#9;placeName.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;placeName.BackgroundTransparency = 1
&#9;&#9;placeName.TextColor3 = Color3.new(1,1,1)
&#9;&#9;placeName.Size = UDim2.new(0.4, 0, 1, 0)
&#9;&#9;placeName.Position = UDim2.new(0, 0, 0.0, 0)
&#9;&#9;placeName = RbxGui.AutoTruncateTextObject(placeName)
&#9;&#9;placeName.Parent = bigHeaderFrame
&#9;&#9;&#9;&#9;
&#9;&#9;placeName.MouseEnter:connect(function()
&#9;&#9;&#9;placeName.BackgroundTransparency = 0.2
&#9;&#9;end)
&#9;&#9;
&#9;&#9;placeName.MouseLeave:connect(function()
&#9;&#9;&#9;placeName.BackgroundTransparency = 1
&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;placeName.MouseButton1Click:connect(function() 
&#9;&#9;&#9;sortPlayerListsFunction()
&#9;&#9;end)
&#9;&#9;
&#9;&#9;currentBoardType = boardType
&#9;&#9;currentStatCount = numStatColumns
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;local players = getPlayers()
&#9;&#9;
&#9;&#9;if isScore then
&#9;&#9;&#9;local statColumns = getStatColumns(players)
&#9;&#9;&#9;numStatColumns = #statColumns
&#9;&#9;&#9;if numStatColumns &gt; 3 then
&#9;&#9;&#9;&#9;numStatColumns = 3
&#9;&#9;&#9;end
&#9;&#9;&#9;createStatHeaders(statColumns, numStatColumns, false).Parent = smallHeaderFrame
&#9;&#9;&#9;createStatHeaders(statColumns, currentStatCount, true).Parent = bigHeaderFrame
&#9;&#9;end

&#9;&#9;--Clean up all old stuff
&#9;&#9;resetPlayerTable()
&#9;&#9;updatePlayerCount()

&#9;&#9;for i, player in ipairs(players) do
&#9;&#9;&#9;local playerObject = buildPlayerObject(player, numStatColumns, &quot;Small&quot;)
&#9;&#9;&#9;table.insert(scrollOrderSmall, playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameSmall

&#9;&#9;&#9;playerObject = buildPlayerObject(player, currentStatCount, &quot;Big&quot;)
&#9;&#9;&#9;table.insert(scrollOrderBig, playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameBig
&#9;&#9;end

&#9;&#9;--Clean up old stuff
&#9;&#9;resetTeamTable()

&#9;&#9;local teamStatObjects = {}
&#9;&#9;if isTeam then
&#9;&#9;&#9;local teams = getTeams()
&#9;&#9;&#9;local i = #teams
&#9;&#9;&#9;while i &gt;= 1 do
&#9;&#9;&#9;&#9;--We go backwards so the &quot;first&quot; team color gets the team
&#9;&#9;&#9;&#9;local team = teams[i]
&#9;&#9;&#9;&#9;teamColorTable[team.TeamColor.Name] = team
&#9;&#9;&#9;&#9;i = i - 1
&#9;&#9;&#9;end 

&#9;&#9;&#9;--Adding/Removing a Team causes a full invalidation of the board
&#9;&#9;&#9;for i, team in ipairs(teams) do
&#9;&#9;&#9;&#9;local teamObject = buildTeamObject(team, numStatColumns, &quot;Small&quot;)
&#9;&#9;&#9;&#9;table.insert(scrollOrderSmall, teamObject)
&#9;&#9;&#9;&#9;teamObject.Parent = scrollFrameSmall

&#9;&#9;&#9;&#9;teamObject = buildTeamObject(team, currentStatCount, &quot;Big&quot;)
&#9;&#9;&#9;&#9;table.insert(scrollOrderBig, teamObject)
&#9;&#9;&#9;&#9;teamObject.Parent = scrollFrameBig
&#9;&#9;&#9;end

&#9;&#9;&#9;teamTable[&quot;Neutral&quot;] = {}
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].Players = {}

&#9;&#9;&#9;local neutralTeamObject = createTeamName(&quot;Neutral&quot;, BrickColor.palette(8))
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].NameObjectSmall = neutralTeamObject
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].StatObjectSmall = nil
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].MainObjectSmall = neutralTeamObject
&#9;&#9;&#9;table.insert(scrollOrderSmall, neutralTeamObject)

&#9;&#9;&#9;neutralTeamObject = createTeamName(&quot;Neutral&quot;, BrickColor.palette(8))
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].NameObjectBig = neutralTeamObject
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].StatObjectBig = nil
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].MainObjectBig = neutralTeamObject
&#9;&#9;&#9;table.insert(scrollOrderBig, neutralTeamObject)

&#9;&#9;&#9;local neutralPlayers = {}
&#9;&#9;&#9;for i, player in ipairs(players) do
&#9;&#9;&#9;&#9;assignToTeam(player)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;removePlayerFunction = function(player)
&#9;&#9;&#9;if playerTable[player] then
&#9;&#9;&#9;&#9;clearTableEntry(player, playerTable[player])
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;placeName.Text = &quot; Players (&quot; .. tostring(updatePlayerCount()) .. &quot;)&quot;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;ArrayRemove(scrollOrderSmall, playerTable[player].MainObjectSmall)
&#9;&#9;&#9;&#9;ArrayRemove(scrollOrderBig, playerTable[player].MainObjectBig)
&#9;
&#9;&#9;&#9;&#9;playerTable[player] = nil
&#9;&#9;&#9;&#9;recalculateSmallPlayerListSize(smallFrame)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;recreatePlayerFunction = function(player)
&#9;&#9;&#9;placeName.Text = &quot; Players (&quot; .. tostring(updatePlayerCount()) .. &quot;)&quot;
&#9;&#9;&#9;
&#9;&#9;&#9;removePlayerFunction(player)

&#9;&#9;&#9;local playerObject = buildPlayerObject(player, numStatColumns, &quot;Small&quot;)
&#9;&#9;&#9;table.insert(scrollOrderSmall, playerObject)
&#9;&#9;&#9;robloxLock(playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameSmall

&#9;&#9;&#9;playerObject = buildPlayerObject(player, currentStatCount, &quot;Big&quot;)
&#9;&#9;&#9;table.insert(scrollOrderBig, playerObject)
&#9;&#9;&#9;robloxLock(playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameBig
&#9;&#9;&#9;
&#9;&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;&#9;if isTeam then
&#9;&#9;&#9;&#9;assignToTeam(player)
&#9;&#9;&#9;end

&#9;&#9;&#9;sortPlayerListsFunction()
&#9;&#9;&#9;recalculateSmallPlayerListSize(smallFrame)
&#9;&#9;end
&#9;&#9;
&#9;&#9;if screenResizeCon then screenResizeCon:disconnect() end
&#9;&#9;screenResizeCon = screen.Changed:connect(
&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;recalculateSmallPlayerListSize(smallFrame)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;sortPlayerListsFunction = function(sortType, ascending)
&#9;&#9;&#9;orderScrollList(scrollOrderSmall, &quot;MainObjectSmall&quot;, scrollFrameSmall, sortType, ascending)
&#9;&#9;&#9;recalculateScrollSmall()
&#9;&#9;&#9;createAlternatingRows(scrollOrderSmall)

&#9;&#9;&#9;orderScrollList(scrollOrderBig, &quot;MainObjectBig&quot;, scrollFrameBig, sortType, ascending)
&#9;&#9;&#9;recalculateScrollBig()
&#9;&#9;&#9;createAlternatingRows(scrollOrderBig)
&#9;&#9;end

&#9;&#9;sortPlayerListsFunction()

&#9;&#9;robloxLock(smallFrame)
&#9;&#9;robloxLock(bigFrame)
&#9;&#9;return smallFrame, bigFrame
&#9;end

&#9;--Teams changing invalidates the whole board&#9;
&#9;local function teamsChanged()
&#9;&#9;if debounceTeamsChanged then 
&#9;&#9;&#9;return 
&#9;&#9;end

&#9;&#9;debounceTeamsChanged = true
&#9;&#9;wait()
&#9;&#9;rebuildBoard(script.Parent, determineBoardType())
&#9;&#9;debounceTeamsChanged = false
&#9;end

&#9;
&#9;local checkIfBoardChanged = function()
&#9;&#9;local newBoardType, numStats = determineBoardType()
&#9;&#9;if newBoardType ~= currentBoardType or numStats ~= currentStatCount then
&#9;&#9;&#9;rebuildBoard(script.Parent, newBoardType, numStats)
&#9;&#9;end
&#9;end

&#9;local function buildPlayerList()
&#9;&#9;waitForChild(game, &quot;Players&quot;)
&#9;&#9;waitForProperty(game.Players, &quot;LocalPlayer&quot;)
&#9;&#9;
&#9;&#9;local teams = game:GetService(&quot;Teams&quot;)
&#9;&#9;if teams then
&#9;&#9;&#9;local teamConnections = {}

&#9;&#9;&#9;teams.ChildAdded:connect(
&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;teamsChanged()
&#9;&#9;&#9;&#9;&#9;&#9;teamConnections[child] = child.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if prop == &quot;TeamColor&quot; or prop == &quot;Name&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--Rebuild when things change
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamsChanged()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;teams.ChildRemoved:connect(
&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;if teamConnections[child] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamConnections[child]:disconnect()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamConnections[child] = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;teamsChanged()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;game.Players.ChildAdded:connect(
&#9;&#9;&#9;function(player)
&#9;&#9;&#9;&#9;if player:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;addPlayerFunction(player)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;game.Players.ChildRemoved:connect(
&#9;&#9;&#9;function(player)
&#9;&#9;&#9;&#9;if player:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;if removePlayerFunction then
&#9;&#9;&#9;&#9;&#9;&#9;removePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;rebuildBoard(script.Parent, determineBoardType())

&#9;&#9;game.GuiService:AddKey(&quot;\t&quot;)
&#9;&#9;local lastTime = nil
&#9;&#9;game.GuiService.KeyPressed:connect(
&#9;&#9;function(key)
&#9;&#9;&#9;if key == &quot;\t&quot; then
&#9;&#9;&#9;&#9;local modalCheck, isModal = pcall(function() return game.GuiService.IsModalDialog end)
&#9;&#9;&#9;&#9;if modalCheck == false or (modalCheck and isModal == false) then
&#9;&#9;&#9;&#9;&#9;local currentTime = time()
&#9;&#9;&#9;&#9;&#9;if lastTime == nil or currentTime - lastTime &gt; 0.4 then
&#9;&#9;&#9;&#9;&#9;&#9;lastTime = currentTime
&#9;&#9;&#9;&#9;&#9;&#9;toggleBigWindow()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;&#9;delay(0,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;while true  do
&#9;&#9;&#9;&#9;&#9;wait(5)
&#9;&#9;&#9;&#9;&#9;checkIfBoardChanged()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;end
&#9;

&#9;&#9;buildPlayerList()


if not personalServerPlace then -- one more backup check
&#9;local theBool = game.Workspace:FindFirstChild(&quot;PSVariable&quot;)
&#9;if theBool and theBool:IsA(&quot;BoolValue&quot;) then
&#9;&#9;personalServerPlace = true
&#9;end
end

if personalServerPlace then
&#9;addPersonalServerContext()
&#9;setupBuildToolManagement()
else
&#9;local psVarCon = nil
&#9;psVarCon = game.Workspace.ChildAdded:connect(function(child)
&#9;&#9;if child:IsA(&quot;BoolValue&quot;) and child.Name == &quot;PSVariable&quot; then
&#9;&#9;&#9;psVarCon:disconnect()
&#9;&#9;&#9;personalServerPlace = true
&#9;&#9;&#9;addPersonalServerContext()
&#9;&#9;&#9;setupBuildToolManagement()
&#9;&#9;end
&#9;end)
end


---------------------------------- Start Player Hover Code ----------------------------------------
if contextMenu3d then
&#9;local inMenu = false

&#9;function waitForProperty(instance, name)
&#9;&#9;while not instance[name] do
&#9;&#9;&#9;instance.Changed:wait()
&#9;&#9;end
&#9;end

&#9;function makeNewActionButton()
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;ActionButton&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;button.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;button.BackgroundTransparency = 0.5
&#9;&#9;button.Size = UDim2.new(1,0,0,50)
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.ZIndex = 4
&#9;&#9;return button
&#9;end

&#9;function getContextElements(currentContextMenuPlayer)
&#9;&#9;local elements = {}
&#9;&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;&#9;local element = contextElement
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local isVisible = false

&#9;&#9;&#9;if contextElement.IsVisible then
&#9;&#9;&#9;&#9;local success, visible = pcall(function() return contextElement.IsVisible(currentContextMenuPlayer) end)
&#9;&#9;&#9;&#9;if success then 
&#9;&#9;&#9;&#9;&#9;isVisible = visible
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;Error in IsVisible call: &quot; .. visible)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if element.Type == &quot;Button&quot; then
&#9;&#9;&#9;&#9;local button = makeNewActionButton()&#9;
&#9;&#9;&#9;&#9;button.Name = &quot;ContextButton&quot; .. i
&#9;&#9;&#9;&#9;button.Visible = isVisible
&#9;&#9;&#9;&#9;button.Text = contextElement.Text
&#9;&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;if button.Active then
&#9;&#9;&#9;&#9;&#9;&#9;local success, result = pcall(function() element.DoIt(currentContextMenuPlayer) end)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;contextElement.Button = button
&#9;&#9;&#9;&#9;contextElement.Element = button
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;table.insert(elements,contextElement)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return elements
&#9;end

&#9;function findContextElement(contextElements, button)
&#9;&#9;for i = 1, #contextElements do
&#9;&#9;&#9;if contextElements[i].Button == button then
&#9;&#9;&#9;&#9;return contextElements[i]
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function populateActions(scrollFrame, nullFrame, recalcFunction, otherPlayer)
&#9;&#9;local elements = getContextElements(otherPlayer)
&#9;&#9;for i = 1, #elements do
&#9;&#9;&#9;if elements[i].Button.Visible then
&#9;&#9;&#9;&#9;elements[i].Button.Parent = scrollFrame
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;elements[i].Button.Parent = nullFrame
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local actionButtonCon
&#9;&#9;&#9;actionButtonCon = elements[i].Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;actionButtonCon:disconnect()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local nullFrameChildren = nullFrame:GetChildren()
&#9;&#9;&#9;&#9;for j = 1, #nullFrameChildren do
&#9;&#9;&#9;&#9;&#9;local contextElement = findContextElement(elements, nullFrameChildren[j])
&#9;&#9;&#9;&#9;&#9;pcall(function() nullFrameChildren[j].Visible = contextElement.IsVisible(otherPlayer) end)
&#9;&#9;&#9;&#9;&#9;if nullFrameChildren[j].Visible then
&#9;&#9;&#9;&#9;&#9;&#9;nullFrameChildren[j].Parent = scrollFrame
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local scrollFrameChildren = scrollFrame:GetChildren()
&#9;&#9;&#9;&#9;for j = 1, #scrollFrameChildren do
&#9;&#9;&#9;&#9;&#9;local contextElement = findContextElement(elements, scrollFrameChildren[j])
&#9;&#9;&#9;&#9;&#9;pcall(function() scrollFrameChildren[j].Visible = contextElement.IsVisible(otherPlayer) end)
&#9;&#9;&#9;&#9;&#9;if not scrollFrameChildren[j].Visible then
&#9;&#9;&#9;&#9;&#9;&#9;scrollFrameChildren[j].Parent = nullFrame
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;elements[i].Button.Parent = nullFrame
&#9;&#9;&#9;&#9;recalcFunction()
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end


&#9;function createContextMenu(otherPlayer)
&#9;&#9;
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;ContextMenuFrame&quot;
&#9;&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;frame.Size = UDim2.new(0,300,0,400)
&#9;&#9;frame.Position = UDim2.new(0.5,-150,0.5,-200)
&#9;&#9;frame.ZIndex = 2

&#9;&#9;local scrollFrame, scrollUpButton, scrollDownButton, recalc, scrollBar = RbxGui.CreateScrollingFrame()

&#9;&#9;scrollFrame.Name = &quot;Actions&quot;
&#9;&#9;scrollFrame.BackgroundTransparency = 1
&#9;&#9;scrollFrame.Position = UDim2.new(0,0,0,25)
&#9;&#9;scrollFrame.Size = UDim2.new(1,-20,1,-80)
&#9;&#9;scrollFrame.ZIndex = 3
&#9;&#9;scrollFrame.Parent = frame
&#9;&#9;
&#9;&#9;local nullFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;nullFrame.Name = &quot;NullFrame&quot;
&#9;&#9;nullFrame.BackgroundTransparency = 1
&#9;&#9;nullFrame.Visible = false
&#9;&#9;nullFrame.Parent = frame

&#9;&#9;local scrollButtons = Instance.new(&quot;Frame&quot;)
&#9;&#9;scrollButtons.Name = &quot;ScrollButtons&quot;
&#9;&#9;scrollButtons.BackgroundTransparency = 1
&#9;&#9;scrollButtons.Position = UDim2.new(1,-17,0,25)
&#9;&#9;scrollButtons.Size = UDim2.new(0,17,1,-80)
&#9;&#9;scrollButtons.ZIndex = 3
&#9;&#9;scrollButtons.Parent = frame

&#9;&#9;scrollUpButton.ZIndex = 3
&#9;&#9;scrollUpButton.Parent = scrollButtons
&#9;&#9;scrollDownButton.Position = UDim2.new(0,0,1,-17)
&#9;&#9;scrollDownButton.ZIndex = 3
&#9;&#9;scrollDownButton.Parent = scrollButtons

&#9;&#9;scrollBar.Size = UDim2.new(1,0,1,-34)
&#9;&#9;scrollBar.Position = UDim2.new(0,0,0,17)
&#9;&#9;scrollBar.Parent = scrollButtons

&#9;&#9;local playerImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;playerImage.Name = &quot;PlayerImage&quot;
&#9;&#9;playerImage.BackgroundTransparency = 1
&#9;&#9;playerImage.Image = &quot;http://www.roblox.com/thumbs/avatar.ashx?userId=&quot; .. tostring(otherPlayer.userId) .. &quot;&amp;x=352&amp;y=352&quot;
&#9;&#9;playerImage.Position = UDim2.new(0.5,-150,0.5,-150)
&#9;&#9;playerImage.Size = UDim2.new(0,300,0,300)
&#9;&#9;playerImage.Parent = frame

&#9;&#9;local playerName = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;playerName.Name = &quot;PlayerName&quot;
&#9;&#9;playerName.BackgroundTransparency = 1
&#9;&#9;playerName.Font = Enum.Font.ArialBold
&#9;&#9;playerName.FontSize = Enum.FontSize.Size24
&#9;&#9;playerName.Position = UDim2.new(0,-8,0,-6)
&#9;&#9;playerName.Size = UDim2.new(1,16,0,24)
&#9;&#9;playerName.Text = otherPlayer[&quot;Name&quot;]
&#9;&#9;playerName.TextColor3 = Color3.new(1,1,1)
&#9;&#9;playerName.TextWrap = true
&#9;&#9;playerName.ZIndex = 3
&#9;&#9;playerName.Parent = frame

&#9;&#9;local doneButtonCon

&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size36
&#9;&#9;doneButton.Position = UDim2.new(0.25,0,1,-50)
&#9;&#9;doneButton.Size = UDim2.new(0.5,0,0,50)
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.ZIndex = 3
&#9;&#9;doneButton.Parent = frame
&#9;&#9;doneButton.Modal = true
&#9;&#9;doneButtonCon = doneButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;doneButtonCon:disconnect()
&#9;&#9;&#9;inMenu = false
&#9;&#9;&#9;game.GuiService:RemoveCenterDialog(frame)
&#9;&#9;&#9;frame:remove()
&#9;&#9;end)

&#9;&#9;populateActions(scrollFrame, nullFrame, recalc, otherPlayer)
&#9;&#9;recalc()

&#9;&#9;return frame
&#9;end

&#9;function makeContextInvisible(menu)
&#9;&#9;menu.Visible = false
&#9;end

&#9;function goToContextMenu(otherPlayer)

&#9;&#9;local menu = createContextMenu(otherPlayer)
&#9;&#9;
&#9;&#9;game.GuiService:AddCenterDialog(menu, Enum.CenterDialogType.PlayerInitiatedDialog,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--ShowFunction
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;menu.Visible = true 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;menu:TweenSize(UDim2.new(0,300,0,400),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.5,true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--HideFunction
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;menu:TweenSize(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.5,true,function() makeContextInvisible(menu) end)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)&#9;
&#9;&#9;menu.Parent = script.Parent

      if menu.Visible == true then
&#9;&#9;inMenu = true
      elseif menu.Visible == false then
      inMenu = false
      end
&#9;end
&#9;
&#9;waitForProperty(game.Players, &quot;LocalPlayer&quot;)

&#9;local currSelectedPlayer = nil
&#9;if game.Players.LocalPlayer[&quot;HoverOnPlayerChanged&quot;] then
&#9;&#9;game.Players.LocalPlayer.HoverOnPlayerChanged:connect(function(otherPlayer)
&#9;&#9;&#9;if not inMenu then
&#9;&#9;&#9;&#9;if otherPlayer and otherPlayer.userId &lt; 0 then return end -- we don&apos;t want this for guests
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;currSelectedPlayer = otherPlayer
&#9;&#9;end)
&#9;end

&#9;if game.Players.LocalPlayer[&quot;MouseDownOnPlayer&quot;] then
&#9;&#9;game.Players.LocalPlayer.MouseDownOnPlayer:connect(function(otherPlayer)
&#9;&#9;&#9;if currSelectedPlayer ~= otherPlayer then return end
&#9;&#9;&#9;if not inMenu and otherPlayer.userId &gt; 0 then
&#9;&#9;&#9;&#9;goToContextMenu(otherPlayer)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

end
---------------------------------- End Player Hover Code ----------------------------------------</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX33">
			<Properties>
				<string name="Name">Backpack</string>
			</Properties>
			<Item class="LocalScript" referent="RBX34">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackBuilder</string>
					<ProtectedString name="Source">--rbxsig%IEUAo3Q1k4Rwb3ZcqPBum//j3+Jm/9Nv0JyCeCRWUrggWps7aG81/aPzlH9pPlMkkdsZwLsCRu6eTTrqzXn2DAJNPRs7y8akc3z91r1DP3jwomfpdT+2DBAmPk3Cdj8NXQzP6T+uEYm2kk2TW9pXonKvCgRVqXFx8J7mTr+aM1M=%
--rbxassetid%45284430%
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;button.RobloxLocked = true
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end
&#9;
-- This script creates almost all gui elements found in the backpack (warning: there are a lot!)
-- TODO: automate this process

local gui = script.Parent

-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

-- First up is the current loadout
local CurrentLoadout = Instance.new(&quot;Frame&quot;)
CurrentLoadout.Name = &quot;CurrentLoadout&quot;
CurrentLoadout.Position = UDim2.new(0.5, -170, 1, -85)
CurrentLoadout.Size = UDim2.new(0, 480, 0, 48)
CurrentLoadout.BackgroundTransparency = 1

CurrentLoadout.Parent = gui

local Debounce = Instance.new(&quot;BoolValue&quot;)
Debounce.Name = &quot;Debounce&quot;

Debounce.Parent = CurrentLoadout

for i = 0, 9 do
&#9;local slotFrame = Instance.new(&quot;Frame&quot;)

&#9;slotFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;slotFrame.BackgroundTransparency = 1
&#9;slotFrame.BorderColor3 = Color3.new(1,1,1)
&#9;slotFrame.Name = &quot;Slot&quot; .. tostring(i)
&#9;if i == 0 then
&#9;&#9;slotFrame.Position = UDim2.new(0.9,0,0,0)
&#9;else
&#9;&#9;slotFrame.Position = UDim2.new((i - 1) * 0.1,0,0,0)
&#9;end
&#9;slotFrame.Size = UDim2.new(0.1,0,1,0)
&#9;slotFrame.Parent = CurrentLoadout
end

local TempSlot = Instance.new(&quot;ImageButton&quot;)
TempSlot.Name = &quot;TempSlot&quot;
TempSlot.Active = true
TempSlot.Size = UDim2.new(1,0,1,0)
TempSlot.Style = Enum.ButtonStyle.RobloxButton
TempSlot.Visible = false

TempSlot.Parent = CurrentLoadout

&#9;-- TempSlot Children
&#9;local GearReference = Instance.new(&quot;ObjectValue&quot;)
&#9;GearReference.Name = &quot;GearReference&quot;

&#9;GearReference.Parent = TempSlot
&#9;
&#9;local ToolTipLabel = Instance.new(&quot;TextLabel&quot;)
&#9;ToolTipLabel.Name = &quot;ToolTipLabel&quot;
&#9;
&#9;ToolTipLabel.Text = &quot;&quot;
&#9;ToolTipLabel.BackgroundTransparency = 0.5
&#9;ToolTipLabel.BorderSizePixel = 0
&#9;ToolTipLabel.Visible = false
&#9;ToolTipLabel.TextColor3 = Color3.new(1,1,1)
&#9;ToolTipLabel.BackgroundColor3 = Color3.new(0,0,0)
&#9;ToolTipLabel.TextStrokeTransparency = 0
&#9;ToolTipLabel.Font = Enum.Font.ArialBold
&#9;ToolTipLabel.FontSize = Enum.FontSize.Size14
&#9;--ToolTipLabel.TextWrap = true
&#9;ToolTipLabel.Size = UDim2.new(1,60,0,20)
&#9;ToolTipLabel.Position = UDim2.new(0,-30,0,-30)
&#9;ToolTipLabel.Parent = TempSlot

&#9;local Kill = Instance.new(&quot;BoolValue&quot;)
&#9;Kill.Name = &quot;Kill&quot;

&#9;Kill.Parent = TempSlot

&#9;local GearImage = Instance.new(&quot;ImageLabel&quot;)
&#9;GearImage.Name = &quot;GearImage&quot;
&#9;GearImage.BackgroundTransparency = 1
&#9;GearImage.Position = UDim2.new(0,-7,0,-7)
&#9;GearImage.Size = UDim2.new(1,14,1,14)
&#9;GearImage.ZIndex = 2

&#9;GearImage.Parent = TempSlot

&#9;local SlotNumber = Instance.new(&quot;TextLabel&quot;)
&#9;SlotNumber.Name = &quot;SlotNumber&quot;
&#9;SlotNumber.BackgroundTransparency = 1
&#9;SlotNumber.BorderSizePixel = 0
&#9;SlotNumber.Font = Enum.Font.ArialBold
&#9;SlotNumber.FontSize = Enum.FontSize.Size18
&#9;SlotNumber.Position = UDim2.new(0,-7,0,-7)
&#9;SlotNumber.Size = UDim2.new(0,10,0,15)
&#9;SlotNumber.TextColor3 = Color3.new(1,1,1)
&#9;SlotNumber.TextTransparency = 0
&#9;SlotNumber.TextXAlignment = Enum.TextXAlignment.Left
&#9;SlotNumber.TextYAlignment = Enum.TextYAlignment.Bottom
&#9;SlotNumber.ZIndex = 4
&#9;
&#9;SlotNumber.Parent = TempSlot
&#9;
&#9;local SlotNumberDownShadow = SlotNumber:clone()
&#9;SlotNumberDownShadow.Name = &quot;SlotNumberDownShadow&quot;
&#9;SlotNumberDownShadow.TextColor3 = Color3.new(0,0,0)
&#9;SlotNumberDownShadow.ZIndex = 3
&#9;SlotNumberDownShadow.Position = UDim2.new(0,-6,0,-6)
&#9;SlotNumberDownShadow.Parent = TempSlot
&#9;
&#9;local SlotNumberUpShadow = SlotNumberDownShadow:clone()
&#9;SlotNumberUpShadow.Name = &quot;SlotNumberUpShadow&quot;
&#9;SlotNumberUpShadow.Position = UDim2.new(0,-8,0,-8)
&#9;SlotNumberUpShadow.Parent = TempSlot

&#9;local GearText = Instance.new(&quot;TextLabel&quot;)
&#9;
&#9;GearText.Name = &quot;GearText&quot;
&#9;GearText.BackgroundTransparency = 1
&#9;GearText.Font = Enum.Font.Arial
&#9;GearText.FontSize = Enum.FontSize.Size14
&#9;GearText.Position = UDim2.new(0,-8,0,-8)
&#9;GearText.ZIndex = 2
&#9;GearText.Size = UDim2.new(1,16,1,16)
&#9;GearText.Text = &quot;&quot;
&#9;GearText.TextColor3 = Color3.new(1,1,1)
&#9;GearText.TextWrap = true
&#9;GearText.Parent = TempSlot

--- Great, now lets make the inventory!

local Backpack = Instance.new(&quot;Frame&quot;)

Backpack.Visible = false
Backpack.Name = &quot;Backpack&quot;
Backpack.Position = UDim2.new(0.5,0,0.5,0)
Backpack.BackgroundColor3 = Color3.new(0,0,0)
Backpack.BackgroundTransparency = 0.08
Backpack.BorderSizePixel = 0
Backpack.Parent = gui
Backpack.Active = true

&#9;-- Backpack Children
&#9;local SwapSlot = Instance.new(&quot;BoolValue&quot;)
&#9;
&#9;SwapSlot.Name = &quot;SwapSlot&quot;
&#9;SwapSlot.Parent = Backpack
&#9;&#9;
&#9;&#9;-- SwapSlot Children
&#9;&#9;local Slot = Instance.new(&quot;IntValue&quot;)
&#9;
&#9;&#9;Slot.Name = &quot;Slot&quot;
&#9;&#9;Slot.Parent = SwapSlot
&#9;&#9;
&#9;&#9;local GearButton = Instance.new(&quot;ObjectValue&quot;)
&#9;&#9;
&#9;&#9;GearButton.Name = &quot;GearButton&quot;
&#9;&#9;GearButton.Parent = SwapSlot
&#9;
&#9;local Tabs = Instance.new(&quot;Frame&quot;)
&#9;Tabs.Name = &quot;Tabs&quot;
&#9;Tabs.Visible = true
&#9;
&#9;Tabs.BackgroundColor3 = Color3.new(0,0,0)
&#9;Tabs.BackgroundTransparency = 0.08
&#9;Tabs.BorderSizePixel = 0
&#9;Tabs.Position = UDim2.new(0,0,-0.1,-4)
&#9;Tabs.Size = UDim2.new(1,0,0.1,4)
&#9;Tabs.Parent = Backpack
&#9;
&#9;&#9;-- Tabs Children
&#9;&#9;
&#9;&#9;local tabLine = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;tabLine.Name = &quot;TabLine&quot;
&#9;&#9;tabLine.BackgroundColor3 = Color3.new(53/255, 53/255, 53/255)
&#9;&#9;tabLine.BorderSizePixel = 0
&#9;&#9;tabLine.Position = UDim2.new(0,5,1,-4)
&#9;&#9;tabLine.Size = UDim2.new(1,-10,0,4)
&#9;&#9;tabLine.ZIndex = 2
&#9;&#9;tabLine.Parent = Tabs
&#9;&#9;
&#9;&#9;local InventoryButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;InventoryButton.Name = &quot;InventoryButton&quot;
&#9;&#9;InventoryButton.Size = UDim2.new(0,60,0,30)
&#9;&#9;InventoryButton.Position = UDim2.new(0,7,1,-31)
&#9;&#9;InventoryButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;InventoryButton.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;InventoryButton.Font = Enum.Font.ArialBold
&#9;&#9;InventoryButton.FontSize = Enum.FontSize.Size18
&#9;&#9;InventoryButton.Text = &quot;Gear&quot;
&#9;&#9;InventoryButton.AutoButtonColor = false
&#9;&#9;InventoryButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;InventoryButton.Selected = true
&#9;&#9;InventoryButton.Active = true
&#9;&#9;InventoryButton.ZIndex = 3
&#9;&#9;InventoryButton.Parent = Tabs
&#9;&#9;&#9;
&#9;&#9;local closeButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;closeButton.Name = &quot;CloseButton&quot;
&#9;&#9;closeButton.Font = Enum.Font.ArialBold
&#9;&#9;closeButton.FontSize = Enum.FontSize.Size24
&#9;&#9;closeButton.Position = UDim2.new(1,-33,0,4)
&#9;&#9;closeButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;closeButton.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;closeButton.Text = &quot;&quot;
&#9;&#9;closeButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;closeButton.Parent = Tabs
&#9;&#9;closeButton.Modal = true
&#9;&#9;
&#9;&#9;&#9;--closeButton child
&#9;&#9;&#9;local XImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;XImage.Name = &quot;XImage&quot;
&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=75547445&quot;)
&#9;&#9;&#9;XImage.Image = &quot;http://www.roblox.com/asset/?id=75547445&quot;  --TODO: move to rbxasset
&#9;&#9;&#9;XImage.BackgroundTransparency = 1
&#9;&#9;&#9;XImage.Position = UDim2.new(-.25,-1,-.25,-1)
&#9;&#9;&#9;XImage.Size = UDim2.new(1.5,2,1.5,2)
&#9;&#9;&#9;XImage.ZIndex = 2
&#9;&#9;&#9;XImage.Parent = closeButton
&#9;&#9;&#9;
&#9;&#9;-- Generic Search gui used across backpack&#9;
&#9;&#9;local SearchFrame = Instance.new(&quot;Frame&quot;)
&#9;
&#9;&#9;SearchFrame.Name = &quot;SearchFrame&quot;
&#9;&#9;SearchFrame.BackgroundTransparency = 1
&#9;&#9;SearchFrame.Position = UDim2.new(1,-220,0,2)
&#9;&#9;SearchFrame.Size = UDim2.new(0,220,0,24)
&#9;&#9;SearchFrame.Parent = Backpack
&#9;&#9;
&#9;&#9;&#9;-- SearchFrame Children
&#9;&#9;&#9;local SearchButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;
&#9;&#9;&#9;SearchButton.Name = &quot;SearchButton&quot;
&#9;&#9;&#9;SearchButton.Size = UDim2.new(0,25,0,25)
&#9;&#9;&#9;SearchButton.BackgroundTransparency = 1
&#9;&#9;&#9;SearchButton.Image = &quot;rbxasset://textures/ui/SearchIcon.png&quot;
&#9;&#9;&#9;SearchButton.Parent = SearchFrame
&#9;&#9;&#9;
&#9;&#9;&#9;local SearchBoxFrame = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;&#9;SearchBoxFrame.Position = UDim2.new(0,25,0,0)
&#9;&#9;&#9;SearchBoxFrame.Size = UDim2.new(1,-28,0,26)
&#9;&#9;&#9;SearchBoxFrame.Name = &quot;SearchBoxFrame&quot;
&#9;&#9;&#9;SearchBoxFrame.Text = &quot;&quot;
&#9;&#9;&#9;SearchBoxFrame.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;&#9;SearchBoxFrame.Parent = SearchFrame
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- SearchBoxFrame Children
&#9;&#9;&#9;&#9;local SearchBox = Instance.new(&quot;TextBox&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;SearchBox.Name = &quot;SearchBox&quot;
&#9;&#9;&#9;&#9;SearchBox.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;SearchBox.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;SearchBox.FontSize = Enum.FontSize.Size12
&#9;&#9;&#9;&#9;SearchBox.Position = UDim2.new(0,-5,0,-5)
&#9;&#9;&#9;&#9;SearchBox.Size = UDim2.new(1,10,1,10)
&#9;&#9;&#9;&#9;SearchBox.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;SearchBox.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;SearchBox.ZIndex = 2
&#9;&#9;&#9;&#9;SearchBox.TextWrap = true
&#9;&#9;&#9;&#9;SearchBox.Text = &quot;Search...&quot;
&#9;&#9;&#9;&#9;SearchBox.Parent = SearchBoxFrame
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;local ResetButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;ResetButton.Visible = false
&#9;&#9;&#9;ResetButton.Name = &quot;ResetButton&quot;
&#9;&#9;&#9;ResetButton.Position = UDim2.new(1,-26,0,3)
&#9;&#9;&#9;ResetButton.Size = UDim2.new(0,20,0,20)
&#9;&#9;&#9;ResetButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;ResetButton.Text = &quot;X&quot;
&#9;&#9;&#9;ResetButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;ResetButton.Font = Enum.Font.ArialBold
&#9;&#9;&#9;ResetButton.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;ResetButton.ZIndex = 3
&#9;&#9;&#9;ResetButton.Parent = SearchFrame
&#9;&#9;
------------------------------- GEAR -------------------------------------------------------
&#9;local Gear = Instance.new(&quot;Frame&quot;)
&#9;Gear.Name = &quot;Gear&quot;

&#9;Gear.BackgroundTransparency = 1
&#9;Gear.Size  = UDim2.new(1,0,1,0)
&#9;Gear.Parent = Backpack

&#9;&#9;-- Gear Children
&#9;&#9;local AssetsList = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;AssetsList.Name = &quot;AssetsList&quot;
&#9;&#9;AssetsList.BackgroundTransparency = 1
&#9;&#9;AssetsList.Size = UDim2.new(0.2,0,1,0)
&#9;&#9;AssetsList.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;AssetsList.Visible = false
&#9;&#9;AssetsList.Parent = Gear
&#9;&#9;&#9;
&#9;&#9;local GearGrid = Instance.new(&quot;Frame&quot;)

&#9;&#9;GearGrid.Name = &quot;GearGrid&quot;
&#9;&#9;GearGrid.Size = UDim2.new(0.69,0,1,0)
&#9;&#9;GearGrid.BackgroundTransparency = 1
&#9;&#9;GearGrid.Parent = Gear
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;local GearButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;
&#9;&#9;&#9;GearButton.Visible = false
&#9;&#9;&#9;GearButton.Name = &quot;GearButton&quot;
&#9;&#9;&#9;GearButton.Size = UDim2.new(0,64,0,64)
&#9;&#9;&#9;GearButton.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;&#9;GearButton.Parent = GearGrid

&#9;&#9;&#9;&#9;-- GearButton Children
&#9;&#9;&#9;&#9;local GearReference = Instance.new(&quot;ObjectValue&quot;)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearReference.Name = &quot;GearReference&quot;
&#9;&#9;&#9;&#9;GearReference.Parent = GearButton
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local GreyOutButton = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;&#9;&#9;GreyOutButton.Name = &quot;GreyOutButton&quot;
&#9;&#9;&#9;&#9;GreyOutButton.BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;GreyOutButton.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;&#9;GreyOutButton.Active = true
&#9;&#9;&#9;&#9;GreyOutButton.Visible = false
&#9;&#9;&#9;&#9;GreyOutButton.ZIndex = 3
&#9;&#9;&#9;&#9;GreyOutButton.Parent = GearButton
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local GearText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearText.Name = &quot;GearText&quot;
&#9;&#9;&#9;&#9;GearText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;GearText.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;GearText.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;GearText.Position = UDim2.new(0,-8,0,-8)
&#9;&#9;&#9;&#9;GearText.Size = UDim2.new(1,16,1,16)
&#9;&#9;&#9;&#9;GearText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;GearText.ZIndex = 2
&#9;&#9;&#9;&#9;GearText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;GearText.TextWrap = true
&#9;&#9;&#9;&#9;GearText.Parent = GearButton

&#9;&#9;local GearGridScrollingArea = Instance.new(&quot;Frame&quot;)

&#9;&#9;GearGridScrollingArea.Name = &quot;GearGridScrollingArea&quot;
&#9;&#9;GearGridScrollingArea.Position = UDim2.new(0.7,0,0,35)
&#9;&#9;GearGridScrollingArea.Size = UDim2.new(0,17,1,-45)
&#9;&#9;GearGridScrollingArea.BackgroundTransparency = 1
&#9;&#9;GearGridScrollingArea.Parent = Gear

&#9;&#9;local GearLoadouts = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;GearLoadouts.Name = &quot;GearLoadouts&quot;
&#9;&#9;GearLoadouts.BackgroundTransparency = 1
&#9;&#9;GearLoadouts.Position = UDim2.new(0.7,23,0.5,1)
&#9;&#9;GearLoadouts.Size = UDim2.new(0.3,-23,0.5,-1)
&#9;&#9;GearLoadouts.Parent = Gear
&#9;&#9;GearLoadouts.Visible = false
&#9;&#9;
&#9;&#9;&#9;-- GearLoadouts Children
&#9;&#9;&#9;local GearLoadoutsHeader = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;GearLoadoutsHeader.Name = &quot;GearLoadoutsHeader&quot;
&#9;&#9;&#9;GearLoadoutsHeader.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;GearLoadoutsHeader.BackgroundTransparency = 0.2
&#9;&#9;&#9;GearLoadoutsHeader.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;&#9;GearLoadoutsHeader.Size = UDim2.new(1,2,0.15,-1)
&#9;&#9;&#9;GearLoadoutsHeader.Parent = GearLoadouts

&#9;&#9;&#9;&#9;-- GearLoadoutsHeader Children
&#9;&#9;&#9;&#9;local LoadoutsHeaderText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Name = &quot;LoadoutsHeaderText&quot;
&#9;&#9;&#9;&#9;LoadoutsHeaderText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;LoadoutsHeaderText.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Text = &quot;Loadouts&quot;
&#9;&#9;&#9;&#9;LoadoutsHeaderText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;LoadoutsHeaderText.Parent = GearLoadoutsHeader
&#9;
&#9;&#9;&#9;&#9;local GearLoadoutsScrollingArea = GearGridScrollingArea:clone()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Name = &quot;GearLoadoutsScrollingArea&quot;
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Position = UDim2.new(1,-15,0.15,2)
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Size = UDim2.new(0,17,0.85,-2)
&#9;&#9;&#9;&#9;GearLoadoutsScrollingArea.Parent = GearLoadouts

&#9;&#9;&#9;&#9;local LoadoutsList = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;LoadoutsList.Name = &quot;LoadoutsList&quot;
&#9;&#9;&#9;&#9;LoadoutsList.Position = UDim2.new(0,0,0.15,2)
&#9;&#9;&#9;&#9;LoadoutsList.Size = UDim2.new(1,-17,0.85,-2)
&#9;&#9;&#9;&#9;LoadoutsList.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;&#9;&#9;LoadoutsList.Parent = GearLoadouts
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;local GearPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;GearPreview.Name = &quot;GearPreview&quot;
&#9;&#9;GearPreview.Position = UDim2.new(0.7,23,0,0)
&#9;&#9;GearPreview.Size = UDim2.new(0.3,-28,0.5,-1)
&#9;&#9;GearPreview.BackgroundTransparency = 1
&#9;&#9;GearPreview.ZIndex = 7
&#9;&#9;GearPreview.Parent = Gear
&#9;&#9;
&#9;&#9;&#9;-- GearPreview Children
&#9;&#9;&#9;local GearStats = Instance.new(&quot;Frame&quot;)
&#9;&#9;
&#9;&#9;&#9;GearStats.Name = &quot;GearStats&quot;
&#9;&#9;&#9;GearStats.BackgroundTransparency = 1
&#9;&#9;&#9;GearStats.Position = UDim2.new(0,0,0.75,0)
&#9;&#9;&#9;GearStats.Size = UDim2.new(1,0,0.25,0)
&#9;&#9;&#9;GearStats.ZIndex = 8
&#9;&#9;&#9;GearStats.Parent = GearPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- GearStats Children
&#9;&#9;&#9;&#9;local GearName = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;GearName.Name = &quot;GearName&quot;
&#9;&#9;&#9;&#9;GearName.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;GearName.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;GearName.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;&#9;GearName.Position = UDim2.new(0,-3,0,0)
&#9;&#9;&#9;&#9;GearName.Size = UDim2.new(1,6,1,5)
&#9;&#9;&#9;&#9;GearName.Text = &quot;&quot;
&#9;&#9;&#9;&#9;GearName.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;GearName.TextWrap = true
&#9;&#9;&#9;&#9;GearName.ZIndex = 9
&#9;&#9;&#9;&#9;GearName.Parent = GearStats
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local GearImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;GearImage.Name = &quot;GearImage&quot;
&#9;&#9;&#9;GearImage.Image = &quot;&quot;
&#9;&#9;&#9;GearImage.BackgroundTransparency = 1
&#9;&#9;&#9;GearImage.Position = UDim2.new(0.125,0,0,0)
&#9;&#9;&#9;GearImage.Size = UDim2.new(0.75,0,0.75,0)
&#9;&#9;&#9;GearImage.ZIndex = 8
&#9;&#9;&#9;GearImage.Parent = GearPreview
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--GearImage Children
&#9;&#9;&#9;&#9;local GearIcons = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;GearIcons.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;GearIcons.BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;GearIcons.BorderSizePixel = 0
&#9;&#9;
&#9;&#9;&#9;&#9;GearIcons.Name = &quot;GearIcons&quot;
&#9;&#9;&#9;&#9;GearIcons.Position = UDim2.new(0.4,2,0.85,-2)
&#9;&#9;&#9;&#9;GearIcons.Size = UDim2.new(0.6,0,0.15,0)
&#9;&#9;&#9;&#9;GearIcons.Visible = false
&#9;&#9;&#9;&#9;GearIcons.ZIndex = 9
&#9;&#9;&#9;&#9;GearIcons.Parent = GearImage
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- GearIcons Children
&#9;&#9;&#9;&#9;&#9;local GenreImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;
&#9;&#9;&#9;&#9;&#9;GenreImage.Name = &quot;GenreImage&quot;
&#9;&#9;&#9;&#9;&#9;GenreImage.BackgroundColor3 = Color3.new(102/255,153/255,1)
&#9;&#9;&#9;&#9;&#9;GenreImage.BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;GenreImage.BorderSizePixel = 0
&#9;&#9;&#9;&#9;&#9;GenreImage.Size = UDim2.new(0.25,0,1,0)
&#9;&#9;&#9;&#9;&#9;GenreImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local AttributeOneImage = GenreImage:clone()
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.Name = &quot;AttributeOneImage&quot;
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.BackgroundColor3 = Color3.new(1,51/255,0)
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.Position = UDim2.new(0.25,0,0,0)
&#9;&#9;&#9;&#9;&#9;AttributeOneImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local AttributeTwoImage = GenreImage:clone()
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.Name = &quot;AttributeTwoImage&quot;
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.BackgroundColor3 = Color3.new(153/255,1,153/255)
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.Position = UDim2.new(0.5,0,0,0)
&#9;&#9;&#9;&#9;&#9;AttributeTwoImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local AttributeThreeImage = GenreImage:clone()
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.Name = &quot;AttributeThreeImage&quot;
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.BackgroundColor3 = Color3.new(0,0.5,0.5)
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.Position = UDim2.new(0.75,0,0,0)
&#9;&#9;&#9;&#9;&#9;AttributeThreeImage.Parent = GearIcons
&#9;&#9;&#9;&#9;&#9;
------------------------------- WARDROBE -------------------------------------------------------


&#9;
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with t.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with t.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end

--rbxsig%S02sfJuSM3Thz5hVIxyf9kDDENER9guz5nwJx/SfET0qAar5EDNQ6VJkwq7L45ZNfqVNd7IxhujzkgYff2V8ee5Mp5MfS9aEcztYGlWumULivAzynGfqkdVh+GzofuzUmMwWqPPsKqvQLiFe9MXMtCqe89S/Y9n6LZgrS1hyuqY=%
--fixed by iagoMAO --

-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local RbxGui,msg = t
if not RbxGui then print(&quot;could not find RbxGui!&quot;) return end

--- Begin Locals
waitForChild(game,&quot;Players&quot;)

-- don&apos;t do anything if we are in an empty game
if #game.Players:GetChildren() &lt; 1 then
&#9;game.Players.ChildAdded:wait()
end

local tilde = &quot;~&quot;
local backquote = &quot;`&quot;
game:GetService(&quot;GuiService&quot;):AddKey(tilde) -- register our keys
game:GetService(&quot;GuiService&quot;):AddKey(backquote)

local player = game.Players.LocalPlayer

local backpack = script.Parent.Backpack
local screen = script.Parent
local closeButton = backpack.Tabs.CloseButton

local openCloseDebounce = false

local backpackItems = {}

local buttons = {}

local debounce = false

local guiTweenSpeed = 1

local browsingMenu = false

local mouseEnterCons = {}
local mouseClickCons = {}

local characterChildAddedCon = nil
local characterChildRemovedCon = nil
local backpackAddCon = nil
local humanoidDiedCon = nil
local backpackButtonClickCon = nil
local guiServiceKeyPressCon = nil

waitForChild(player,&quot;Backpack&quot;)
local playerBackpack = player.Backpack

waitForChild(backpack,&quot;Gear&quot;)
waitForChild(backpack.Gear,&quot;GearPreview&quot;)
local gearPreview = backpack.Gear.GearPreview

waitForChild(backpack.Gear,&quot;GearGridScrollingArea&quot;)
local scroller = backpack.Gear.GearGridScrollingArea

waitForChild(backpack.Parent,&quot;CurrentLoadout&quot;)
local currentLoadout = backpack.Parent.CurrentLoadout

waitForChild(backpack.Parent,&quot;ControlFrame&quot;)
waitForChild(backpack.Parent.ControlFrame,&quot;BackpackButton&quot;)
local backpackButton = backpack.Parent.ControlFrame.BackpackButton

waitForChild(backpack.Gear,&quot;GearGrid&quot;)
waitForChild(backpack.Gear.GearGrid,&quot;GearButton&quot;)
local gearButton = backpack.Gear.GearGrid.GearButton
local grid = backpack.Gear.GearGrid

waitForChild(backpack.Gear.GearGrid,&quot;SearchFrame&quot;)
waitForChild(backpack.Gear.GearGrid.SearchFrame,&quot;SearchBoxFrame&quot;)
waitForChild(backpack.Gear.GearGrid.SearchFrame.SearchBoxFrame,&quot;SearchBox&quot;)
local searchBox = backpack.Gear.GearGrid.SearchFrame.SearchBoxFrame.SearchBox

waitForChild(backpack.Gear.GearGrid.SearchFrame,&quot;SearchButton&quot;)
local searchButton = backpack.Gear.GearGrid.SearchFrame.SearchButton

waitForChild(backpack.Gear.GearGrid,&quot;ResetFrame&quot;)
local resetFrame = backpack.Gear.GearGrid.ResetFrame

waitForChild(backpack.Gear.GearGrid.ResetFrame,&quot;ResetButtonBorder&quot;)
local resetButton = backpack.Gear.GearGrid.ResetFrame.ResetButtonBorder

waitForChild(script.Parent,&quot;SwapSlot&quot;)
local swapSlot = script.Parent.SwapSlot


-- creating scroll bar early as to make sure items get placed correctly
local scrollFrame, scrollUp, scrollDown, recalculateScroll = RbxGui.CreateScrollingFrame(nil,&quot;grid&quot;)

scrollFrame.Position = UDim2.new(0,0,0,30)
scrollFrame.Size = UDim2.new(1,0,1,-30)
scrollFrame.Parent = backpack.Gear.GearGrid

local scrollBar = Instance.new(&quot;Frame&quot;)
scrollBar.Name = &quot;ScrollBar&quot;
scrollBar.BackgroundTransparency = 0.9
scrollBar.BackgroundColor3 = Color3.new(1,1,1)
scrollBar.BorderSizePixel = 0
scrollBar.Size = UDim2.new(0, 17, 1, -36)
scrollBar.Position = UDim2.new(0,0,0,18)
scrollBar.Parent = scroller

scrollDown.Position = UDim2.new(0,0,1,-17)

scrollUp.Parent = scroller
scrollDown.Parent = scroller

local scrollFrameLoadout, scrollUpLoadout, scrollDownLoadout, recalculateScrollLoadout = RbxGui.CreateScrollingFrame()

scrollFrameLoadout.Position = UDim2.new(0,0,0,0)
scrollFrameLoadout.Size = UDim2.new(1,0,1,0)
scrollFrameLoadout.Parent = backpack.Gear.GearLoadouts.LoadoutsList

local LoadoutButton = Instance.new(&quot;TextButton&quot;)

LoadoutButton.Name = &quot;LoadoutButton&quot;
LoadoutButton.Font = Enum.Font.ArialBold
LoadoutButton.FontSize = Enum.FontSize.Size14
LoadoutButton.Position = UDim2.new(0,0,0,0)
LoadoutButton.Size = UDim2.new(1,0,0,32)
LoadoutButton.Style = Enum.ButtonStyle.RobloxButton
LoadoutButton.Text = &quot;Loadout #1&quot;
LoadoutButton.TextColor3 = Color3.new(1,1,1)
LoadoutButton.Parent = scrollFrameLoadout

local LoadoutButtonTwo = LoadoutButton:clone()
LoadoutButtonTwo.Text = &quot;Loadout #2&quot;
LoadoutButtonTwo.Parent = scrollFrameLoadout

local LoadoutButtonThree = LoadoutButton:clone()
LoadoutButtonThree.Text = &quot;Loadout #3&quot;
LoadoutButtonThree.Parent = scrollFrameLoadout

local LoadoutButtonFour = LoadoutButton:clone()
LoadoutButtonFour.Text = &quot;Loadout #4&quot;
LoadoutButtonFour.Parent = scrollFrameLoadout

local scrollBarLoadout = Instance.new(&quot;Frame&quot;)
scrollBarLoadout.Name = &quot;ScrollBarLoadout&quot;
scrollBarLoadout.BackgroundTransparency = 0.9
scrollBarLoadout.BackgroundColor3 = Color3.new(1,1,1)
scrollBarLoadout.BorderSizePixel = 0
scrollBarLoadout.Size = UDim2.new(0, 17, 1, -36)
scrollBarLoadout.Position = UDim2.new(0,0,0,18)
scrollBarLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea

scrollDownLoadout.Position = UDim2.new(0,0,1,-17)

scrollUpLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea
scrollDownLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea


-- Begin Functions
function removeFromMap(map,object)
&#9;for i = 1, #map do
&#9;&#9;if map[i] == object then
&#9;&#9;&#9;table.remove(map,i)
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
end


function resize()
&#9;local size = 0
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function addToGrid(child)
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then 
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end
&#9;
&#9;for i,v in pairs(backpackItems) do  -- check to see if we already have this gear registered
&#9;&#9;if v == child then return end
&#9;end

&#9;table.insert(backpackItems,child)
&#9;
&#9;local changeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if buttons[child] then
&#9;&#9;&#9;&#9;if buttons[child].Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttons[child].GearText.Text = child.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;local ancestryCon = nil
&#9;ancestryCon = child.AncestryChanged:connect(function(theChild,theParent)
&#9;&#9;local thisObject = nil
&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;if v == child then
&#9;&#9;&#9;&#9;thisObject = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player,&quot;Backpack&quot;)
&#9;&#9;if (child.Parent ~= player.Backpack and child.Parent ~= player.Character) then
&#9;&#9;&#9;if ancestryCon then ancestryCon:disconnect() end
&#9;&#9;&#9;if changeCon then changeCon:disconnect() end
&#9;&#9;&#9;
&#9;&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;&#9;if v == thisObject then
&#9;&#9;&#9;&#9;&#9;if mouseEnterCons[buttons[v]] then mouseEnterCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;if mouseClickCons[buttons[v]] then mouseClickCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;buttons[v].Parent = nil
&#9;&#9;&#9;&#9;&#9;buttons[v] = nil
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;removeFromMap(backpackItems,thisObject)
&#9;&#9;&#9;
&#9;&#9;&#9;resizeGrid()
&#9;&#9;else
&#9;&#9;&#9;resizeGrid()
&#9;&#9;end
&#9;&#9;updateGridActive()
&#9;end)
&#9;resizeGrid()
end

function buttonClick(button)
&#9;if button:FindFirstChild(&quot;UnequipContextMenu&quot;) and not button.Active then
&#9;&#9;button.UnequipContextMenu.Visible = true
&#9;&#9;browsingMenu = true
&#9;end
end

function previewGear(button)
&#9;if not browsingMenu then
&#9;&#9;gearPreview.GearImage.Image = button.Image
&#9;&#9;gearPreview.GearStats.GearName.Text = button.GearReference.Value.Name
&#9;end
end

function findEmptySlot()
&#9;local smallestNum = nil
&#9;local loadout = currentLoadout:GetChildren()
&#9;for i = 1, #loadout do
&#9;&#9;if loadout[i]:IsA(&quot;Frame&quot;) and #loadout[i]:GetChildren() &lt;= 0 then
&#9;&#9;&#9;local frameNum = tonumber(string.sub(loadout[i].Name,5))
&#9;&#9;&#9;if frameNum == 0 then frameNum = 10 end
&#9;&#9;&#9;if not smallestNum or (smallestNum &gt; frameNum) then
&#9;&#9;&#9;&#9;smallestNum = frameNum
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if smallestNum == 10 then smallestNum = 0 end
&#9;return smallestNum
end

function checkForSwap(button,x,y)
&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;&#9;if x &gt;= loadoutChildren[i].AbsolutePosition.x and x &lt;= (loadoutChildren[i].AbsolutePosition.x + loadoutChildren[i].AbsoluteSize.x) then
&#9;&#9;&#9;&#9;if y &gt;= loadoutChildren[i].AbsolutePosition.y and y &lt;= (loadoutChildren[i].AbsolutePosition.y + loadoutChildren[i].AbsoluteSize.y) then
&#9;&#9;&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,button)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function resizeGrid()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;local clickTime = tick()
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;local newClickTime = tick()
&#9;&#9;&#9;&#9;&#9;if buttonClone.Active and (newClickTime - clickTime) &lt; 0.5 then
&#9;&#9;&#9;&#9;&#9;&#9;local slot = findEmptySlot()
&#9;&#9;&#9;&#9;&#9;&#9;if slot then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,buttonClone)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;buttonClick(buttonClone)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;clickTime = newClickTime
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showPartialGrid(subset)

&#9;resetFrame.Visible = true

&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = nil
&#9;end
&#9;for k,v in pairs(subset) do
&#9;&#9;v.Parent =  grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function showEntireGrid()
&#9;resetFrame.Visible = false
&#9;
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function inLoadout(gear)
&#9;local children = currentLoadout:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local button = children[i]:GetChildren()
&#9;&#9;&#9;if #button &gt; 0 then
&#9;&#9;&#9;&#9;if button[1].GearReference.Value and button[1].GearReference.Value == gear then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end&#9;

function updateGridActive()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function centerGear(loadoutChildren)
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;table.insert(gearButtons, loadoutChildren[i])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1, #gearButtons do&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;end
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function openCloseBackpack(close)
&#9;if openCloseDebounce then return end
&#9;openCloseDebounce = true

&#9;local visible = not backpack.Visible
&#9;if visible and not close then
&#9;&#9;updateGridActive()
&#9;&#9;local centerDialogSupported, msg = pcall(function() game.GuiService:AddCenterDialog(backpack, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = true
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)
&#9;&#9;&#9;end,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = false
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;local children = backpack:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false
&#9;&#9;&#9;end)
&#9;else
&#9;&#9;backpackButton.Selected = false
&#9;&#9;local children = backpack:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;children[i].Visible = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;centerGear(loadoutChildren)
&#9;
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = visible
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(backpack) end)
&#9;&#9;&#9;&#9;openCloseDebounce = false
&#9;&#9;&#9;end)
&#9;end
end

function loadoutCheck(child, selectState)
&#9;if not child:IsA(&quot;ImageButton&quot;) then return end
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;if child:FindFirstChild(&quot;GearReference&quot;) and buttons[v]:FindFirstChild(&quot;GearReference&quot;) then
&#9;&#9;&#9;&#9;if buttons[v].GearReference.Value == child.GearReference.Value then
&#9;&#9;&#9;&#9;&#9;buttons[v].Active = selectState
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function clearPreview()
&#9;gearPreview.GearImage.Image = &quot;&quot;
&#9;gearPreview.GearStats.GearName.Text = &quot;&quot;
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;stuff[i].Parent = playerBackpack
&#9;&#9;end
&#9;end
end

function equipGear(physGear)
&#9;removeAllEquippedGear(physGear)
&#9;physGear.Parent = player.Character
&#9;updateGridActive()
end

function unequipGear(physGear)
&#9;physGear.Parent = playerBackpack
&#9;updateGridActive()
end

function highlight(button)
&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
end
function clearHighlight(button)
&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function swapGearSlot(slot,gearButton)
&#9;if not swapSlot.Value then -- signal loadout to swap a gear out
&#9;&#9;swapSlot.Slot.Value = slot
&#9;&#9;swapSlot.GearButton.Value = gearButton
&#9;&#9;swapSlot.Value = true
&#9;&#9;updateGridActive()
&#9;end
end


local UnequipGearMenuClick = function(element, menu)
&#9;if type(element.Action) ~= &quot;number&quot; then return end
&#9;local num = element.Action
&#9;if num == 1 then -- remove from loadout
&#9;&#9;unequipGear(menu.Parent.GearReference.Value)
&#9;&#9;local inventoryButton = menu.Parent
&#9;&#9;local gearToUnequip = inventoryButton.GearReference.Value
&#9;&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;local slot = -1
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;local button = loadoutChildren[i]:GetChildren()
&#9;&#9;&#9;&#9;if button[1] and button[1].GearReference.Value == gearToUnequip then
&#9;&#9;&#9;&#9;&#9;slot = button[1].SlotNumber.Text
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;swapGearSlot(slot,nil)
&#9;end
end

-- these next two functions are used to stop any use of backpack while the player is dead (can cause issues)
function activateBackpack()
&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
&#9;&#9;end
&#9;end

&#9;backpackButtonClickCon = backpackButton.MouseButton1Click:connect(function() openCloseBackpack() end)
&#9;guiServiceKeyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key)
&#9;&#9;if key == tilde or key == backquote then
&#9;&#9;&#9;openCloseBackpack()
&#9;&#9;end
&#9;end)
end
function deactivateBackpack()
&#9;if backpackButtonClickCon then backpackButtonClickCon:disconnect() end
&#9;if guiServiceKeyPressCon then guiServiceKeyPressCon:disconnect() end

&#9;openCloseBackpack(true)
end

function setupCharacterConnections()

&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;
&#9;-- make sure we get all the children
&#9;local backpackChildren = game.Players.LocalPlayer.Backpack:GetChildren()
&#9;for i = 1, #backpackChildren do
&#9;&#9;addToGrid(backpackChildren[i])
&#9;end

&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;characterChildAddedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addToGrid(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;characterChildRemovedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildRemoved:connect(function(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;&#9;&#9;
&#9;if humanoidDiedCon then humanoidDiedCon:disconnect() end
&#9;local localPlayer = game.Players.LocalPlayer
&#9;waitForProperty(localPlayer,&quot;Character&quot;)
&#9;waitForChild(localPlayer.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = game.Players.LocalPlayer.Character.Humanoid.Died:connect(function() deactivateBackpack() end)
&#9;
&#9;activateBackpack()

&#9;wait()
&#9;centerGear(currentLoadout:GetChildren())
end

function removeCharacterConnections()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;if backpackAddCon then backpackAddCon:disconnect() end
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function splitByWhiteSpace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 2 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end

function filterGear(searchTerm)
&#9;string.lower(searchTerm)
&#9;searchTerm = trim(searchTerm)
&#9;if string.len(searchTerm) &lt; 2 then return nil end
&#9;local terms = splitByWhiteSpace(searchTerm)
&#9;
&#9;local filteredGear = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gearString = string.lower(buttons[v].GearReference.Value.Name)
&#9;&#9;&#9;gearString = trim(gearString)
&#9;&#9;&#9;for i = 1, #terms do
&#9;&#9;&#9;&#9;if string.match(gearString,terms[i]) then
&#9;&#9;&#9;&#9;&#9;table.insert(filteredGear,buttons[v])
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return filteredGear
end


function showSearchGear()
&#9;local searchText = searchBox.Text
&#9;searchBox.Text = &quot;Search...&quot;
&#9;local filteredButtons = filterGear(searchText)
&#9;if filteredButtons and #filteredButtons &gt; 0 then
&#9;&#9;showPartialGrid(filteredButtons)
&#9;else
&#9;&#9;showEntireGrid()
&#9;end
end

function nukeBackpack()
&#9;while #buttons &gt; 0 do
&#9;&#9;table.remove(buttons)
&#9;end
&#9;buttons = {}
&#9;while #backpackItems &gt; 0 do
&#9;&#9;table.remove(backpackItems)
&#9;end
&#9;backpackItems = {}
&#9;local scrollingFrameChildren = grid.ScrollingFrame:GetChildren()
&#9;for i = 1, #scrollingFrameChildren do
&#9;&#9;scrollingFrameChildren[i]:remove()
&#9;end
end

function getGearContextMenu()
&#9;local gearContextMenu = Instance.new(&quot;Frame&quot;)
&#9;gearContextMenu.Active = true
&#9;gearContextMenu.Name = &quot;UnequipContextMenu&quot;
&#9;gearContextMenu.Size = UDim2.new(0,115,0,70)
&#9;gearContextMenu.Position = UDim2.new(0,-16,0,-16)
&#9;gearContextMenu.BackgroundTransparency = 1
&#9;gearContextMenu.Visible = false

&#9;local gearContextMenuButton = Instance.new(&quot;TextButton&quot;)
&#9;gearContextMenuButton.Name = &quot;UnequipContextMenuButton&quot;
&#9;gearContextMenuButton.Text = &quot;&quot;
&#9;gearContextMenuButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;gearContextMenuButton.ZIndex = 4
&#9;gearContextMenuButton.Size = UDim2.new(1, 0, 1, -20)
&#9;gearContextMenuButton.Visible = true
&#9;gearContextMenuButton.Parent = gearContextMenu
&#9;
&#9;local elementHeight = 12
&#9;
&#9;local contextMenuElements = {}&#9;&#9;
&#9;local contextMenuElementsName = {&quot;Remove Hotkey&quot;}

&#9;for i = 1, #contextMenuElementsName do
&#9;&#9;local element = {}
&#9;&#9;element.Type = &quot;Button&quot;
&#9;&#9;element.Text = contextMenuElementsName[i]
&#9;&#9;element.Action = i
&#9;&#9;element.DoIt = UnequipGearMenuClick
&#9;&#9;table.insert(contextMenuElements,element)
&#9;end

&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;local element = contextElement
&#9;&#9;if element.Type == &quot;Button&quot; then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = &quot;UnequipContextButton&quot; .. i
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;button.Text = &quot; &quot; .. contextElement.Text
&#9;&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;&#9;button.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;button.Size = UDim2.new(1, 8, 0, elementHeight)
&#9;&#9;&#9;button.Position = UDim2.new(0,0,0,elementHeight * i)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.ZIndex = 4
&#9;&#9;&#9;button.Parent = gearContextMenuButton

&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if button.Active and not gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;local success, result = pcall(function() element.DoIt(element, gearContextMenu) end)
&#9;&#9;&#9;&#9;&#9;browsingMenu = false
&#9;&#9;&#9;&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;&#9;clearPreview()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;highlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;contextElement.Button = button
&#9;&#9;&#9;contextElement.Element = button
&#9;&#9;elseif element.Type == &quot;Label&quot; then
&#9;&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;frame.Name = &quot;ContextLabel&quot; .. i
&#9;&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;&#9;frame.Size = UDim2.new(1, 8, 0, elementHeight)

&#9;&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;label.Name = &quot;Text1&quot;
&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;label.Position = UDim2.new(0.0, 0, 0, 0)
&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;element.Label1 = label
&#9;&#9;
&#9;&#9;&#9;if element.GetText2 then
&#9;&#9;&#9;&#9;label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;&#9;label.Name = &quot;Text2&quot;
&#9;&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;&#9;&#9;label.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;label.Position = UDim2.new(0.5, 0, 0, 0)
&#9;&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;&#9;element.Label2 = label
&#9;&#9;&#9;end
&#9;&#9;&#9;frame.Parent = gearContextMenuButton
&#9;&#9;&#9;element.Label = frame
&#9;&#9;&#9;element.Element =  frame
&#9;&#9;end
&#9;end

&#9;gearContextMenu.ZIndex = 4
&#9;gearContextMenu.MouseLeave:connect(function()
&#9;&#9;browsingMenu = false
&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;clearPreview()
&#9;end)
&#9;
&#9;
&#9;return gearContextMenu
end

local backpackChildren = player.Backpack:GetChildren()
for i = 1, #backpackChildren do
&#9;addToGrid(backpackChildren[i])
end

------------------------- Start Lifelong Connections -----------------------
screen.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;if debounce then return end
&#9;&#9;debounce = true
&#9;&#9;wait()
&#9;&#9;resize()
&#9;&#9;resizeGrid()
&#9;&#9;debounce = false
&#9;end
end)

currentLoadout.ChildAdded:connect(function(child) loadoutCheck(child, false) end)
currentLoadout.ChildRemoved:connect(function(child) loadoutCheck(child, true) end)

currentLoadout.DescendantAdded:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
currentLoadout.DescendantRemoving:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;wait()
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
&#9;
grid.MouseEnter:connect(function() clearPreview() end)
grid.MouseLeave:connect(function() clearPreview() end)

player.CharacterRemoving:connect(function()
&#9;removeCharacterConnections()
&#9;nukeBackpack()
end)
player.CharacterAdded:connect(function() setupCharacterConnections() end)

player.ChildAdded:connect(function(child)
&#9;if child:IsA(&quot;Backpack&quot;) then
&#9;&#9;playerBackpack = child
&#9;&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;end
end)

swapSlot.Changed:connect(function()
&#9;if not swapSlot.Value then
&#9;&#9;updateGridActive()
&#9;end
end)

searchBox.FocusLost:connect(function(enterPressed)
&#9;if enterPressed then
&#9;&#9;showSearchGear()
&#9;end
end)

local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;loadoutChildren[i].ChildRemoved:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;loadoutChildren[i].ChildAdded:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;end
end

pcall(function() closeButton.Modal = true end)
closeButton.MouseButton1Click:connect(function() openCloseBackpack() end)

searchButton.MouseButton1Click:connect(function() showSearchGear() end)
resetButton.MouseButton1Click:connect(function() showEntireGrid() end)
------------------------- End Lifelong Connections -----------------------

resize()
resizeGrid()

-- make sure any items in the loadout are accounted for in inventory
local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;loadoutCheck(loadoutChildren[i], false)
end
if not backpack.Visible then centerGear(currentLoadout:GetChildren()) end

-- make sure that inventory is listening to gear reparenting
if characterChildAddedCon == nil and game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;setupCharacterConnections()
end
if not backpackAddCon then
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
end

recalculateScrollLoadout()

print(&quot;Backpack has been built. Time for the resizer script.&quot;)
script.Parent.BackpackResizer.Parent = script.Parent.Backpack</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX35">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackScript</string>
					<ProtectedString name="Source">-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end





--- Begin Locals
waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local currentLoadout = script.Parent
local maxNumLoadoutItems = 10

local guiBackpack = currentLoadout.Backpack

local characterChildAddedCon = nil
local keyPressCon = nil
local backpackChildCon = nil

local debounce = script.Parent.CurrentLoadout.Debounce

local waitingOnEnlarge = nil

local enlargeFactor = 1.18
local buttonSizeEnlarge = UDim2.new(1 * enlargeFactor,0,1 * enlargeFactor,0)
local buttonSizeNormal = UDim2.new(1,0,1,0)
local enlargeOverride = true

local guiTweenSpeed = 0.5

for i = 0, 9 do
&#9;game:GetService(&quot;GuiService&quot;):AddKey(tostring(i)) -- register our keys
end

local gearSlots = {}
for i = 1, maxNumLoadoutItems do
&#9;gearSlots[i] = &quot;empty&quot;
end

local inventory = {}
--- End Locals






-- Begin Functions
local function kill(prop,con,gear)
&#9;if con then con:disconnect() end
&#9;if prop == true and gear then
&#9;&#9;reorganizeLoadout(gear,false)
&#9;end
end



function centerGear()
   
   local Loadout = script.Parent.CurrentLoadout
   Loadout.Position = UDim2.new(0.45, -170, 1, -85)
&#9;loadoutChildren = Loadout:GetChildren()
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1,#loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(gearButtons,loadoutChildren[i])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
         if script.Parent.Backpack.Visible == true then
         loadoutChildren[i].BackgroundTransparency = 0.5
         elseif script.Parent.Backpack.Visible == false then 
         loadoutChildren[i].BackgroundTransparency = 1
         end
         
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1,#gearButtons do&#9;&#9;&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.25,true)
&#9;end
end

function removeGear(gear)
&#9;local emptySlot = nil
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == gear and gear.Parent ~= nil then
&#9;&#9;&#9;emptySlot = i
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
&#9;if emptySlot then
&#9;&#9;if gearSlots[emptySlot].GearReference.Value then
&#9;&#9;&#9;if gearSlots[emptySlot].GearReference.Value.Parent == game.Players.LocalPlayer.Character then -- if we currently have this equipped, unequip it
&#9;&#9;&#9;&#9;gearSlots[emptySlot].GearReference.Value.Parent = game.Players.LocalPlayer.Backpack
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if gearSlots[emptySlot].GearReference.Value:IsA(&quot;HopperBin&quot;) and gearSlots[emptySlot].GearReference.Value.Active then -- this is an active hopperbin
&#9;&#9;&#9;&#9;gearSlots[emptySlot].GearReference.Value:Disable()
&#9;&#9;&#9;&#9;gearSlots[emptySlot].GearReference.Value.Active = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;gearSlots[emptySlot] = &quot;empty&quot;
&#9;


&#9;&#9;delay(guiTweenSpeed/2,
&#9;&#9;&#9;function()
            
&#9;&#9;&#9;&#9;gear:remove()
            if script.Parent.Backpack.Visible == false then
            centerGear()
            else
            gear:remove()
            end

&#9;&#9;&#9;end)
&#9;end
end

function insertGear(gear, addToSlot)
&#9;local pos = nil
&#9;if not addToSlot then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] == &quot;empty&quot; then
&#9;&#9;&#9;&#9;pos = i
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if pos == 1 and gearSlots[1] ~= &quot;empty&quot; then gear:remove() return end -- we are currently full, can&apos;t add in
&#9;else
&#9;&#9;pos = addToSlot
&#9;&#9;-- push all gear down one slot
&#9;&#9;local start = 1
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] == &quot;empty&quot; then
&#9;&#9;&#9;&#9;start = i
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for i = start, pos + 1, -1 do
&#9;&#9;&#9;gearSlots[i] = gearSlots[i - 1]
&#9;&#9;&#9;if i == 10 then
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumber.Text = &quot;0&quot;
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberDownShadow.Text = &quot;0&quot;
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberUpShadow.Text = &quot;0&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumber.Text = i
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberDownShadow.Text = i
&#9;&#9;&#9;&#9;gearSlots[i].SlotNumberUpShadow.Text = i
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;gearSlots[pos] = gear
&#9;if pos ~= maxNumLoadoutItems then
&#9;&#9;if(type(tostring(pos)) == &quot;string&quot;) then
&#9;&#9;&#9;local posString = tostring(pos) 
&#9;&#9;&#9;gear.SlotNumber.Text = posString
&#9;&#9;&#9;gear.SlotNumberDownShadow.Text = posString
&#9;&#9;&#9;gear.SlotNumberUpShadow.Text = posString
&#9;&#9;end
&#9;else -- tenth gear doesn&apos;t follow mathematical pattern :(
&#9;&#9;gear.SlotNumber.Text = &quot;0&quot;
&#9;&#9;gear.SlotNumberDownShadow.Text = &quot;0&quot;
&#9;&#9;gear.SlotNumberUpShadow.Text = &quot;0&quot;
&#9;end
&#9;gear.Visible = true

   if script.Parent.Backpack.Visible == false then
   centerGear()
   else
   return 
   end
&#9;local con = nil
&#9;con = gear.Kill.Changed:connect(function(prop) kill(prop,con,gear) end)
end


function reorganizeLoadout(gear, inserting, equipped, addToSlot)
&#9;if inserting then -- add in gear
&#9;&#9;insertGear(gear, addToSlot)
&#9;else
&#9;&#9;removeGear(gear)
&#9;end
&#9;if gear ~= &quot;empty&quot; then gear.ZIndex = 1 end
end

function checkToolAncestry(child,parent)
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end -- don&apos;t show roblox build tools
&#9;if child:IsA(&quot;Tool&quot;) or child:IsA(&quot;HopperBin&quot;) then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] ~= &quot;empty&quot; and gearSlots[i].GearReference.Value == child then
&#9;&#9;&#9;&#9;if parent == nil then 
&#9;&#9;&#9;&#9;&#9;gearSlots[i].Kill.Value = true
&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;elseif child.Parent == player.Character then
&#9;&#9;&#9;&#9;&#9;gearSlots[i].Selected = true
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;elseif child.Parent == player.Backpack then
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Tool&quot;) then gearSlots[i].Selected = false end
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;gearSlots[i].Kill.Value = true
&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;if stuff[i]:IsA(&quot;Tool&quot;) then stuff[i].Parent = player.Backpack end
&#9;&#9;&#9;if stuff[i]:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;stuff[i]:Disable()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function hopperBinSwitcher(numKey, physGear)
&#9;if not physGear then return end
&#9;
&#9;physGear:ToggleSelect()
&#9;
&#9;if gearSlots[numKey] == &quot;empty&quot; then return end
&#9;
&#9;if not physGear.Active then
&#9;&#9;gearSlots[numKey].Selected = false
&#9;&#9;normalizeButton(gearSlots[numKey])
&#9;else
&#9;&#9;gearSlots[numKey].Selected = true
&#9;&#9;enlargeButton(gearSlots[numKey])
&#9;end
end

function toolSwitcher(numKey)

&#9;if not gearSlots[numKey] then return end
&#9;local physGear = gearSlots[numKey].GearReference.Value
&#9;if physGear == nil then return end

&#9;removeAllEquippedGear(physGear) -- we don&apos;t remove this gear, as then we get a double switcheroo

&#9;local key = numKey
&#9;if numKey == 0 then key = 10 end
&#9;&#9;
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] and gearSlots[i] ~= &quot;empty&quot; and i ~= key then
&#9;&#9;&#9;normalizeButton(gearSlots[i])
&#9;&#9;&#9;gearSlots[i].Selected = false
&#9;&#9;&#9;if gearSlots[i].GearReference.Value:IsA(&quot;HopperBin&quot;) and gearSlots[i].GearReference.Value.Active then
&#9;&#9;&#9;&#9;gearSlots[i].GearReference.Value:ToggleSelect()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if physGear:IsA(&quot;HopperBin&quot;) then
&#9;&#9;hopperBinSwitcher(numKey,physGear)
&#9;else
&#9;&#9;if physGear.Parent == player.Character then
&#9;&#9;&#9;physGear.Parent = player.Backpack
&#9;&#9;&#9;gearSlots[numKey].Selected = false
&#9;&#9;&#9;
&#9;&#9;&#9;normalizeButton(gearSlots[numKey])
&#9;&#9;else
&#9;&#9;&#9;physGear.Parent = player.Character
&#9;&#9;&#9;gearSlots[numKey].Selected = true
&#9;&#9;&#9;
&#9;&#9;&#9;enlargeButton(gearSlots[numKey])
&#9;&#9;end
&#9;end
end


function activateGear(num)
&#9;local numKey = nil
&#9;if num == &quot;0&quot; then
&#9;&#9;numKey = 10 -- why do lua indexes have to start at 1? :(
&#9;else
&#9;&#9;numKey = tonumber(num)
&#9;end

&#9;if(numKey == nil) then return end

&#9;if gearSlots[numKey] ~= &quot;empty&quot; then
&#9;&#9;toolSwitcher(numKey)
&#9;end
end


enlargeButton = function(button)
&#9;if button.Size.Y.Scale &gt; 1 then return end
&#9;if not button.Parent then return end
&#9;if not button.Selected then return end

&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == &quot;empty&quot; then break end
&#9;&#9;if gearSlots[i] ~= button then
&#9;&#9;&#9;normalizeButton(gearSlots[i])
&#9;&#9;end
&#9;end
&#9;
&#9;if not enlargeOverride then
&#9;&#9;waitingOnEnlarge = button
&#9;&#9;return
&#9;end

&#9;if button:IsA(&quot;ImageButton&quot;) or button:IsA(&quot;TextButton&quot;) then
&#9;&#9;button.ZIndex = 2
&#9;&#9;local centerizeX = -(buttonSizeEnlarge.X.Scale - button.Size.X.Scale)/2
&#9;&#9;local centerizeY = -(buttonSizeEnlarge.Y.Scale - button.Size.Y.Scale)/2
&#9;&#9;button:TweenSizeAndPosition(buttonSizeEnlarge,
&#9;&#9;&#9;UDim2.new(button.Position.X.Scale + centerizeX,button.Position.X.Offset,button.Position.Y.Scale + centerizeY,button.Position.Y.Offset),
&#9;&#9;&#9;Enum.EasingDirection.Out, Enum.EasingStyle.Quad,guiTweenSpeed/5,enlargeOverride)
&#9;end
end

normalizeAllButtons = function()
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == &quot;empty&quot; then break end
&#9;&#9;if gearSlots[i] ~= button then
&#9;&#9;&#9;normalizeButton(gearSlots[i],0.1)
&#9;&#9;end
&#9;end
end


normalizeButton = function(button, speed)
&#9;if not button then return end
&#9;if button.Size.Y.Scale &lt;= 1 then return end
&#9;if button.Selected then return end
&#9;if not button.Parent then return end
&#9;
&#9;local moveSpeed = speed
&#9;if moveSpeed == nil or type(moveSpeed) ~= &quot;number&quot; then moveSpeed = guiTweenSpeed/5 end

&#9;if button:IsA(&quot;ImageButton&quot;) or button:IsA(&quot;TextButton&quot;) then
&#9;&#9;button.ZIndex = 1
&#9;&#9;local inverseEnlarge = 1/enlargeFactor
&#9;&#9;local centerizeX = -(buttonSizeNormal.X.Scale - button.Size.X.Scale)/2
&#9;&#9;local centerizeY = -(buttonSizeNormal.Y.Scale - button.Size.Y.Scale)/2
&#9;&#9;button:TweenSizeAndPosition(buttonSizeNormal,
&#9;&#9;&#9;UDim2.new(button.Position.X.Scale + centerizeX,button.Position.X.Offset,button.Position.Y.Scale + centerizeY,button.Position.Y.Offset),
&#9;&#9;&#9;Enum.EasingDirection.Out, Enum.EasingStyle.Quad,moveSpeed,enlargeOverride)
&#9;end
end

waitForDebounce = function()
&#9;if debounce.Value then
&#9;&#9;debounce.Changed:wait()
&#9;end
end

function pointInRectangle(point,rectTopLeft,rectSize)
&#9;if point.x &gt; rectTopLeft.x and point.x &lt; (rectTopLeft.x + rectSize.x) then
&#9;&#9;if point.y &gt; rectTopLeft.y and point.y &lt; (rectTopLeft.y + rectSize.y) then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

function swapGear(gearClone,toFrame)
&#9;local toFrameChildren = toFrame:GetChildren()
&#9;if #toFrameChildren == 1 then
&#9;&#9;if toFrameChildren[1]:FindFirstChild(&quot;SlotNumber&quot;) then
&#9;&#9;
&#9;&#9;&#9;local toSlot = tonumber(toFrameChildren[1].SlotNumber.Text)
&#9;&#9;&#9;local gearCloneSlot = tonumber(gearClone.SlotNumber.Text)
&#9;&#9;&#9;if toSlot == 0 then toSlot = 10 end
&#9;&#9;&#9;if gearCloneSlot == 0 then gearCloneSlot = 10 end
&#9;&#9;&#9;
&#9;&#9;&#9;gearSlots[toSlot] = gearClone
&#9;&#9;&#9;gearSlots[gearCloneSlot] = toFrameChildren[1]
&#9;&#9;&#9;
&#9;&#9;&#9;toFrameChildren[1].SlotNumber.Text = gearClone.SlotNumber.Text
&#9;&#9;&#9;toFrameChildren[1].SlotNumberDownShadow.Text = gearClone.SlotNumber.Text
&#9;&#9;&#9;toFrameChildren[1].SlotNumberUpShadow.Text = gearClone.SlotNumber.Text
&#9;&#9;&#9;
&#9;&#9;&#9;local subString = string.sub(toFrame.Name,5)
&#9;&#9;&#9;gearClone.SlotNumber.Text = subString
&#9;&#9;&#9;gearClone.SlotNumberDownShadow.Text = subString
&#9;&#9;&#9;gearClone.SlotNumberUpShadow.Text = subString
&#9;&#9;&#9;
&#9;&#9;&#9;gearClone.Position = UDim2.new(gearClone.Position.X.Scale,0,gearClone.Position.Y.Scale,0)
&#9;&#9;&#9;toFrameChildren[1].Position = UDim2.new(toFrameChildren[1].Position.X.Scale,0,toFrameChildren[1].Position.Y.Scale,0)
&#9;&#9;&#9;
&#9;&#9;&#9;toFrameChildren[1].Parent = gearClone.Parent
&#9;&#9;&#9;gearClone.Parent = toFrame
&#9;&#9;end
&#9;else
&#9;&#9;local slotNum = tonumber(gearClone.SlotNumber.Text)
&#9;&#9;if slotNum == 0 then slotNum = 10 end
&#9;&#9;gearSlots[slotNum] = &quot;empty&quot; -- reset this gear slot
&#9;&#9;
&#9;&#9;local subString = string.sub(toFrame.Name,5)
&#9;&#9;gearClone.SlotNumber.Text = subString
&#9;&#9;gearClone.SlotNumberDownShadow.Text = subString
&#9;&#9;gearClone.SlotNumberUpShadow.Text = subString
&#9;&#9;&#9;
&#9;&#9;local toSlotNum = tonumber(gearClone.SlotNumber.Text)
&#9;&#9;if toSlotNum == 0 then toSlotNum = 10 end
&#9;&#9;gearSlots[toSlotNum] = gearClone
&#9;&#9;gearClone.Position = UDim2.new(gearClone.Position.X.Scale,0,gearClone.Position.Y.Scale,0)
&#9;&#9;gearClone.Parent = toFrame
&#9;end
end

function resolveDrag(gearClone,x,y)
&#9;local mousePoint = Vector2.new(x,y)
&#9;
&#9;local frame = gearClone.Parent
&#9;local frames = frame.Parent:GetChildren()
&#9;
&#9;for i = 1, #frames do
&#9;&#9;if frames[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if pointInRectangle(mousePoint, frames[i].AbsolutePosition,frames[i].AbsoluteSize) then
&#9;&#9;&#9;&#9;swapGear(gearClone,frames[i])
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if x &lt; frame.AbsolutePosition.x or x &gt; ( frame.AbsolutePosition.x + frame.AbsoluteSize.x ) then
&#9;&#9;reorganizeLoadout(gearClone,false)
&#9;&#9;return false
&#9;elseif y &lt; frame.AbsolutePosition.y or y &gt; ( frame.AbsolutePosition.y + frame.AbsoluteSize.y ) then
&#9;&#9;reorganizeLoadout(gearClone,false)
&#9;&#9;return false
&#9;else
&#9;&#9;gearClone.Position = dragBeginPos
&#9;&#9;return -1
&#9;end
end

function unequipAllItems(dontEquipThis)
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] == &quot;empty&quot; then break end
&#9;&#9;if gearSlots[i].GearReference.Value ~= dontEquipThis then
&#9;&#9;&#9;if gearSlots[i].GearReference.Value:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;gearSlots[i].GearReference.Value:Disable()
&#9;&#9;&#9;elseif gearSlots[i].GearReference.Value:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;gearSlots[i].GearReference.Value.Parent = game.Players.LocalPlayer.Backpack
&#9;&#9;&#9;end
&#9;&#9;&#9;gearSlots[i].Selected = false
&#9;&#9;end
&#9;end
end

local addingPlayerChild = function(child, equipped, addToSlot, inventoryGearButton)
&#9;waitForDebounce()
&#9;debounce.Value = true
&#9;
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then debounce.Value = false return end -- don&apos;t show roblox build tools
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;debounce.Value = false 
&#9;&#9;&#9;return  -- we don&apos;t care about anything besides tools (sigh...)
&#9;&#9;end
&#9;end
&#9;
&#9;if not addToSlot then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] ~= &quot;empty&quot; and gearSlots[i].GearReference.Value == child then -- we already have gear, do nothing
&#9;&#9;&#9;&#9;debounce.Value = false
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;

&#9;local gearClone = currentLoadout.CurrentLoadout.TempSlot:clone()
&#9;gearClone.Name = child.Name
&#9;gearClone.GearImage.Image = child.TextureId
&#9;if gearClone.GearImage.Image == &quot;&quot; then
&#9;&#9;gearClone.GearText.Text = child.Name
&#9;end
&#9;gearClone.GearReference.Value = child

&#9;

&#9;local slotToMod = -1
&#9;
&#9;if not addToSlot then
&#9;&#9;for i = 1, #gearSlots do
&#9;&#9;&#9;if gearSlots[i] == &quot;empty&quot; then
&#9;&#9;&#9;&#9;slotToMod = i
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;slotToMod = addToSlot
&#9;end
&#9;
&#9;if slotToMod == - 1 then debounce.Value = false print(&quot;no slots!&quot;) return end -- No available slot to add in!
&#9;
&#9;local slotNum = slotToMod % 10
&#9;local parent = currentLoadout.CurrentLoadout:FindFirstChild(&quot;Slot&quot;..tostring(slotNum))
&#9;gearClone.Parent = parent
&#9;
&#9;if inventoryGearButton then
&#9;&#9;local absolutePositionFinal = inventoryGearButton.AbsolutePosition
&#9;&#9;local currentAbsolutePosition = gearClone.AbsolutePosition
&#9;&#9;local diff = absolutePositionFinal - currentAbsolutePosition
&#9;&#9;gearClone.Position = UDim2.new(gearClone.Position.X.Scale,diff.x,gearClone.Position.Y.Scale,diff.y)
&#9;&#9;gearClone.ZIndex = 4
&#9;end
&#9;
&#9;if addToSlot then
&#9;&#9;reorganizeLoadout(gearClone, true, equipped, addToSlot)
&#9;else
&#9;&#9;reorganizeLoadout(gearClone, true)
&#9;end

&#9;if gearClone.Parent == nil then debounce.Value = false return end -- couldn&apos;t fit in (hopper is full!)

&#9;if equipped then
&#9;&#9;gearClone.Selected = true
&#9;&#9;unequipAllItems(child)
&#9;&#9;delay(guiTweenSpeed + 0.01,function() -- if our gear is equipped, we will want to enlarge it when done moving
&#9;&#9;&#9;if (gearClone.GearReference.Value:IsA(&quot;Tool&quot;) and gearClone.GearReference.Value.Parent == player.Character) or
&#9;&#9;&#9;&#9;(gearClone.GearReference.Value:IsA(&quot;HopperBin&quot;) and gearClone.GearReference.Value.Active == true) then
&#9;&#9;&#9;&#9;&#9;enlargeButton(gearClone)
&#9;&#9;&#9;end
&#9;&#9;end) 
&#9;end

&#9;local dragBeginPos = nil
&#9;local clickCon, buttonDeleteCon, mouseEnterCon, mouseLeaveCon, dragStop, dragBegin = nil
&#9;clickCon = gearClone.MouseButton1Click:connect(function() if not gearClone.Draggable then activateGear(gearClone.SlotNumber.Text) end end)
&#9;mouseEnterCon = gearClone.MouseEnter:connect(function()
&#9;&#9;if guiBackpack.Visible then
&#9;&#9;&#9;gearClone.Draggable = true
&#9;&#9;end
&#9;end)
&#9;dragBegin = gearClone.DragBegin:connect(function(pos)
&#9;&#9;dragBeginPos = pos
&#9;&#9;gearClone.ZIndex = 7
&#9;&#9;local children = gearClone:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;TextLabel&quot;) then
&#9;&#9;&#9;&#9;if string.find(children[i].Name,&quot;Shadow&quot;) then
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 8
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 9
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif children[i]:IsA(&quot;Frame&quot;) or children[i]:IsA(&quot;ImageLabel&quot;) then
&#9;&#9;&#9;&#9; children[i].ZIndex = 7
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;dragStop = gearClone.DragStopped:connect(function(x,y)
&#9;&#9;if gearClone.Selected then
&#9;&#9;&#9;gearClone.ZIndex = 2
&#9;&#9;else
&#9;&#9;&#9;gearClone.ZIndex = 1
&#9;&#9;end
&#9;&#9;local children = gearClone:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;TextLabel&quot;) then
&#9;&#9;&#9;&#9;if string.find(children[i].Name,&quot;Shadow&quot;) then
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 3
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;children[i].ZIndex = 4
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif children[i]:IsA(&quot;Frame&quot;) or children[i]:IsA(&quot;ImageLabel&quot;) then
&#9;&#9;&#9;&#9; children[i].ZIndex = 2
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;resolveDrag(gearClone,x,y)
&#9;end)
&#9;mouseLeaveCon = gearClone.MouseLeave:connect(function()
&#9;&#9;gearClone.Draggable = false
&#9;end)
&#9;buttonDeleteCon = gearClone.AncestryChanged:connect(function()
&#9;&#9;&#9;if gearClone.Parent and gearClone.Parent.Parent == currentLoadout then return end
&#9;&#9;&#9;if clickCon then clickCon:disconnect() end
&#9;&#9;&#9;if buttonDeleteCon then buttonDeleteCon:disconnect() end
&#9;&#9;&#9;if mouseEnterCon then mouseEnterCon:disconnect() end
&#9;&#9;&#9;if mouseLeaveCon then mouseLeaveCon:disconnect() end
&#9;&#9;&#9;if dragStop then dragStop:disconnect() end
&#9;&#9;&#9;if dragBegin then dragBegin:disconnect() end
&#9;end) -- this probably isn&apos;t necessary since objects are being deleted (probably), but this might still leak just in case
&#9;
&#9;local childCon = nil
&#9;local childChangeCon = nil
&#9;childCon = child.AncestryChanged:connect(function(newChild,parent)
&#9;&#9;if not checkToolAncestry(newChild,parent) then
&#9;&#9;&#9;if childCon then childCon:disconnect() end
&#9;&#9;&#9;if childChangeCon then childChangeCon:disconnect() end
&#9;&#9;&#9;removeFromInventory(child)
&#9;&#9;elseif parent == game.Players.LocalPlayer.Backpack then
&#9;&#9;&#9;normalizeButton(gearClone)
&#9;&#9;end
&#9;end)
&#9;
&#9;childChangeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if gearClone and gearClone.GearImage.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;gearClone.GearText.Text = child.Name
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;
&#9;debounce.Value = false
&#9;
end

function addToInventory(child)
&#9;if not child:IsA(&quot;Tool&quot;) or not child:IsA(&quot;HopperBin&quot;) then return end
&#9;
&#9;local slot = nil
&#9;for i = 1, #inventory do
&#9;&#9;if inventory[i] and inventory[i] == child then return end
&#9;&#9;if not inventory[i] then slot = i end
&#9;end
&#9;if slot then 
&#9;&#9;inventory[slot] = child 
&#9;elseif #inventory &lt; 1 then
&#9;&#9;inventory[1] = child
&#9;else
&#9;&#9;inventory[#inventory + 1] = child
&#9;end
end

function removeFromInventory(child)
&#9;for i = 1, #inventory do
&#9;&#9;if inventory[i] == child then
&#9;&#9;&#9;table.remove(inventory,i)
&#9;&#9;&#9;inventory[i] = nil
&#9;&#9;end
&#9;end
end

-- these next two functions are used for safe guarding 
-- when we are waiting for character to come back after dying
function activateLoadout()
&#9;keyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key) activateGear(key) end)
&#9;currentLoadout.Visible = true
end

function deactivateLoadout()
&#9;if keyPressCon then keyPressCon:disconnect() end
&#9;currentLoadout.CurrentLoadout.Visible = false
end

function setupBackpackListener()
&#9;if backpackChildCon then backpackChildCon:disconnect() end
&#9;backpackChildCon = player.Backpack.ChildAdded:connect(function(child)
&#9;&#9;addingPlayerChild(child)
&#9;&#9;addToInventory(child)
&#9;end)
end

function playerCharacterChildAdded(child)
&#9;addingPlayerChild(child,true)
&#9;addToInventory(child)
end
-- End Functions






-- Begin Script
wait() -- let stuff initialize incase this is first heartbeat...
&#9;
waitForChild(player,&quot;Backpack&quot;)
local backpackChildren = player.Backpack:GetChildren()
local size = math.min(10,#backpackChildren)
for i = 1, size do
&#9;addingPlayerChild(backpackChildren[i],false)
end
setupBackpackListener()

waitForProperty(player,&quot;Character&quot;)
for i,v in ipairs(player.Character:GetChildren()) do
&#9;playerCharacterChildAdded(v)
end
characterChildAddedCon = player.Character.ChildAdded:connect(function(child) playerCharacterChildAdded(child) end)

waitForChild(player.Character,&quot;Humanoid&quot;)
humanoidDiedCon = player.Character.Humanoid.Died:connect(function() deactivateLoadout() end)

player.CharacterRemoving:connect(function()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if humanoidDiedCon then humanoidDiedCon:disconnect() end
&#9;if backpackChildCon then backpackChildCon:disconnect() end
&#9;deactivateLoadout()
end)
player.CharacterAdded:connect(function()
&#9;player = game.Players.LocalPlayer -- make sure we are still looking at the correct character
&#9;
&#9;for i = 1, #gearSlots do
&#9;&#9;if gearSlots[i] ~= &quot;empty&quot; then
&#9;&#9;&#9;gearSlots[i].Parent = nil
&#9;&#9;&#9;gearSlots[i] = &quot;empty&quot;
&#9;&#9;end
&#9;end

&#9;local backpackChildren = player.Backpack:GetChildren()
&#9;local size = math.min(10,#backpackChildren)
&#9;for i = 1, size do
&#9;&#9;addingPlayerChild(backpackChildren[i])
&#9;end
&#9;
&#9;setupBackpackListener()
&#9;
&#9;characterChildAddedCon = 
&#9;&#9;player.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addingPlayerChild(child,true)
&#9;&#9;end)
&#9;&#9;
&#9;waitForChild(player.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = 
&#9;&#9;player.Character.Humanoid.Died:connect(function()
&#9;&#9;&#9;deactivateLoadout()
&#9;&#9;end)
&#9;activateLoadout()
end)

script.Parent.ControlFrame.BackpackButton.MouseButton1Click:connect(function()
centerGear()
end)

waitForChild(guiBackpack,&quot;SwapSlot&quot;)
guiBackpack.SwapSlot.Changed:connect(function()
&#9;if guiBackpack.SwapSlot.Value then
&#9;&#9;local swapSlot = guiBackpack.SwapSlot
&#9;&#9;local pos = swapSlot.Slot.Value
&#9;&#9;if pos == 0 then pos = 10 end
&#9;&#9;if gearSlots[pos] then
&#9;&#9;&#9;reorganizeLoadout(gearSlots[pos],false)
&#9;&#9;end
&#9;&#9;if swapSlot.GearButton.Value then
&#9;&#9;&#9;addingPlayerChild(swapSlot.GearButton.Value.GearReference.Value,false,pos)
&#9;&#9;end
&#9;&#9;guiBackpack.SwapSlot.Value = false
&#9;end
end)

keyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key) activateGear(key) end)</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX36">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ControlFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="NotificationBox" referent="RBX37">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">NotificationBox</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-200</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0.419999987</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX38">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackMaker</string>
					<ProtectedString name="Source">local BackpackButton = Instance.new(&quot;ImageButton&quot;)
BackpackButton.Visible = true
BackpackButton.Name = &quot;BackpackButton&quot;
BackpackButton.BackgroundTransparency = 1
BackpackButton.Image = &quot;rbxasset://textures/ui/backpackButton.png&quot;
BackpackButton.Position = UDim2.new(0.5, -195, 1, -30)
BackpackButton.Size = UDim2.new(0,107,0,26)
BackpackButton.Parent = script.Parent.ControlFrame

-- this makes the backpackbutton without making the backpack D I  E --</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX39">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackManager</string>
					<ProtectedString name="Source">-- This script manages context switches in the backpack (Gear to Wardrobe, etc.) and player state changes.  Also manages global functions across different tabs (currently only search)
print(&quot;mamanger&quot;)
print(&quot;made it past gui version check&quot;)

-- basic functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
&#9;return instance:FindFirstChild(name)
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

-- don&apos;t do anything if we are in an empty game
waitForChild(game,&quot;Players&quot;)
if #game.Players:GetChildren() &lt; 1 then
&#9;game.Players.ChildAdded:wait()
end
-- make sure everything is loaded in before we do anything
-- get our local player
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer



------------------------ Locals ------------------------------
local backpack = script.Parent.Backpack
waitForChild(backpack,&quot;Gear&quot;)

local screen = script.Parent
assert(screen:IsA(&quot;ScreenGui&quot;))

waitForChild(backpack, &quot;Tabs&quot;)
waitForChild(backpack.Tabs, &quot;CloseButton&quot;)
local closeButton = backpack.Tabs.CloseButton

waitForChild(backpack.Tabs, &quot;InventoryButton&quot;)
local inventoryButton = backpack.Tabs.InventoryButton
waitForChild(backpack.Parent,&quot;ControlFrame&quot;)
local backpackButton = waitForChild(backpack.Parent.ControlFrame,&quot;BackpackButton&quot;)
local currentTab = &quot;gear&quot;

local searchFrame = waitForChild(backpack,&quot;SearchFrame&quot;)
waitForChild(backpack.SearchFrame,&quot;SearchBoxFrame&quot;)
local searchBox = waitForChild(backpack.SearchFrame.SearchBoxFrame,&quot;SearchBox&quot;)
local searchButton = waitForChild(backpack.SearchFrame,&quot;SearchButton&quot;)
local resetButton = waitForChild(backpack.SearchFrame,&quot;ResetButton&quot;)

local canToggle = true
local readyForNextEvent = true
local backpackIsOpen = false
local active = true

local humanoidDiedCon = nil

local guiTweenSpeed = 0.25 -- how quickly we open/close the backpack

local searchDefaultText = &quot;Search...&quot;
local tilde = &quot;~&quot;
local backquote = &quot;`&quot;

------------------------ End Locals ---------------------------


---------------------------------------- Public Event Setup ----------------------------------------

function createPublicEvent(eventName)
&#9;assert(eventName, &quot;eventName is nil&quot;)
&#9;assert(tostring(eventName),&quot;eventName is not a string&quot;)
&#9;
&#9;local newEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;newEvent.Name = tostring(eventName)
&#9;newEvent.Parent = script

&#9;return newEvent
end

function createPublicFunction(funcName, invokeFunc)
&#9;assert(funcName, &quot;funcName is nil&quot;)
&#9;assert(tostring(funcName), &quot;funcName is not a string&quot;)
&#9;assert(invokeFunc, &quot;invokeFunc is nil&quot;)
&#9;assert(type(invokeFunc) == &quot;function&quot;, &quot;invokeFunc should be of type &apos;function&apos;&quot;)
&#9;
&#9;local newFunction = Instance.new(&quot;BindableFunction&quot;)
&#9;newFunction.Name = tostring(funcName)
&#9;newFunction.OnInvoke = invokeFunc
&#9;newFunction.Parent = script

&#9;return newFunction
end

-- Events 
local resizeEvent = createPublicEvent(&quot;ResizeEvent&quot;)
local backpackOpenEvent = createPublicEvent(&quot;BackpackOpenEvent&quot;)
local backpackCloseEvent = createPublicEvent(&quot;BackpackCloseEvent&quot;)
local tabClickedEvent = createPublicEvent(&quot;TabClickedEvent&quot;)
local searchRequestedEvent = createPublicEvent(&quot;SearchRequestedEvent&quot;)
---------------------------------------- End Public Event Setup ----------------------------------------



--------------------------- Internal Functions ----------------------------------------

function deactivateBackpack()
&#9;backpack.Visible = false
&#9;active = false
end

function activateBackpack()
&#9;initHumanoidDiedConnections()&#9;&#9;
&#9;active = true
&#9;backpack.Visible = backpackIsOpen
end

function initHumanoidDiedConnections()&#9;&#9;&#9;
&#9;if humanoidDiedCon then 
&#9;&#9;humanoidDiedCon:disconnect()
&#9;end
&#9;waitForProperty(game.Players.LocalPlayer,&quot;Character&quot;)
&#9;waitForChild(game.Players.LocalPlayer.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = game.Players.LocalPlayer.Character.Humanoid.Died:connect(deactivateBackpack)
end

function resizeGrid()
   local backpackItems = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function() buttonClick(buttonClone) end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function resize()
&#9;local size = 0
   local gearPreview = script.Parent.Backpack.Gear.GearPreview
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function openCloseBackpack()
&#9;if backpack.Visible == true then
&#9;&#9;updateGridActive()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)

&#9;&#9;--[[backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()--]]
&#9;&#9;&#9;&#9;local children = backpack:getChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false


&#9;end
end

function centerGear()
   
   local Loadout = script.Parent.CurrentLoadout
   Loadout.Position = UDim2.new(0.45, -170, 1, -85)
&#9;loadoutChildren = Loadout:GetChildren()
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1,#loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(gearButtons,loadoutChildren[i])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
         
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1,#gearButtons do&#9;&#9;&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.25,true)
&#9;end
end

local hideBackpack = function()
&#9;backpackIsOpen = false
&#9;readyForNextEvent = false
&#9;backpackButton.Selected = false
&#9;resetSearch()
&#9;backpackCloseEvent:Fire(currentTab)
&#9;backpack.Tabs.Visible = false
&#9;searchFrame.Visible = false
   loadoutChildren = script.Parent.CurrentLoadout:GetChildren()
   for i = 1,#loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;if #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
   end
end

   loadoutChildren[i].BackgroundTransparency = 1
   centerGear()
   end
&#9;backpack:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed, true,
&#9;&#9;function()
&#9;&#9;&#9;game.GuiService:RemoveCenterDialog(backpack)
&#9;&#9;&#9;backpack.Visible = false
&#9;&#9;&#9;backpackButton.Selected = false
&#9;&#9;end)
&#9;delay(guiTweenSpeed,function()
&#9;&#9;game.GuiService:RemoveCenterDialog(backpack)
&#9;&#9;backpack.Visible = false
&#9;&#9;backpackButton.Selected = false
&#9;&#9;canToggle = true
&#9;end)
end

end

function showBackpack()
&#9;game.GuiService:AddCenterDialog(backpack, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;function()
&#9;&#9;&#9;backpack.Visible = true
&#9;&#9;&#9;backpackButton.Selected = true
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;backpack.Visible = false
&#9;&#9;&#9;backpackButton.Selected = false
&#9;end)
&#9;backpack.Visible = true
&#9;backpackButton.Selected = true
&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.76, 0),UDim2.new(0.225, 0, 0.09, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed, true)
&#9;delay(guiTweenSpeed,function()
      openCloseBackpack()
&#9;&#9;backpack.Tabs.Visible = true
&#9;&#9;searchFrame.Visible = true
&#9;&#9;backpackOpenEvent:Fire(currentTab)
&#9;&#9;canToggle = true
&#9;end)
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function toggleBackpack()
&#9;if not game.Players.LocalPlayer then return end
&#9;if not game.Players.LocalPlayer[&quot;Character&quot;] then return end

&#9;if not canToggle then return end
&#9;if not readyForNextEvent then return end
&#9;readyForNextEvent = false
&#9;canToggle = false
&#9;
&#9;backpackIsOpen = not backpackIsOpen

&#9;if backpackIsOpen then
      
&#9;&#9;showBackpack()
 
&#9;else
&#9;&#9;backpackButton.Selected = false
&#9;&#9;closeBackpack()
&#9;end
end

function updateGridActive()
   local backpackItems = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function openCloseBackpack()
&#9;
&#9;if backpack.Visible == true then
&#9;&#9;updateGridActive()
            local currentLoadout = script.Parent.CurrentLoadout
&#9;&#9;&#9;&#9;backpack.Visible = true
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)


&#9;&#9;backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;local children = backpack:getChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false
           end)

&#9;else
&#9;&#9;backpackButton.Selected = false
&#9;&#9;local children = backpack:getChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;children[i].Visible = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;centerGear(loadoutChildren)
&#9;
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;backpack.Visible = visible
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(backpack) end)
&#9;&#9;&#9;&#9;openCloseDebounce = false
&#9;&#9;&#9;end)
&#9;end
end

function closeBackpack()
&#9;if backpackIsOpen then
&#9;&#9;toggleBackpack()
&#9;end
end

function setSelected(tab)
&#9;assert(tab)
&#9;assert(tab:IsA(&quot;TextButton&quot;))
&#9;
&#9;tab.BackgroundColor3 = Color3.new(1,1,1)
&#9;tab.TextColor3 = Color3.new(0,0,0)
&#9;tab.Selected = true
&#9;tab.ZIndex = 3
end

function setUnselected(tab)
&#9;assert(tab)
&#9;assert(tab:IsA(&quot;TextButton&quot;))
&#9;
&#9;tab.BackgroundColor3 = Color3.new(0,0,0)
&#9;tab.TextColor3 = Color3.new(1,1,1)
&#9;tab.Selected = false
&#9;tab.ZIndex = 1
end

function updateTabGui(selectedTab)
&#9;assert(selectedTab)
&#9;
&#9;if selectedTab == &quot;gear&quot; then
&#9;&#9;setSelected(inventoryButton)
&#9;&#9;setUnselected(wardrobeButton)
&#9;elseif selectedTab == &quot;wardrobe&quot; then
&#9;&#9;setSelected(wardrobeButton)
&#9;&#9;setUnselected(inventoryButton)
&#9;end
end

function mouseLeaveTab(button)
&#9;assert(button)
&#9;assert(button:IsA(&quot;TextButton&quot;))
&#9;
&#9;if button.Selected then return end
&#9;
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function mouseOverTab(button)
&#9;assert(button)
&#9;assert(button:IsA(&quot;TextButton&quot;))
&#9;
&#9;if button.Selected then return end
&#9;
&#9;button.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
end

function newTabClicked(tabName)
&#9;assert(tabName)
&#9;tabName = string.lower(tabName)
&#9;currentTab = tabName
&#9;
&#9;updateTabGui(tabName)
&#9;tabClickedEvent:Fire(tabName)
&#9;resetSearch()
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function splitByWhitespace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 0 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end

function resetSearchBoxGui()
&#9;resetButton.Visible = false
&#9;searchBox.Text = searchDefaultText
end

function doSearch()
&#9;local searchText = searchBox.Text
&#9;if searchText == &quot;&quot; then
&#9;&#9;resetSearch()
&#9;&#9;return
&#9;end
&#9;searchText = trim(searchText)
&#9;resetButton.Visible = true
&#9;termTable = splitByWhitespace(searchText)
&#9;searchRequestedEvent:Fire(searchText) -- todo: replace this with termtable when table passing is possible
end

function resetSearch()
&#9;resetSearchBoxGui()
&#9;searchRequestedEvent:Fire()
end

local backpackReady = function()
&#9;readyForNextEvent = true
end

--------------------------- End Internal Functions -------------------------------------


------------------------------ Public Functions Setup -------------------------------------
createPublicFunction(&quot;CloseBackpack&quot;, hideBackpack)
createPublicFunction(&quot;BackpackReady&quot;, backpackReady)
------------------------------ End Public Functions Setup ---------------------------------


------------------------ Connections/Script Main -------------------------------------------

inventoryButton.MouseButton1Click:connect(function() newTabClicked(&quot;gear&quot;) end)
inventoryButton.MouseEnter:connect(function() mouseOverTab(inventoryButton) end)
inventoryButton.MouseLeave:connect(function() mouseLeaveTab(inventoryButton) end)


closeButton.MouseButton1Click:connect(hideBackpack)

screen.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;resizeEvent:Fire(screen.AbsoluteSize)
&#9;end
end)

-- GuiService key setup
local testkey = &quot;&apos;&quot;
game:GetService(&quot;GuiService&quot;):AddKey(testkey)
game:GetService(&quot;GuiService&quot;):AddKey(tilde)
game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key)
&#9;if not active then return end
&#9;if key == tilde or key == backquote then
&#9;&#9;toggleBackpack()
      showBackpack()
&#9;end
end)
backpackButton.MouseButton1Click:connect(function() 

toggleBackpack()
showBackpack()
--openCloseBackpack()

end)

if game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;activateBackpack()
end
game.Players.LocalPlayer.CharacterAdded:connect(activateBackpack)

-- search functions
searchBox.FocusLost:connect(function(enterPressed)
&#9;if enterPressed or searchBox.Text ~= &quot;&quot; then
&#9;&#9;doSearch()
&#9;elseif searchBox.Text == &quot;&quot; then
&#9;&#9;resetSearch()
&#9;end
end)
searchButton.MouseButton1Click:connect(doSearch)
resetButton.MouseButton1Click:connect(resetSearch)

backpackButton.Visible = true</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX40">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackGear</string>
					<ProtectedString name="Source">local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end
&#9;
-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;assert(instance)
&#9;assert(name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
&#9;return instance:FindFirstChild(name)
end
local function waitForProperty(instance, property)
&#9;assert(instance)
&#9;assert(property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local RbxGui, msg = t
if not RbxGui then print(&quot;could not find RbxGui!&quot;) return end

--- Begin Locals
local StaticTabName = &quot;gear&quot;

local backpack = script.Parent.Backpack
local screen = script.Parent

local backpackItems = {}
local buttons = {}

local debounce = false
local browsingMenu = false

local mouseEnterCons = {}
local mouseClickCons = {}

local characterChildAddedCon = nil
local characterChildRemovedCon = nil
local backpackAddCon = nil

local playerBackpack = waitForChild(player,&quot;Backpack&quot;)

waitForChild(backpack,&quot;Tabs&quot;)

waitForChild(backpack,&quot;Gear&quot;)
local gearPreview = waitForChild(backpack.Gear,&quot;GearPreview&quot;)

local scroller = waitForChild(backpack.Gear,&quot;GearGridScrollingArea&quot;)

local currentLoadout = waitForChild(backpack.Parent,&quot;CurrentLoadout&quot;)

local grid = waitForChild(backpack.Gear,&quot;GearGrid&quot;)
local gearButton = waitForChild(grid,&quot;GearButton&quot;)

local swapSlot = waitForChild(script.Parent,&quot;SwapSlot&quot;)

local backpackManager = waitForChild(script.Parent,&quot;CoreScripts/BackpackScripts/BackpackManager&quot;)
local backpackOpenEvent = waitForChild(backpackManager,&quot;BackpackOpenEvent&quot;)
local backpackCloseEvent = waitForChild(backpackManager,&quot;BackpackCloseEvent&quot;)
local tabClickedEvent = waitForChild(backpackManager,&quot;TabClickedEvent&quot;)
local resizeEvent = waitForChild(backpackManager,&quot;ResizeEvent&quot;)
local searchRequestedEvent = waitForChild(backpackManager,&quot;SearchRequestedEvent&quot;)
local tellBackpackReadyFunc = waitForChild(backpackManager,&quot;BackpackReady&quot;)

-- creating scroll bar early as to make sure items get placed correctly
local scrollFrame, scrollUp, scrollDown, recalculateScroll = RbxGui.CreateScrollingFrame(nil,&quot;grid&quot;)

scrollFrame.Position = UDim2.new(0,0,0,30)
scrollFrame.Size = UDim2.new(1,0,1,-30)
scrollFrame.Parent = backpack.Gear.GearGrid

local scrollBar = Instance.new(&quot;Frame&quot;)
scrollBar.Name = &quot;ScrollBar&quot;
scrollBar.BackgroundTransparency = 0.9
scrollBar.BackgroundColor3 = Color3.new(1,1,1)
scrollBar.BorderSizePixel = 0
scrollBar.Size = UDim2.new(0, 17, 1, -36)
scrollBar.Position = UDim2.new(0,0,0,18)
scrollBar.Parent = scroller

scrollDown.Position = UDim2.new(0,0,1,-17)

scrollUp.Parent = scroller
scrollDown.Parent = scroller

local scrollFrameLoadout, scrollUpLoadout, scrollDownLoadout, recalculateScrollLoadout = RbxGui.CreateScrollingFrame()

scrollFrameLoadout.Position = UDim2.new(0,0,0,0)
scrollFrameLoadout.Size = UDim2.new(1,0,1,0)
scrollFrameLoadout.Parent = backpack.Gear.GearLoadouts.LoadoutsList

local LoadoutButton = Instance.new(&quot;TextButton&quot;)

LoadoutButton.Name = &quot;LoadoutButton&quot;
LoadoutButton.Font = Enum.Font.ArialBold
LoadoutButton.FontSize = Enum.FontSize.Size14
LoadoutButton.Position = UDim2.new(0,0,0,0)
LoadoutButton.Size = UDim2.new(1,0,0,32)
LoadoutButton.Style = Enum.ButtonStyle.RobloxButton
LoadoutButton.Text = &quot;Loadout #1&quot;
LoadoutButton.TextColor3 = Color3.new(1,1,1)
LoadoutButton.Parent = scrollFrameLoadout

local LoadoutButtonTwo = LoadoutButton:clone()
LoadoutButtonTwo.Text = &quot;Loadout #2&quot;
LoadoutButtonTwo.Parent = scrollFrameLoadout

local LoadoutButtonThree = LoadoutButton:clone()
LoadoutButtonThree.Text = &quot;Loadout #3&quot;
LoadoutButtonThree.Parent = scrollFrameLoadout

local LoadoutButtonFour = LoadoutButton:clone()
LoadoutButtonFour.Text = &quot;Loadout #4&quot;
LoadoutButtonFour.Parent = scrollFrameLoadout

local scrollBarLoadout = Instance.new(&quot;Frame&quot;)
scrollBarLoadout.Name = &quot;ScrollBarLoadout&quot;
scrollBarLoadout.BackgroundTransparency = 0.9
scrollBarLoadout.BackgroundColor3 = Color3.new(1,1,1)
scrollBarLoadout.BorderSizePixel = 0
scrollBarLoadout.Size = UDim2.new(0, 17, 1, -36)
scrollBarLoadout.Position = UDim2.new(0,0,0,18)
scrollBarLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea

scrollDownLoadout.Position = UDim2.new(0,0,1,-17)

scrollUpLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea
scrollDownLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea


-- Begin Functions
function removeFromMap(map,object)
&#9;for i = 1, #map do
&#9;&#9;if map[i] == object then
&#9;&#9;&#9;table.remove(map,i)
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
end

function robloxLock(instance)
end

function resize()
&#9;local size = 0
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;waitForChild(gearPreview,&quot;GearImage&quot;)
&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function addToGrid(child)
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then 
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end
&#9;
&#9;for i,v in pairs(backpackItems) do  -- check to see if we already have this gear registered
&#9;&#9;if v == child then return end
&#9;end

&#9;table.insert(backpackItems,child)
&#9;
&#9;local changeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if buttons[child] then
&#9;&#9;&#9;&#9;if buttons[child].Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttons[child].GearText.Text = child.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;local ancestryCon = nil
&#9;ancestryCon = child.AncestryChanged:connect(function(theChild,theParent)
&#9;&#9;local thisObject = nil
&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;if v == child then
&#9;&#9;&#9;&#9;thisObject = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player,&quot;Backpack&quot;)
&#9;&#9;if (child.Parent ~= player.Backpack and child.Parent ~= player.Character) then
&#9;&#9;&#9;if ancestryCon then ancestryCon:disconnect() end
&#9;&#9;&#9;if changeCon then changeCon:disconnect() end
&#9;&#9;&#9;
&#9;&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;&#9;if v == thisObject then
&#9;&#9;&#9;&#9;&#9;if mouseEnterCons[buttons[v]] then mouseEnterCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;if mouseClickCons[buttons[v]] then mouseClickCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;buttons[v].Parent = nil
&#9;&#9;&#9;&#9;&#9;buttons[v] = nil
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;removeFromMap(backpackItems,thisObject)
&#9;&#9;&#9;
&#9;&#9;&#9;resizeGrid()
&#9;&#9;else
&#9;&#9;&#9;resizeGrid()
&#9;&#9;end
&#9;&#9;updateGridActive()
&#9;end)
&#9;resizeGrid()
end

function buttonClick(button)
&#9;if button:FindFirstChild(&quot;UnequipContextMenu&quot;) and not button.Active then
&#9;&#9;button.UnequipContextMenu.Visible = true
&#9;&#9;browsingMenu = true
&#9;end
end

function previewGear(button)
&#9;if not browsingMenu then
&#9;&#9;gearPreview.GearImage.Image = button.Image
&#9;&#9;gearPreview.GearStats.GearName.Text = button.GearReference.Value.Name
&#9;end
end

function findEmptySlot()
&#9;local smallestNum = nil
&#9;local loadout = currentLoadout:GetChildren()
&#9;for i = 1, #loadout do
&#9;&#9;if loadout[i]:IsA(&quot;Frame&quot;) and #loadout[i]:GetChildren() &lt;= 0 then
&#9;&#9;&#9;local frameNum = tonumber(string.sub(loadout[i].Name,5))
&#9;&#9;&#9;if frameNum == 0 then frameNum = 10 end
&#9;&#9;&#9;if not smallestNum or (smallestNum &gt; frameNum) then
&#9;&#9;&#9;&#9;smallestNum = frameNum
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if smallestNum == 10 then smallestNum = 0 end
&#9;return smallestNum
end

function checkForSwap(button,x,y)
&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;&#9;if x &gt;= loadoutChildren[i].AbsolutePosition.x and x &lt;= (loadoutChildren[i].AbsolutePosition.x + loadoutChildren[i].AbsoluteSize.x) then
&#9;&#9;&#9;&#9;if y &gt;= loadoutChildren[i].AbsolutePosition.y and y &lt;= (loadoutChildren[i].AbsolutePosition.y + loadoutChildren[i].AbsoluteSize.y) then
&#9;&#9;&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,button)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function resizeGrid()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Draggable = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;local clickTime = tick()
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;local newClickTime = tick()
&#9;&#9;&#9;&#9;&#9;if buttonClone.Active and (newClickTime - clickTime) &lt; 0.5 then
&#9;&#9;&#9;&#9;&#9;&#9;local slot = findEmptySlot()
&#9;&#9;&#9;&#9;&#9;&#9;if slot then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,buttonClone)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;buttonClick(buttonClone)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;clickTime = newClickTime
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showPartialGrid(subset)
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = nil
&#9;end
&#9;if subset then
&#9;&#9;for k,v in pairs(subset) do
&#9;&#9;&#9;v.Parent =  grid.ScrollingFrame
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showEntireGrid()
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function inLoadout(gear)
&#9;local children = currentLoadout:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local button = children[i]:GetChildren()
&#9;&#9;&#9;if #button &gt; 0 then
&#9;&#9;&#9;&#9;if button[1].GearReference.Value and button[1].GearReference.Value == gear then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end&#9;

function updateGridActive()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function centerGear(loadoutChildren)
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;table.insert(gearButtons, loadoutChildren[i])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1, #gearButtons do&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;end
end

function tabClickHandler(tabName)
&#9;if tabName == StaticTabName then
&#9;&#9;backpackOpenHandler(tabName)
&#9;else
&#9;&#9;backpackCloseHandler(tabName)
&#9;end
end

function backpackOpenHandler(currentTab)
&#9;if currentTab and currentTab ~= StaticTabName then 
&#9;&#9;backpack.Gear.Visible = false
&#9;&#9;return
&#9;end
&#9;
&#9;backpack.Gear.Visible = true
&#9;updateGridActive()

&#9;resizeGrid()
&#9;resize()
&#9;tellBackpackReadyFunc:Invoke()
end

function backpackCloseHandler(currentTab)
&#9;if currentTab and currentTab ~= StaticTabName then
&#9;&#9;backpack.Gear.Visible = false
&#9;&#9;return
&#9;end
&#9;
&#9;backpack.Gear.Visible = false

&#9;resizeGrid()
&#9;resize()
&#9;tellBackpackReadyFunc:Invoke()
end

function loadoutCheck(child, selectState)
&#9;if not child:IsA(&quot;ImageButton&quot;) then return end
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;if child:FindFirstChild(&quot;GearReference&quot;) and buttons[v]:FindFirstChild(&quot;GearReference&quot;) then
&#9;&#9;&#9;&#9;if buttons[v].GearReference.Value == child.GearReference.Value then
&#9;&#9;&#9;&#9;&#9;buttons[v].Active = selectState
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function clearPreview()
&#9;gearPreview.GearImage.Image = &quot;&quot;
&#9;gearPreview.GearStats.GearName.Text = &quot;&quot;
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;stuff[i].Parent = playerBackpack
&#9;&#9;end
&#9;end
end

function equipGear(physGear)
&#9;removeAllEquippedGear(physGear)
&#9;physGear.Parent = player.Character
&#9;updateGridActive()
end

function unequipGear(physGear)
&#9;physGear.Parent = playerBackpack
&#9;updateGridActive()
end

function highlight(button)
&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
end
function clearHighlight(button)
&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function swapGearSlot(slot,gearButton)
&#9;if not swapSlot.Value then -- signal loadout to swap a gear out
&#9;&#9;swapSlot.Slot.Value = slot
&#9;&#9;swapSlot.GearButton.Value = gearButton
&#9;&#9;swapSlot.Value = true
&#9;&#9;updateGridActive()
&#9;end
end


local UnequipGearMenuClick = function(element, menu)
&#9;if type(element.Action) ~= &quot;number&quot; then return end
&#9;local num = element.Action
&#9;if num == 1 then -- remove from loadout
&#9;&#9;unequipGear(menu.Parent.GearReference.Value)
&#9;&#9;local inventoryButton = menu.Parent
&#9;&#9;local gearToUnequip = inventoryButton.GearReference.Value
&#9;&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;local slot = -1
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;local button = loadoutChildren[i]:GetChildren()
&#9;&#9;&#9;&#9;if button[1] and button[1].GearReference.Value == gearToUnequip then
&#9;&#9;&#9;&#9;&#9;slot = button[1].SlotNumber.Text
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;swapGearSlot(slot,nil)
&#9;end
end

function setupCharacterConnections()

&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;
&#9;-- make sure we get all the children
&#9;local backpackChildren = game.Players.LocalPlayer.Backpack:GetChildren()
&#9;for i = 1, #backpackChildren do
&#9;&#9;addToGrid(backpackChildren[i])
&#9;end

&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;characterChildAddedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addToGrid(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;characterChildRemovedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildRemoved:connect(function(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)

&#9;wait()
&#9;centerGear(currentLoadout:GetChildren())
end

function removeCharacterConnections()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;if backpackAddCon then backpackAddCon:disconnect() end
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function filterGear(terms)
&#9;local filteredGear = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gearString = string.lower(buttons[v].GearReference.Value.Name)
&#9;&#9;&#9;gearString = trim(gearString)
&#9;&#9;&#9;for i = 1, #terms do
&#9;&#9;&#9;&#9;if string.match(gearString,terms[i]) then
&#9;&#9;&#9;&#9;&#9;table.insert(filteredGear,buttons[v])
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return filteredGear
end
function splitByWhitespace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 0 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end
function showSearchGear(searchTerms)
&#9;if not backpack.Gear.Visible then return end -- currently not active tab

&#9;local searchTermTable = splitByWhitespace(searchTerms)
&#9;if searchTermTable and (#searchTermTable &gt; 0) then
&#9;&#9;currSearchTerms = searchTermTable
&#9;else
&#9;&#9;currSearchTerms = nil
&#9;end

&#9;if searchTermTable == nil then
&#9;&#9;showEntireGrid()
&#9;&#9;return
&#9;end

&#9;local filteredButtons = filterGear(currSearchTerms)
&#9;showPartialGrid(filteredButtons)
end

function nukeBackpack()
&#9;while #buttons &gt; 0 do
&#9;&#9;table.remove(buttons)
&#9;end
&#9;buttons = {}
&#9;while #backpackItems &gt; 0 do
&#9;&#9;table.remove(backpackItems)
&#9;end
&#9;backpackItems = {}
&#9;local scrollingFrameChildren = grid.ScrollingFrame:GetChildren()
&#9;for i = 1, #scrollingFrameChildren do
&#9;&#9;scrollingFrameChildren[i]:remove()
&#9;end
end

function getGearContextMenu()
&#9;local gearContextMenu = Instance.new(&quot;Frame&quot;)
&#9;gearContextMenu.Active = true
&#9;gearContextMenu.Name = &quot;UnequipContextMenu&quot;
&#9;gearContextMenu.Size = UDim2.new(0,115,0,70)
&#9;gearContextMenu.Position = UDim2.new(0,-16,0,-16)
&#9;gearContextMenu.BackgroundTransparency = 1
&#9;gearContextMenu.Visible = false

&#9;local gearContextMenuButton = Instance.new(&quot;TextButton&quot;)
&#9;gearContextMenuButton.Name = &quot;UnequipContextMenuButton&quot;
&#9;gearContextMenuButton.Text = &quot;&quot;
&#9;gearContextMenuButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;gearContextMenuButton.ZIndex = 8
&#9;gearContextMenuButton.Size = UDim2.new(1, 0, 1, -20)
&#9;gearContextMenuButton.Visible = true
&#9;gearContextMenuButton.Parent = gearContextMenu
&#9;
&#9;local elementHeight = 12
&#9;
&#9;local contextMenuElements = {}&#9;&#9;
&#9;local contextMenuElementsName = {&quot;Remove Hotkey&quot;}

&#9;for i = 1, #contextMenuElementsName do
&#9;&#9;local element = {}
&#9;&#9;element.Type = &quot;Button&quot;
&#9;&#9;element.Text = contextMenuElementsName[i]
&#9;&#9;element.Action = i
&#9;&#9;element.DoIt = UnequipGearMenuClick
&#9;&#9;table.insert(contextMenuElements,element)
&#9;end

&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;local element = contextElement
&#9;&#9;if element.Type == &quot;Button&quot; then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = &quot;UnequipContextButton&quot; .. i
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;button.Text = &quot; &quot; .. contextElement.Text
&#9;&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;&#9;button.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;button.Size = UDim2.new(1, 8, 0, elementHeight)
&#9;&#9;&#9;button.Position = UDim2.new(0,0,0,elementHeight * i)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.ZIndex = 9
&#9;&#9;&#9;button.Parent = gearContextMenuButton

&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if button.Active and not gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;local success, result = pcall(function() element.DoIt(element, gearContextMenu) end)
&#9;&#9;&#9;&#9;&#9;browsingMenu = false
&#9;&#9;&#9;&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;&#9;clearPreview()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;highlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;contextElement.Button = button
&#9;&#9;&#9;contextElement.Element = button
&#9;&#9;elseif element.Type == &quot;Label&quot; then
&#9;&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;frame.Name = &quot;ContextLabel&quot; .. i
&#9;&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;&#9;frame.Size = UDim2.new(1, 8, 0, elementHeight)

&#9;&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;label.Name = &quot;Text1&quot;
&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;label.Position = UDim2.new(0.0, 0, 0, 0)
&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.ZIndex = 9
&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;element.Label1 = label
&#9;&#9;
&#9;&#9;&#9;if element.GetText2 then
&#9;&#9;&#9;&#9;label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;&#9;label.Name = &quot;Text2&quot;
&#9;&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;&#9;&#9;label.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;label.Position = UDim2.new(0.5, 0, 0, 0)
&#9;&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.ZIndex = 9
&#9;&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;&#9;element.Label2 = label
&#9;&#9;&#9;end
&#9;&#9;&#9;frame.Parent = gearContextMenuButton
&#9;&#9;&#9;element.Label = frame
&#9;&#9;&#9;element.Element =  frame
&#9;&#9;end
&#9;end

&#9;gearContextMenu.ZIndex = 4
&#9;gearContextMenu.MouseLeave:connect(function()
&#9;&#9;browsingMenu = false
&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;clearPreview()
&#9;end)

&#9;
&#9;return gearContextMenu
end

local backpackChildren = player.Backpack:GetChildren()
for i = 1, #backpackChildren do
&#9;addToGrid(backpackChildren[i])
end

------------------------- Start Lifelong Connections -----------------------


resizeEvent.Event:connect(function(absSize)
&#9;if debounce then return end
&#9;
&#9;debounce = true
&#9;wait()
&#9;resize()
&#9;resizeGrid()
&#9;debounce = false
end)

currentLoadout.ChildAdded:connect(function(child) loadoutCheck(child, false) end)
currentLoadout.ChildRemoved:connect(function(child) loadoutCheck(child, true) end)

currentLoadout.DescendantAdded:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
currentLoadout.DescendantRemoving:connect(function(descendant)
&#9;if not backpack.Visible and ( descendant:IsA(&quot;ImageButton&quot;) or descendant:IsA(&quot;TextButton&quot;) ) then
&#9;&#9;wait()
&#9;&#9;centerGear(currentLoadout:GetChildren())
&#9;end
end)
&#9;
grid.MouseEnter:connect(function() clearPreview() end)
grid.MouseLeave:connect(function() clearPreview() end)

player.CharacterRemoving:connect(function()
&#9;removeCharacterConnections()
&#9;nukeBackpack()
end)
player.CharacterAdded:connect(function() setupCharacterConnections() end)

player.ChildAdded:connect(function(child)
&#9;if child:IsA(&quot;Backpack&quot;) then
&#9;&#9;playerBackpack = child
&#9;&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;end
end)

swapSlot.Changed:connect(function()
&#9;if not swapSlot.Value then
&#9;&#9;updateGridActive()
&#9;end
end)

local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;loadoutChildren[i].ChildRemoved:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;loadoutChildren[i].ChildAdded:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;end
end
------------------------- End Lifelong Connections -----------------------

resize()
resizeGrid()

-- make sure any items in the loadout are accounted for in inventory
local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;loadoutCheck(loadoutChildren[i], false)
end
if not backpack.Visible then centerGear(currentLoadout:GetChildren()) end

-- make sure that inventory is listening to gear reparenting
if characterChildAddedCon == nil and game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;setupCharacterConnections()
end
if not backpackAddCon then
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
end

backpackOpenEvent.Event:connect(backpackOpenHandler)
backpackCloseEvent.Event:connect(backpackCloseHandler)
tabClickedEvent.Event:connect(tabClickHandler)
searchRequestedEvent.Event:connect(showSearchGear)

recalculateScrollLoadout()</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX41">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackResizer</string>
					<ProtectedString name="Source">print(&quot;Making sure BackpackResizer script is doing it&apos;s work...&quot;)
print(&quot;Backpack has been built. Time for the resizer script.&quot;)
script.Parent.BackpackResizer.Parent = script.Parent.Backpack
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end


--rbxsig%mno74b/wRJKHL8Xt9/BxwXVZl+tc9a/CmKlTTsWwuH0ibb5lbU57AjhmG/j/sFf+k7yKL9GKKWCUdPSSH3I6N4Vg02Ru5DtokfUAKrgAAdixtQU0mSgGT3ZI/vNZjH7Dw39RzLgT4rVVyCh38B/pVg0BKcE3SdIXVdeIRPX0cb8=%
--rbxassetid%53878053%

-- A couple of necessary functions
local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
local function waitForProperty(instance, property)
&#9;while not instance[property] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

waitForChild(game,&quot;Players&quot;)
waitForProperty(game.Players,&quot;LocalPlayer&quot;)
local player = game.Players.LocalPlayer

local RbxGui,msg = t
if not RbxGui then print(&quot;could not find RbxGui!&quot;) return end

--- Begin Locals
waitForChild(game,&quot;Players&quot;)

-- don&apos;t do anything if we are in an empty game
if #game.Players:GetChildren() &lt; 1 then
&#9;game.Players.ChildAdded:wait()
end

local tilde = &quot;~&quot;
local backquote = &quot;`&quot;
game:GetService(&quot;GuiService&quot;):AddKey(tilde) -- register our keys
game:GetService(&quot;GuiService&quot;):AddKey(backquote)

local player = game.Players.LocalPlayer

local backpack = script.Parent
local screen = script.Parent.Parent

local openCloseDebounce = false

local backpackItems = {}

local buttons = {}

local debounce = false

local guiTweenSpeed = 1

local backpackOldStateVisible = false
local browsingMenu = false

local mouseEnterCons = {}
local mouseClickCons = {}

local characterChildAddedCon = nil
local characterChildRemovedCon = nil
local backpackAddCon = nil
local humanoidDiedCon = nil
local backpackButtonClickCon = nil
local guiServiceKeyPressCon = nil

local currentLoadout = backpack.Parent.CurrentLoadout
local swapSlot = script.Parent.SwapSlot
local grid = script.Parent.Gear.GearGrid
local scroller = backpack.Gear.GearGridScrollingArea
local gearPreview = backpack.Gear.GearPreview
local playerBackpack = player.Backpack
local currentLoadout = backpack.Parent.CurrentLoadout
local backpackButton = backpack.Parent.ControlFrame.BackpackButton
local gearButton = backpack.Gear.GearGrid.GearButton
local searchBox = backpack.SearchFrame.SearchBoxFrame.SearchBox
local searchButton = backpack.SearchFrame.SearchButton
local gearPreview = backpack.Gear.GearPreview
local resetButton = backpack.SearchFrame.ResetButton



-- creating scroll bar early as to make sure items get placed correctly
local scrollFrame, scrollUp, scrollDown, recalculateScroll = RbxGui.CreateScrollingFrame(nil,&quot;grid&quot;)

scrollFrame.Position = UDim2.new(0,0,0,30)
scrollFrame.Size = UDim2.new(1,0,1,-30)
scrollFrame.Parent = grid

local scrollBar = Instance.new(&quot;Frame&quot;)
scrollBar.Name = &quot;ScrollBar&quot;
scrollBar.BackgroundTransparency = 0.9
scrollBar.BackgroundColor3 = Color3.new(1,1,1)
scrollBar.BorderSizePixel = 0
scrollBar.Size = UDim2.new(0, 17, 1, -36)
scrollBar.Position = UDim2.new(0,0,0,18)
scrollBar.Parent = scroller

scrollDown.Position = UDim2.new(0,0,1,-17)

scrollUp.Parent = scroller
scrollDown.Parent = scroller

local scrollFrameLoadout, scrollUpLoadout, scrollDownLoadout, recalculateScrollLoadout = RbxGui.CreateScrollingFrame()

scrollFrameLoadout.Position = UDim2.new(0,0,0,0)
scrollFrameLoadout.Size = UDim2.new(1,0,1,0)
scrollFrameLoadout.Parent = backpack.Gear.GearLoadouts.LoadoutsList

local LoadoutButton = Instance.new(&quot;TextButton&quot;)
LoadoutButton.Name = &quot;LoadoutButton&quot;
LoadoutButton.Font = Enum.Font.ArialBold
LoadoutButton.FontSize = Enum.FontSize.Size14
LoadoutButton.Position = UDim2.new(0,0,0,0)
LoadoutButton.Size = UDim2.new(1,0,0,32)
LoadoutButton.Style = Enum.ButtonStyle.RobloxButton
LoadoutButton.Text = &quot;Loadout #1&quot;
LoadoutButton.TextColor3 = Color3.new(1,1,1)
LoadoutButton.Parent = scrollFrameLoadout

local LoadoutButtonTwo = LoadoutButton:clone()
LoadoutButtonTwo.Text = &quot;Loadout #2&quot;
LoadoutButtonTwo.Parent = scrollFrameLoadout

local LoadoutButtonThree = LoadoutButton:clone()
LoadoutButtonThree.Text = &quot;Loadout #3&quot;
LoadoutButtonThree.Parent = scrollFrameLoadout

local LoadoutButtonFour = LoadoutButton:clone()
LoadoutButtonFour.Text = &quot;Loadout #4&quot;
LoadoutButtonFour.Parent = scrollFrameLoadout

local scrollBarLoadout = Instance.new(&quot;Frame&quot;)
scrollBarLoadout.Name = &quot;ScrollBarLoadout&quot;
scrollBarLoadout.BackgroundTransparency = 0.9
scrollBarLoadout.BackgroundColor3 = Color3.new(1,1,1)
scrollBarLoadout.BorderSizePixel = 0
scrollBarLoadout.Size = UDim2.new(0, 17, 1, -36)
scrollBarLoadout.Position = UDim2.new(0,0,0,18)
scrollBarLoadout.Parent = backpack.Gear.GearLoadouts.GearLoadoutsScrollingArea

scrollDownLoadout.Position = UDim2.new(0,0,1,-17)

scrollUpLoadout.Parent = script.Parent.Gear.GearLoadouts.GearLoadoutsScrollingArea
scrollDownLoadout.Parent = script.Parent.Gear.GearLoadouts.GearLoadoutsScrollingArea


-- Begin Functions
function removeFromMap(map,object)
&#9;for i = 1, #map do
&#9;&#9;if map[i] == object then
&#9;&#9;&#9;table.remove(map,i)
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end
end

function robloxLock(instance)
end

function resize()
&#9;local size = 0
&#9;if gearPreview.AbsoluteSize.Y &gt; gearPreview.AbsoluteSize.X then
&#9;&#9;size = gearPreview.AbsoluteSize.X * 0.75
&#9;else
&#9;&#9;size = gearPreview.AbsoluteSize.Y * 0.75
&#9;end

&#9;gearPreview.GearImage.Size = UDim2.new(0,size,0,size)
&#9;gearPreview.GearImage.Position = UDim2.new(0,gearPreview.AbsoluteSize.X/2 - size/2,0.75,-size)
&#9;
&#9;resizeGrid()
end

function addToGrid(child)
&#9;if not child:IsA(&quot;Tool&quot;) then
&#9;&#9;if not child:IsA(&quot;HopperBin&quot;) then 
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if child:FindFirstChild(&quot;RobloxBuildTool&quot;) then return end
&#9;
&#9;for i,v in pairs(backpackItems) do  -- check to see if we already have this gear registered
&#9;&#9;if v == child then return end
&#9;end

&#9;table.insert(backpackItems,child)
&#9;
&#9;local changeCon = child.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Name&quot; then
&#9;&#9;&#9;if buttons[child] then
&#9;&#9;&#9;&#9;if buttons[child].Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttons[child].GearText.Text = child.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;local ancestryCon = nil
&#9;ancestryCon = child.AncestryChanged:connect(function(theChild,theParent)
&#9;&#9;local thisObject = nil
&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;if v == child then
&#9;&#9;&#9;&#9;thisObject = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player,&quot;Backpack&quot;)
&#9;&#9;if (child.Parent ~= player.Backpack and child.Parent ~= player.Character) then
&#9;&#9;&#9;if ancestryCon then ancestryCon:disconnect() end
&#9;&#9;&#9;if changeCon then changeCon:disconnect() end
&#9;&#9;&#9;
&#9;&#9;&#9;for k,v in pairs(backpackItems) do
&#9;&#9;&#9;&#9;if v == thisObject then
&#9;&#9;&#9;&#9;&#9;if mouseEnterCons[buttons[v]] then mouseEnterCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;if mouseClickCons[buttons[v]] then mouseClickCons[buttons[v]]:disconnect() end
&#9;&#9;&#9;&#9;&#9;buttons[v].Parent = nil
&#9;&#9;&#9;&#9;&#9;buttons[v] = nil
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;removeFromMap(backpackItems,thisObject)
&#9;&#9;&#9;
&#9;&#9;&#9;resizeGrid()
&#9;&#9;else
&#9;&#9;&#9;resizeGrid()
&#9;&#9;end
&#9;&#9;updateGridActive()
&#9;end)
&#9;resizeGrid()
end

function buttonClick(button)
&#9;if button:FindFirstChild(&quot;UnequipContextMenu&quot;) and not button.Active then
&#9;&#9;button.UnequipContextMenu.Visible = true
&#9;&#9;browsingMenu = true
&#9;end
end

function previewGear(button)
&#9;if not browsingMenu then
&#9;&#9;gearPreview.GearImage.Image = button.Image
&#9;&#9;gearPreview.GearStats.GearName.Text = button.GearReference.Value.Name
&#9;end
end

function checkForSwap(button,x,y)
&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;&#9;if x &gt;= loadoutChildren[i].AbsolutePosition.x and x &lt;= (loadoutChildren[i].AbsolutePosition.x + loadoutChildren[i].AbsoluteSize.x) then
&#9;&#9;&#9;&#9;if y &gt;= loadoutChildren[i].AbsolutePosition.y and y &lt;= (loadoutChildren[i].AbsolutePosition.y + loadoutChildren[i].AbsoluteSize.y) then
&#9;&#9;&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;&#9;&#9;swapGearSlot(slot,button)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function resizeGrid()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if not v:FindFirstChild(&quot;RobloxBuildTool&quot;) then
&#9;&#9;&#9;if not buttons[v] then
&#9;&#9;&#9;&#9;local buttonClone = gearButton:clone()
&#9;&#9;&#9;&#9;buttonClone.Parent = grid.ScrollingFrame
&#9;&#9;&#9;&#9;buttonClone.Visible = true
&#9;&#9;&#9;&#9;buttonClone.Image = v.TextureId
&#9;&#9;&#9;&#9;if buttonClone.Image == &quot;&quot; then
&#9;&#9;&#9;&#9;&#9;buttonClone.GearText.Text = v.Name
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;buttonClone.GearReference.Value = v
&#9;&#9;&#9;&#9;buttonClone.Draggable = true 
&#9;&#9;&#9;&#9;buttons[v] = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local unequipMenu = getGearContextMenu()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;unequipMenu.Visible = false
&#9;&#9;&#9;&#9;unequipMenu.Parent = buttonClone
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local beginPos = nil
&#9;&#9;&#9;&#9;buttonClone.DragBegin:connect(function(value)
&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 9
&#9;&#9;&#9;&#9;&#9;beginPos = value
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;buttonClone.DragStopped:connect(function(x,y)
&#9;&#9;&#9;&#9;&#9;if beginPos ~= buttonClone.Position then
&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.ZIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;if not checkForSwap(buttonClone,x,y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone:TweenPosition(beginPos,Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.5, true)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;buttonClone.Position = beginPos
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;mouseEnterCons[buttonClone] = buttonClone.MouseEnter:connect(function() previewGear(buttonClone) end)
&#9;&#9;&#9;&#9;mouseClickCons[buttonClone] = buttonClone.MouseButton1Click:connect(function() buttonClick(buttonClone) end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;recalculateScroll()
end

function showPartialGrid(subset)


&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = nil
&#9;end
&#9;for k,v in pairs(subset) do
&#9;&#9;v.Parent =  grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function showEntireGrid()
&#9;
&#9;for k,v in pairs(buttons) do
&#9;&#9;v.Parent = grid.ScrollingFrame
&#9;end
&#9;recalculateScroll()
end

function inLoadout(gear)
&#9;local children = currentLoadout:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local button = children[i]:GetChildren()
&#9;&#9;&#9;if #button &gt; 0 then
&#9;&#9;&#9;&#9;if button[1].GearReference.Value and button[1].GearReference.Value == gear then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end&#9;

function updateGridActive()
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gear = nil
&#9;&#9;&#9;local gearRef = buttons[v]:FindFirstChild(&quot;GearReference&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if gearRef then gear = gearRef.Value end
&#9;&#9;&#9;
&#9;&#9;&#9;if not gear then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;elseif inLoadout(gear) then
&#9;&#9;&#9;&#9;buttons[v].Active = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;buttons[v].Active = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function centerGear(loadoutChildren)
&#9;local gearButtons = {}
&#9;local lastSlotAdd = nil
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and #loadoutChildren[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;if loadoutChildren[i].Name == &quot;Slot0&quot; then 
&#9;&#9;&#9;&#9;lastSlotAdd = loadoutChildren[i]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;table.insert(gearButtons, loadoutChildren[i])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if lastSlotAdd then table.insert(gearButtons,lastSlotAdd) end
&#9;
&#9;local startPos = ( 1 - (#gearButtons * 0.1) ) / 2
&#9;for i = 1, #gearButtons do&#9;
&#9;&#9;gearButtons[i]:TweenPosition(UDim2.new(startPos + ((i - 1) * 0.1),0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;end
end

function spreadOutGear(loadoutChildren)
&#9;for i = 1, #loadoutChildren do
&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;local slot = tonumber(string.sub(loadoutChildren[i].Name,5))
&#9;&#9;&#9;if slot == 0 then slot = 10 end
&#9;&#9;&#9;loadoutChildren[i]:TweenPosition(UDim2.new((slot - 1)/10,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
&#9;&#9;end
&#9;end
end

function openCloseBackpack()
&#9;if backpack.Visible == true then
&#9;&#9;updateGridActive()
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;loadoutChildren[i].BackgroundTransparency = 0.5
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;spreadOutGear(loadoutChildren)

&#9;&#9;--[[backpackButton.Selected = true
&#9;&#9;backpack:TweenSizeAndPosition(UDim2.new(0.55, 0, 0.6, 0),UDim2.new(0.225, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, guiTweenSpeed/2, true)
&#9;&#9;delay(guiTweenSpeed/2 + 0.01,
&#9;&#9;&#9;function()--]]
&#9;&#9;&#9;&#9;local children = backpack:getChildren()
&#9;&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;children[i].Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;resizeGrid()
&#9;&#9;&#9;&#9;resize()
&#9;&#9;&#9;&#9;openCloseDebounce = false


&#9;end
end

function loadoutCheck(child, selectState)
&#9;if not child:IsA(&quot;ImageButton&quot;) then return end
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;if child:FindFirstChild(&quot;GearReference&quot;) then
&#9;&#9;&#9;&#9;if buttons[v].GearReference.Value == child.GearReference.Value then
&#9;&#9;&#9;&#9;&#9;buttons[v].Active = selectState
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function clearPreview()
&#9;gearPreview.GearImage.Image = &quot;&quot;
&#9;gearPreview.GearStats.GearName.Text = &quot;&quot;
end

function removeAllEquippedGear(physGear)
&#9;local stuff = player.Character:GetChildren()
&#9;for i = 1, #stuff do
&#9;&#9;if ( stuff[i]:IsA(&quot;Tool&quot;) or stuff[i]:IsA(&quot;HopperBin&quot;) ) and stuff[i] ~= physGear then
&#9;&#9;&#9;stuff[i].Parent = playerBackpack
&#9;&#9;end
&#9;end
end

function equipGear(physGear)
&#9;removeAllEquippedGear(physGear)
&#9;physGear.Parent = player.Character
&#9;updateGridActive()
end

function unequipGear(physGear)
&#9;physGear.Parent = playerBackpack
&#9;updateGridActive()
end

function highlight(button)
&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
end
function clearHighlight(button)
&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;button.BackgroundColor3 = Color3.new(0,0,0)
end

function swapGearSlot(slot,gearButton)
&#9;if not swapSlot.Value then -- signal loadout to swap a gear out
&#9;&#9;swapSlot.Slot.Value = slot
&#9;&#9;swapSlot.GearButton.Value = gearButton
&#9;&#9;swapSlot.Value = true
&#9;&#9;updateGridActive()
&#9;end
end


local UnequipGearMenuClick = function(element, menu)
&#9;if type(element.Action) ~= &quot;number&quot; then return end
&#9;local num = element.Action
&#9;if num == 1 then -- remove from loadout
&#9;&#9;unequipGear(menu.Parent.GearReference.Value)
&#9;&#9;local inventoryButton = menu.Parent
&#9;&#9;local gearToUnequip = inventoryButton.GearReference.Value
&#9;&#9;local loadoutChildren = currentLoadout:GetChildren()
&#9;&#9;local slot = -1
&#9;&#9;for i = 1, #loadoutChildren do
&#9;&#9;&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;&#9;local button = loadoutChildren[i]:GetChildren()
&#9;&#9;&#9;&#9;if button[1] and button[1].GearReference.Value == gearToUnequip then
&#9;&#9;&#9;&#9;&#9;slot = button[1].SlotNumber.Text
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;swapGearSlot(slot,nil)
&#9;end
end

-- these next two functions are used to stop any use of backpack while the player is dead (can cause issues)
function activateBackpack()
&#9;backpack.Visible = backpackOldStateVisible
&#9;
&#9;backpackButtonClickCon = backpackButton.MouseButton1Click:connect(function() openCloseBackpack() end)
&#9;guiServiceKeyPressCon = game:GetService(&quot;GuiService&quot;).KeyPressed:connect(function(key)
&#9;&#9;if key == tilde or key == backquote then
&#9;&#9;&#9;openCloseBackpack()
&#9;&#9;end
&#9;end)
end
function deactivateBackpack()
&#9;if backpackButtonClickCon then backpackButtonClickCon:disconnect() end
&#9;if guiServiceKeyPressCon then guiServiceKeyPressCon:disconnect() end

&#9;backpackOldStateVisible = backpack.Visible
&#9;backpack.Visible = false
end

function setupCharacterConnections()

&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;
&#9;-- make sure we get all the children
&#9;local backpackChildren = game.Players.LocalPlayer.Backpack:GetChildren()
&#9;for i = 1, #backpackChildren do
&#9;&#9;addToGrid(backpackChildren[i])
&#9;end

&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;characterChildAddedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildAdded:connect(function(child)
&#9;&#9;&#9;addToGrid(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;characterChildRemovedCon = 
&#9;&#9;game.Players.LocalPlayer.Character.ChildRemoved:connect(function(child)
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;
&#9;&#9;&#9;
&#9;if humanoidDiedCon then humanoidDiedCon:disconnect() end
&#9;local localPlayer = game.Players.LocalPlayer
&#9;waitForProperty(localPlayer,&quot;Character&quot;)
&#9;waitForChild(localPlayer.Character,&quot;Humanoid&quot;)
&#9;humanoidDiedCon = game.Players.LocalPlayer.Character.Humanoid.Died:connect(function() deactivateBackpack() end)
&#9;
&#9;activateBackpack()
end

function removeCharacterConnections()
&#9;if characterChildAddedCon then characterChildAddedCon:disconnect() end
&#9;if characterChildRemovedCon then characterChildRemovedCon:disconnect() end
&#9;if backpackAddCon then backpackAddCon:disconnect() end
end

function trim(s)
  return (s:gsub(&quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end

function splitByWhiteSpace(text)
&#9;if type(text) ~= &quot;string&quot; then return nil end
&#9;
&#9;local terms = {}
&#9;for token in string.gmatch(text, &quot;[^%s]+&quot;) do
&#9;   if string.len(token) &gt; 2 then
&#9;&#9;&#9;table.insert(terms,token)
&#9;   end
&#9;end
&#9;return terms
end

function filterGear(searchTerm)
&#9;string.lower(searchTerm)
&#9;searchTerm = trim(searchTerm)
&#9;if string.len(searchTerm) &lt; 2 then return nil end
&#9;local terms = splitByWhiteSpace(searchTerm)
&#9;
&#9;local filteredGear = {}
&#9;for k,v in pairs(backpackItems) do
&#9;&#9;if buttons[v] then
&#9;&#9;&#9;local gearString = string.lower(buttons[v].GearReference.Value.Name)
&#9;&#9;&#9;gearString = trim(gearString)
&#9;&#9;&#9;for i = 1, #terms do
&#9;&#9;&#9;&#9;if string.match(gearString,terms[i]) then
&#9;&#9;&#9;&#9;&#9;table.insert(filteredGear,buttons[v])
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return filteredGear
end


function showSearchGear()
   local searchBox = backpack.SearchFrame.SearchBoxFrame.SearchBox
&#9;local searchText = searchBox.Text
&#9;searchBox.Text = &quot;Search...&quot;
&#9;local filteredButtons = filterGear(searchText)
&#9;if filteredButtons and #filteredButtons &gt; 0 then
&#9;&#9;showPartialGrid(filteredButtons)
&#9;else
&#9;&#9;showEntireGrid()
&#9;end
end

function nukeBackpack()
&#9;while #buttons &gt; 0 do
&#9;&#9;table.remove(buttons)
&#9;end
&#9;buttons = {}
&#9;while #backpackItems &gt; 0 do
&#9;&#9;table.remove(backpackItems)
&#9;end
&#9;backpackItems = {}
&#9;local scrollingFrameChildren = grid.ScrollingFrame:GetChildren()
&#9;for i = 1, #scrollingFrameChildren do
&#9;&#9;scrollingFrameChildren[i]:remove()
&#9;end
end

function getGearContextMenu()
&#9;local gearContextMenu = Instance.new(&quot;Frame&quot;)
&#9;gearContextMenu.Active = true
&#9;gearContextMenu.Name = &quot;UnequipContextMenu&quot;
&#9;gearContextMenu.Size = UDim2.new(0,115,0,70)
&#9;gearContextMenu.Position = UDim2.new(0,-16,0,-16)
&#9;gearContextMenu.BackgroundTransparency = 1
&#9;gearContextMenu.Visible = false

&#9;local gearContextMenuButton = Instance.new(&quot;TextButton&quot;)
&#9;gearContextMenuButton.Name = &quot;UnequipContextMenuButton&quot;
&#9;gearContextMenuButton.Text = &quot;&quot;
&#9;gearContextMenuButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;gearContextMenuButton.ZIndex = 4
&#9;gearContextMenuButton.Size = UDim2.new(1, 0, 1, -20)
&#9;gearContextMenuButton.Visible = true
&#9;gearContextMenuButton.Parent = gearContextMenu
&#9;
&#9;local elementHeight = 12
&#9;
&#9;local contextMenuElements = {}&#9;&#9;
&#9;local contextMenuElementsName = {&quot;Remove Hotkey&quot;}

&#9;for i = 1, #contextMenuElementsName do
&#9;&#9;local element = {}
&#9;&#9;element.Type = &quot;Button&quot;
&#9;&#9;element.Text = contextMenuElementsName[i]
&#9;&#9;element.Action = i
&#9;&#9;element.DoIt = UnequipGearMenuClick
&#9;&#9;table.insert(contextMenuElements,element)
&#9;end

&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;local element = contextElement
&#9;&#9;if element.Type == &quot;Button&quot; then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = &quot;UnequipContextButton&quot; .. i
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;button.Text = &quot; &quot; .. contextElement.Text
&#9;&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;&#9;button.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;button.Size = UDim2.new(1, 8, 0, elementHeight)
&#9;&#9;&#9;button.Position = UDim2.new(0,0,0,elementHeight * i)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.ZIndex = 4
&#9;&#9;&#9;button.Parent = gearContextMenuButton

&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;if button.Active and not gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;local success, result = pcall(function() element.DoIt(element, gearContextMenu) end)
&#9;&#9;&#9;&#9;&#9;browsingMenu = false
&#9;&#9;&#9;&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;&#9;clearPreview()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;highlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if button.Active and gearContextMenu.Parent.Active then
&#9;&#9;&#9;&#9;&#9;clearHighlight(button)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;contextElement.Button = button
&#9;&#9;&#9;contextElement.Element = button
&#9;&#9;elseif element.Type == &quot;Label&quot; then
&#9;&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;frame.Name = &quot;ContextLabel&quot; .. i
&#9;&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;&#9;frame.Size = UDim2.new(1, 8, 0, elementHeight)

&#9;&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;label.Name = &quot;Text1&quot;
&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;label.Position = UDim2.new(0.0, 0, 0, 0)
&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;element.Label1 = label
&#9;&#9;
&#9;&#9;&#9;if element.GetText2 then
&#9;&#9;&#9;&#9;label = Instance.new(&quot;TextLabel&quot;)&#9;
&#9;&#9;&#9;&#9;label.Name = &quot;Text2&quot;
&#9;&#9;&#9;&#9;label.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;label.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;&#9;&#9;label.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;label.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;label.Position = UDim2.new(0.5, 0, 0, 0)
&#9;&#9;&#9;&#9;label.Size = UDim2.new(0.5, 0, 1, 0)
&#9;&#9;&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;label.ZIndex = 4
&#9;&#9;&#9;&#9;label.Parent = frame
&#9;&#9;&#9;&#9;element.Label2 = label
&#9;&#9;&#9;end
&#9;&#9;&#9;frame.Parent = gearContextMenuButton
&#9;&#9;&#9;element.Label = frame
&#9;&#9;&#9;element.Element =  frame
&#9;&#9;end
&#9;end

&#9;gearContextMenu.ZIndex = 4
&#9;gearContextMenu.MouseLeave:connect(function()
&#9;&#9;browsingMenu = false
&#9;&#9;gearContextMenu.Visible = false
&#9;&#9;clearPreview()
&#9;end)
&#9;robloxLock(gearContextMenu)
&#9;
&#9;return gearContextMenu
end

local backpackChildren = player.Backpack:GetChildren()
for i = 1, #backpackChildren do
&#9;addToGrid(backpackChildren[i])
end

------------------------- Start Lifelong Connections -----------------------
screen.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;if debounce then return end
&#9;&#9;debounce = true
&#9;&#9;wait()
&#9;&#9;resize()
&#9;&#9;resizeGrid()
&#9;&#9;debounce = false
&#9;end
end)

currentLoadout.ChildAdded:connect(function(child) loadoutCheck(child, false) end)
currentLoadout.ChildRemoved:connect(function(child) loadoutCheck(child, true) end)

grid.MouseEnter:connect(function() clearPreview() end)
grid.MouseLeave:connect(function() clearPreview() end)

player.CharacterRemoving:connect(function()
&#9;removeCharacterConnections()
&#9;nukeBackpack()
end)
player.CharacterAdded:connect(function() setupCharacterConnections() end)

player.ChildAdded:connect(function(child)
&#9;if child:IsA(&quot;Backpack&quot;) then
&#9;&#9;playerBackpack = child
&#9;&#9;if backpackAddCon then backpackAddCon:disconnect() end
&#9;&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
&#9;end
end)

swapSlot.Changed:connect(function()
&#9;if not swapSlot.Value then
&#9;&#9;updateGridActive()
&#9;end
end)

searchBox.FocusLost:connect(function(enterPressed)
&#9;if enterPressed then
&#9;&#9;showSearchGear()
&#9;end
end)

local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;if loadoutChildren[i]:IsA(&quot;Frame&quot;) and string.find(loadoutChildren[i].Name,&quot;Slot&quot;) then
&#9;&#9;loadoutChildren[i].ChildRemoved:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;&#9;loadoutChildren[i].ChildAdded:connect(function()
&#9;&#9;&#9;updateGridActive()
&#9;&#9;end)
&#9;end
end

searchButton.MouseButton1Click:connect(function() showSearchGear() end)
------------------------- End Lifelong Connections -----------------------

resize()
resizeGrid()

-- make sure any items in the loadout are accounted for in inventory
local loadoutChildren = currentLoadout:GetChildren()
for i = 1, #loadoutChildren do
&#9;loadoutCheck(loadoutChildren[i], false)
end

-- make sure that inventory is listening to gear reparenting
if characterChildAddedCon == nil and game.Players.LocalPlayer[&quot;Character&quot;] then
&#9;setupCharacterConnections()
end
if not backpackAddCon then
&#9;backpackAddCon = game.Players.LocalPlayer.Backpack.ChildAdded:connect(function(child) addToGrid(child) end)
end


&#9;backpackButton.Visible = true


recalculateScrollLoadout()</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX42">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Workaround</string>
					<ProtectedString name="Source">wait(0.1)
game.Players.LocalPlayer.PlayerGui.Backpack.BackpackResizer.Disabled = true
game.Players.LocalPlayer.PlayerGui.Backpack.BackpackResizer.Disabled = false
game.Players.LocalPlayer.PlayerGui.Backpack.CurrentLoadout.Visible = true</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>